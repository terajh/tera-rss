[
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "[알고리즘] 이분탐색 (Binary Search) —정렬, O(logN), 매개변수 탐색",
    "partialText": "<h1 id=\"이분탐색-binary-search\">이분탐색 (Binary Search)</h1>\n<h2 id=\"1-이분탐색-원리\">1. 이분탐색 원리</h2>\n<h3 id=\"11-이분탐색이란\">1.1 이분탐색이란?</h3>\n<p>이분탐색(Binary Search)은 <strong>정렬된 데이터</strong>에서 원하는 값을 찾기 위해 탐색 범위를 <strong>매 단계마다 절반으로 줄여나가는</strong> 알고리즘이다. 선형 탐색(Linear Search)이 최악의 경우 N번의 비교가 필요한 반면, 이분탐색은 <strong>O(log N)</strong>에 탐색을 완료한다.</p>\n<h3 id=\"12-전제조건-정렬된-데이터\">1.2 전제조건: 정렬된 데이터</h3>\n<p>이분탐색의 핵심 전제는 <strong>데이터가 반드시 정렬되어 있어야 한다</strong>는 것이다.</p>\n<p>정렬되지 않은 배열에서 이분탐색을 수행하면, 중간값 기준으로 &quot;왼쪽에 있다/오른쪽에 있다&quot;는 판단 자체가 보장되지 않기 때문에 올바른 결과를 얻을 수 없다.</p>\n<blockquote>\n<p>💡 <strong>정렬 비용을 고려하자</strong>: 정렬되지 않은 배열이라면 정렬(<code>O(N log N)</code>) 후 이분탐색(<code>O(log N)</code>)을 적용하는 전략이 유효하다. 다만 탐색이 딱 한 번뿐이라면 선형 탐색(<code>O(N)</code>)이 더 효율적일 수 있다. 탐색 횟수가 많을수록 정렬 + 이분탐색 조합이 유리해진다.</p>\n</blockquote>\n<h3 id=\"13-시간복잡도-olog-n의-직관적-이해\">1.3 시간복잡도 O(log N)의 직관적 이해</h3>\n<p>배열의 크기가 N일 때, 이분탐색은 매 단계에서 탐색 범위를 절반으로 줄인다.</p>\n<pre><code>단계 0: 탐색 범위 = N\n단계 1: 탐색 범위 = N/2\n단계 2: 탐색 범위 = N/4\n단계 3: 탐색 범위 = N/8\n...\n단계 k: 탐색 범위 = N / 2^k</code></pre><p>탐색이 종료되는 시점은 범위가 1 이하가 될 때이므로:</p>\n<pre><code>N / 2^k = 1\n→ 2^k = N\n→ k = log₂(N)</code></pre><table>\n<thead>\n<tr>\n<th align=\"center\">N (배열 크기)</th>\n<th align=\"center\">선형 탐색 (최악)</th>\n<th align=\"center\">이분탐색 (최악)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">100</td>\n<td align=\"center\">100회</td>\n<td align=\"center\">7회</td>\n</tr>\n<tr>\n<td align=\"center\">10,000</td>\n<td align=\"center\">10,000회</td>\n<td align=\"center\">14회</td>\n</tr>\n<tr>\n<td align=\"center\">1,000,000</td>\n<td align=\"center\">1,000,000회</td>\n<td align=\"center\">20회</td>\n</tr>\n<tr>\n<td align=\"center\">10억</td>\n<td align=\"center\">10억 회</td>\n<td align=\"center\">30회</td>\n</tr>\n</tbody></table>\n<p>10억 개의 데이터에서도 최대 30번의 비교로 원하는 값을 찾을 수 있다. 이것이 이분탐색의 강력함이다.</p>\n<h3 id=\"14-left-right-mid-포인터의-역할과-갱신-규칙\">1.4 <code>left</code>, <code>right</code>, <code>mid</code> 포인터의 역할과 갱신 규칙</h3>\n<p>이분탐색의 세 가지 핵심 포인터:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">포인터</th>\n<th align=\"left\">역할</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>left</code></td>\n<td align=\"left\">현재 탐색 범위의 <strong>시작</strong> 인덱스</td>\n</tr>\n<tr>\n<td align=\"center\"><code>right</code></td>\n<td align=\"left\">현재 탐색 범위의 <strong>끝</strong> 인덱스</td>\n</tr>\n<tr>\n<td align=\"center\"><code>mid</code></td>\n<td align=\"left\">현재 탐색 범위의 <strong>중간</strong> 인덱스. 이 위치의 값과 타겟을 비교한다</td>\n</tr>\n</tbody></table>\n<p><strong>갱신 규칙 (오름차순 정렬 기준):</strong></p>\n<pre><code>arr[mid] == target → 찾았다! → return mid\narr[mid] &lt; target  → 타겟은 오른쪽에 있다 → left = mid + 1\narr[mid] &gt; target  → 타겟은 왼쪽에 있다  → right = mid - 1</code></pre><p><strong><code>mid</code> 계산 시 오버플로우 방지:</strong></p>\n<pre><code class=\"language-java\">// ❌ 오버플로우 위험 (left + right가 int 범위를 초과할 수 있음)\nint mid = (left + right) / 2;\n\n// ✅ 안전한 계산\nint mid = left + (right - left) / 2;</code></pre>\n<p><code>left</code>와 <code>right</code>가 모두 큰 양수일 때, <code>left + right</code>가 <code>Integer.MAX_VALUE</code>를 초과하여 음수가 될 수 있다. <code>left + (right - left) / 2</code>는 이를 방지한다.</p>\n<h3 id=\"15-반복문iterative-구현-vs-재귀recursive-구현\">1.5 반복문(iterative) 구현 vs 재귀(recursive) 구현</h3>\n<h4 id=\"반복문-구현-권장\">반복문 구현 (권장)</h4>\n<pre><code class=\"language-java\">/**\n * 정렬된 배열에서 target의 인덱스를 반환한다.\n * 존재하지 않으면 -1을 반환한다.\n */\npublic static int binarySearch(int[] arr, int target) {\n    int left = 0;\n    int right = arr.length - 1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid;         // 찾았다!\n        } else if (arr[mid] &lt; target) {\n            left = mid + 1;     // 오른쪽 절반 탐색\n        } else {\n            right = mid - 1;    // 왼쪽 절반 탐색\n        }\n    }\n\n    return -1;  // 못 찾았다\n}</code></pre>\n<h4 id=\"재귀-구현\">재귀 구현</h4>\n<pre><code class=\"language-java\">public static int binarySearchRecursive(int[] arr, int target, int left, int right) {\n    if (left &gt; right) {\n        return -1;  // 기저 조건: 탐색 범위 소진\n    }\n\n    int mid = left + (right - left) / 2;\n\n    if (arr[mid] == target) {\n        return mid;\n    } else if (arr[mid] &lt; target) {\n        return binarySearchRecursive(arr, target, mid + 1, right);\n    } else {\n        return binarySearchRecursive(arr, target, left, mid - 1);\n    }\n}</code></pre>\n<h4 id=\"비교\">비교</h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">항목</th>\n<th align=\"center\">반복문 (Iterative)</th>\n<th align=\"center\">재귀 (Recursive)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">스택 사용</td>\n<td align=\"center\">X (상수 공간)</td>\n<td align=\"center\">O (O(log N) 호출 스택)</td>\n</tr>\n<tr>\n<td align=\"center\">StackOverflow 위험</td>\n<td align=\"center\">없음</td>\n<td align=\"center\">이론적으로 있음 (실전에서는 거의 없음)</td>\n</tr>\n<tr>\n<td align=\"center\">가독성</td>\n<td align=\"center\">직관적</td>\n<td align=\"center\">수학적으로 깔끔</td>\n</tr>\n<tr>\n<td align=\"center\">성능</td>\n<td align=\"center\">함수 호출 오버헤드 없음</td>\n<td align=\"center\">미미한 오버헤드</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>코딩 테스트 권장</strong></td>\n<td align=\"center\"><strong>✅ 권장</strong></td>\n<td align=\"center\">특별한 이유 없으면 비권장</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>💡 <strong>실전 팁</strong>: 코딩 테스트에서는 반복문 구현을 사용하자. 재귀는 불필요한 호출 스택을 쌓고, 디버깅도 어렵다. 이분탐색은 꼬리 재귀(tail recursion)이므로 반복문으로의 변환이 자연스럽다.</p>\n</blockquote>\n<h3 id=\"16-종료-조건-left--right-vs-left--right\">1.6 종료 조건: <code>left &lt;= right</code> vs <code>left &lt; right</code></h3>\n<p>이분탐색에서 가장 헷갈리는 부분 중 하나가 종료 조건이다. 두 가지 스타일이 있으며, 각각 의미가 다르다.</p>\n<h4 id=\"스타일-a-while-left--right--닫힌-구간-left-right\">스타일 A: <code>while (left &lt;= right)</code> — 닫힌 구간 <code>[left, right]</code></h4>\n<pre><code class=\"language-java\">int left = 0, right = n - 1;  // [0, n-1]\n\nwhile (left &lt;= right) {\n    int mid = left + (right - left) / 2;\n    if (arr[mid] == target) return mid;\n    else if (arr[mid] &lt; target) left = mid + 1;\n    else right = mid - 1;\n}\n// 종료 시 left &gt; right → 탐색 범위가 완전히 소진됨</code></pre>\n<ul>\n<li><strong>탐색 범위</strong>: <code>[left, right]</code> (양쪽 끝 포함)</li>\n<li><strong>갱신</strong>: <code>left = mid + 1</code> / <code>right = mid - 1</code> (mid는 이미 확인했으므로 제외)</li>\n<li><strong>종료 시점</strong>: <code>left &gt; right</code>, 즉 탐색 범위가 비어있음</li>\n<li><strong>용도</strong>: <strong>정확한 값을 찾을 때</strong> (존재 여부 판별)</li>\n</ul>\n<h4 id=\"스타일-b-while-left--right--반닫힌-구간-left-right\">스타일 B: <code>while (left &lt; right)</code> — 반닫힌 구간 <code>[left, right)</code></h4>\n<pre><code class=\"language-java\">int left = 0, right = n;  // [0, n)\n\nwhile (left &lt; right) {\n    int mid = left + (right - left) / 2;\n    if (check(mid)) right = mid;      // mid가 조건을 만족하면, mid 포함하여 왼쪽 탐색\n    else left = mid + 1;               // 만족하지 않으면, mid 제외하고 오른쪽 탐색\n}\n// 종료 시 left == right → 이 위치가 경계(답)</code></pre>\n<ul>\n<li><strong>탐색 범위</strong>: <code>[left, right)</code> (right은 미포함)</li>\n<li><strong>갱신</strong>: <code>left = mid + 1</code> / <code>right = mid</code> (right는 &quot;미포함 경계&quot;이므로 mid를 그대로 넣어도 중복 확인 안 함)</li>\n<li><strong>종료 시점</strong>: <code>left == right</code>, 이 위치가 곧 경계점(답)</li>\n<li><strong>용도</strong>: <strong>Lower Bound, Upper Bound, 매개변수 탐색</strong> 등 경계를 찾을 때</li>\n</ul>\n<h4 id=\"정리-어떤-종료-조건을-쓸까\">정리: 어떤 종료 조건을 쓸까?</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">상황</th>\n<th align=\"center\">종료 조건</th>\n<th align=\"left\">갱신 규칙</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">값의 존재 여부 / 인덱스 찾기</td>\n<td align=\"center\"><code>left &lt;= right</code></td>\n<td align=\"left\"><code>left = mid + 1</code>, <code>right = mid - 1</code></td>\n</tr>\n<tr>\n<td align=\"left\">경계(Lower/Upper Bound) 찾기</td>\n<td align=\"center\"><code>left &lt; right</code></td>\n<td align=\"left\"><code>left = mid + 1</code>, <code>right = mid</code></td>\n</tr>\n<tr>\n<td align=\"left\">매개변수 탐색</td>\n<td align=\"center\"><code>left &lt; right</code></td>\n<td align=\"left\">조건에 따라 다름 (뒤에서 상세 설명)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>⚠️ <strong>주의</strong>: <code>left &lt; right</code>를 쓸 때 <code>right = mid - 1</code>로 갱신하면 무한루프에 빠질 수 있다. <code>right = mid</code>로 갱신해야 한다. 반대로 <code>left &lt;= right</code>를 쓸 때 <code>right = mid</code>로 갱신하면 마찬가지로 무한루프 위험이 있다. <strong>종료 조건과 갱신 규칙은 반드시 세트로 외우자.</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"2-lower-bound--upper-bound\">2. Lower Bound / Upper Bound</h2>\n<h3 id=\"21-개념-정의\">2.1 개념 정의</h3>\n<p>정렬된 배열에서 특정 값 <code>target</code>에 대해:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">개념</th>\n<th align=\"left\">정의</th>\n<th align=\"left\">의미</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>Lower Bound</strong></td>\n<td align=\"left\"><code>target</code> <strong>이상</strong>인 값이 <strong>처음</strong> 나타나는 위치</td>\n<td align=\"left\"><code>target</code>이 들어갈 수 있는 <strong>가장 왼쪽</strong> 위치</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>Upper Bound</strong></td>\n<td align=\"left\"><code>target</code>을 <strong>초과</strong>하는 값이 <strong>처음</strong> 나타나는 위치</td>\n<td align=\"left\"><code>target</code>이 들어갈 수 있는 <strong>가장 오른쪽 + 1</strong> 위치</td>\n</tr>\n</tbody></table>\n<p>시각적으로 보면:</p>\n<pre><code>배열: [1, 2, 3, 3, 3, 5, 7]\n인덱스: 0  1  2  3  4  5  6\n\ntarget = 3일 때:\nLower Bound = 2  (arr[2] = 3, 처음으로 3 이상)\nUpper Bound = 5  (arr[5] = 5, 처음으로 3 초과)\n\ntarget = 4일 때 (배열에 없는 값):\nLower Bound = 5  (arr[5] = 5, 처음으로 4 이상)\nUpper Bound = 5  (arr[5] = 5, 처음으로 4 초과)\n\ntarget = 8일 때 (배열 최댓값보다 큰 값):\nLower Bound = 7  (배열 밖, 즉 arr.length)\nUpper Bound = 7  (배열 밖, 즉 arr.length)</code></pre><h3 id=\"22-특정-값의-개수-구하기\">2.2 특정 값의 개수 구하기</h3>\n<pre><code>target의 개수 = Upper Bound - Lower Bound</code></pre><p>위 예시에서 <code>target = 3</code>:</p>\n<pre><code>Upper Bound(5) - Lower Bound(2) = 3 → 3이 3개 존재</code></pre><p><code>target = 4</code> (없는 값):</p>\n<pre><code>Upper Bound(5) - Lower Bound(5) = 0 → 4가 0개 존재</code></pre><p>이 공식이 성립하는 이유: Lower Bound는 <code>target</code>이 시작되는 위치, Upper Bound는 <code>target</code> 바로 다음 위치이므로, 그 차이가 곧 <code>target</code>의 개수이다.</p>\n<h3 id=\"23-java에서-직접-구현\">2.3 Java에서 직접 구현</h3>\n<h4 id=\"lower-bound\">Lower Bound</h4>\n<pre><code class=\"language-java\">/**\n * target 이상인 값이 처음 나타나는 인덱스를 반환한다.\n * 모든 원소가 target 미만이면 arr.length를 반환한다.\n */\npublic static int lowerBound(int[] arr, int target) {\n    int left = 0;\n    int right = arr.length;  // 주의: n-1이 아니라 n\n\n    while (left &lt; right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] &gt;= target) {\n            right = mid;       // mid가 target 이상이면 → 더 왼쪽에 답이 있을 수 있음\n        } else {\n            left = mid + 1;    // mid가 target 미만이면 → mid는 답이 될 수 없음\n        }\n    }\n\n    return left;  // left == right, 이 위치가 Lower Bound\n}</code></pre>\n<p><strong>동작 흐름 (arr = [1, 2, 3, 3, 3, 5, 7], target = 3):</strong></p>\n<pre><code>초기: left=0, right=7\nmid=3 → arr[3]=3 &gt;= 3 → right=3  → [0, 3)\nmid=1 → arr[1]=2 &lt;  3 → left=2   → [2, 3)\nmid=2 → arr[2]=3 &gt;= 3 → right=2  → [2, 2)\n종료: left==right==2 ✅</code></pre><h4 id=\"upper-bound\">Upper Bound</h4>\n<pre><code class=\"language-java\">/**\n * target을 초과하는 값이 처음 나타나는 인덱스를 반환한다.\n * 모든 원소가 target 이하이면 arr.length를 반환한다.\n */\npublic static int upperBound(int[] arr, int target) {\n    int left = 0;\n    int right = arr.length;\n\n    while (left &lt; right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] &gt; target) {\n            right = mid;       // mid가 target 초과이면 → 더 왼쪽에 답이 있을 수 있음\n        } else {\n            left = mid + 1;    // mid가 target 이하이면 → mid는 답이 될 수 없음\n        }\n    }\n\n    return left;\n}</code></pre>\n<blockquote>\n<p>💡 <strong>Lower Bound와 Upper Bound의 차이점은 딱 하나</strong>: 조건문에서 <code>&gt;=</code>를 쓰느냐 <code>&gt;</code>를 쓰느냐의 차이뿐이다. <code>&gt;=</code>이면 <code>target</code>과 같은 값도 오른쪽으로 밀어내므로 Lower Bound, <code>&gt;</code>이면 <code>target</code>과 같은 값은 왼쪽에 남기므로 Upper Bound가 된다.</p>\n</blockquote>\n<h3 id=\"24-lower-bound--upper-bound-활용-패턴\">2.4 Lower Bound / Upper Bound 활용 패턴</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">문제</th>\n<th align=\"left\">풀이</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>target</code>이 배열에 존재하는가?</td>\n<td align=\"left\"><code>lb = lowerBound(target)</code> → <code>lb &lt; n &amp;&amp; arr[lb] == target</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>target</code>의 개수</td>\n<td align=\"left\"><code>upperBound(target) - lowerBound(target)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>target</code> 미만인 원소의 개수</td>\n<td align=\"left\"><code>lowerBound(target)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>target</code> 이하인 원소의 개수</td>\n<td align=\"left\"><code>upperBound(target)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>target</code> 이상인 원소 중 최솟값</td>\n<td align=\"left\"><code>arr[lowerBound(target)]</code> (범위 체크 필요)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>target</code> 이하인 원소 중 최댓값</td>\n<td align=\"left\"><code>arr[upperBound(target) - 1]</code> (범위 체크 필요)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"3-java-표준-라이브러리의-이분탐색\">3. Java 표준 라이브러리의 이분탐색</h2>\n<h3 id=\"31-arraysbinarysearch\">3.1 <code>Arrays.binarySearch()</code></h3>\n<pre><code class=\"language-java\">import java.util.Arrays;\n\nint[] arr = {1, 3, 5, 7, 9, 11};\n\nint idx = Arrays.binarySearch(arr, 7);\n// idx = 3 (값 7이 인덱스 3에 위치)\n\nint idx2 = Arrays.binarySearch(arr, 6);\n// idx2 = -4 (값 6이 없음)</code></pre>\n<p><strong>반환값 규칙:</strong></p>\n<ul>\n<li>값을 <strong>찾은 경우</strong>: 해당 값의 인덱스 (0 이상)</li>\n<li>값을 <strong>못 찾은 경우</strong>: <code>-(insertion point) - 1</code> (음수)</li>\n</ul>\n<p>여기서 <strong>insertion point</strong>란, 해당 값이 삽입되어야 할 위치(정렬 순서를 유지하기 위해)를 의미한다.</p>\n<pre><code class=\"language-java\">// 못 찾았을 때 insertion point 추출하기\nint result = Arrays.binarySearch(arr, 6);\nif (result &lt; 0) {\n    int insertionPoint = -(result + 1);  // = -((-4) + 1) = 3\n    // 6은 인덱스 3에 삽입되어야 함 (5와 7 사이)\n}</code></pre>\n<p><strong>부분 배열 탐색:</strong></p>\n<pre><code class=\"language-java\">// fromIndex(inclusive) ~ toIndex(exclusive) 범위에서 탐색\nArrays.binarySearch(arr, 1, 4, target);  // arr[1] ~ arr[3] 범위</code></pre>\n<h3 id=\"32-collectionsbinarysearch\">3.2 <code>Collections.binarySearch()</code></h3>\n<p><code>List</code> 자료구조에 대한 이분탐색이다. 반환값 규칙은 <code>Arrays.binarySearch()</code>와 동일하다.</p>\n<pre><code class=\"language-java\">import java.util.Collections;\nimport java.util.List;\n\nList&lt;Integer&gt; list = List.of(1, 3, 5, 7, 9);\n\nint idx = Collections.binarySearch(list, 5);\n// idx = 2</code></pre>\n<blockquote>\n<p>⚠️ <code>Collections.binarySearch()</code>는 <code>RandomAccess</code>를 구현하지 않는 List(예: <code>LinkedList</code>)에서도 동작하지만, <code>O(N)</code>이 되어 이분탐색의 이점이 사라진다. <code>ArrayList</code> 또는 배열 기반 리스트에서만 사용하자.</p>\n</blockquote>\n<h3 id=\"33-표준-라이브러리의-한계\">3.3 표준 라이브러리의 한계</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">한계점</th>\n<th align=\"left\">설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>중복 원소 처리 불가</strong></td>\n<td align=\"left\">배열에 같은 값이 여러 개 있을 때, 어떤 인덱스를 반환할지 보장되지 않음</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Lower Bound 미지원</strong></td>\n<td align=\"left\">&quot;target 이상인 첫 위치&quot;를 직접 구할 수 없음</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Upper Bound 미지원</strong></td>\n<td align=\"left\">&quot;target 초과인 첫 위치&quot;를 직접 구할 수 없음</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>유연성 부족</strong></td>\n<td align=\"left\">매개변수 탐색 등 커스텀 조건 함수 사용 불가</td>\n</tr>\n</tbody></table>\n<pre><code class=\"language-java\">// 문제 상황: 중복 원소가 있는 배열\nint[] arr = {1, 3, 3, 3, 5, 7};\n\nint idx = Arrays.binarySearch(arr, 3);\n// idx = ? → 1, 2, 3 중 어느 것이 반환될지 보장되지 않음!\n// 첫 번째 3의 위치(Lower Bound)를 구하려면 직접 구현해야 함</code></pre>\n<blockquote>\n<p>💡 <strong>결론</strong>: 코딩 테스트에서는 <code>Arrays.binarySearch()</code>에 의존하지 말고, <strong>Lower Bound / Upper Bound를 직접 구현</strong>하는 것을 추천한다. 직접 구현이 모든 상황에 대응 가능하고, 매개변수 탐색으로의 확장도 자연스럽다.</p>\n</blockquote>\n<hr>\n<h2 id=\"4-매개변수-탐색-parametric-search\">4. 매개변수 탐색 (Parametric Search)</h2>\n<h3 id=\"41-핵심-발상-최적값정답을-이분탐색한다\">4.1 핵심 발상: &quot;최적값(정답)을 이분탐색한다&quot;</h3>\n<p>일반적인 이분탐색은 <strong>배열의 인덱스</strong>를 탐색한다. 매개변수 탐색은 <strong>정답이 될 수 있는 값의 범위</strong> 자체를 이분탐색한다.</p>\n<pre><code>일반 이분탐색:  &quot;이 배열에서 값 X가 어디 있지?&quot;\n매개변수 탐색:  &quot;정답이 될 수 있는 값 중 최적값이 뭐지?&quot;</code></pre><h3 id=\"42-결정-문제decision-problem로의-변환\">4.2 결정 문제(Decision Problem)로의 변환</h3>\n<p>매개변수 탐색의 핵심 아이디어:</p>\n<blockquote>\n<p><strong>최적화 문제</strong> → <strong>결정 문제</strong>로 변환</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">원래 문제 (최적화)</th>\n<th align=\"left\">변환된 문제 (결정)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&quot;최대 몇 개를 만들 수 있는가?&quot;</td>\n<td align=\"left\">&quot;X개를 만들 수 있는가?&quot; → Yes/No</td>\n</tr>\n<tr>\n<td align=\"left\">&quot;최소 거리의 최댓값은?&quot;</td>\n<td align=\"left\">&quot;최소 거리를 D 이상으로 할 수 있는가?&quot; → Yes/No</td>\n</tr>\n<tr>\n<td align=\"left\">&quot;최대 높이는 얼마인가?&quot;</td>\n<td align=\"left\">&quot;높이 H로 자르면 조건을 만족하는가?&quot; → Yes/No</td>\n</tr>\n</tbody></table>\n<p>이렇게 변환하면, &quot;가능/불가능&quot;의 경계를 이분탐색으로 찾을 수 있다.</p>\n<pre><code>정답 후보:  1  2  3  4  5  6  7  8  9  10\n가능 여부:  O  O  O  O  O  X  X  X  X  X\n                        ↑\n                    여기가 정답 (최댓값)</code></pre><p>가능(O)과 불가능(X)이 <strong>단조적(monotonic)</strong>으로 나뉘어야 이분탐색이 성립한다. 즉, 한번 불가능해지면 그 이후는 모두 불가능해야 한다 (또는 그 반대).</p>\n<h3 id=\"43-탐색-범위left-right-설정법\">4.3 탐색 범위(<code>left</code>, <code>right</code>) 설정법</h3>\n<p>매개변수 탐색에서 <code>left</code>와 <code>right</code>는 <strong>정답이 될 수 있는 값의 최소/최대 범위</strong>를 의미한다.</p>\n<pre><code class=\"language-java\">// 예: 나무 자르기 (BOJ 2805)\n// 높이 H로 자르면 필요한 나무를 얻을 수 있는가?\nlong left = 0;           // 높이의 최솟값 (가장 낮게 자르는 경우)\nlong right = 1_000_000_000L;  // 높이의 최댓값 (문제 조건에서 주어진 범위)</code></pre>\n<p><strong>범위 설정 원칙:</strong></p>\n<ul>\n<li><code>left</code>: 정답이 될 수 있는 <strong>가장 작은 값</strong> (보통 0 또는 1)</li>\n<li><code>right</code>: 정답이 될 수 있는 <strong>가장 큰 값</strong> (문제의 제약 조건에서 도출)</li>\n<li>확신이 없으면 <strong>넉넉하게</strong> 잡아도 된다. <code>O(log N)</code>이므로 범위가 2배 되어도 반복 1회만 추가된다.</li>\n</ul>\n<blockquote>\n<p>⚠️ <strong>주의</strong>: <code>right</code> 값이 <code>int</code> 범위를 초과할 수 있는지 반드시 확인하자. 매개변수 탐색에서 <code>mid</code> 계산이나 조건 함수 내부에서 오버플로우가 발생하는 경우가 매우 많다. 의심스러우면 <code>long</code>을 사용하자.</p>\n</blockquote>\n<h3 id=\"44-조건-함수판별-함수-설계-패턴\">4.4 조건 함수(판별 함수) 설계 패턴</h3>\n<p>매개변수 탐색의 핵심은 <strong>&quot;주어진 값이 조건을 만족하는지 판별하는 함수&quot;</strong>를 잘 설계하는 것이다.</p>\n<pre><code class=\"language-java\">/**\n * 매개변수 탐색의 일반적인 판별 함수 패턴\n * @param value 이분탐색 중인 &quot;정답 후보&quot; 값\n * @return 이 값으로 조건을 만족할 수 있는지 여부\n */\nprivate static boolean canAchieve(long value, /* 문제에 필요한 추가 파라미터 */) {\n    // 1. value를 기준으로 시뮬레이션 또는 계산\n    // 2. 문제의 조건과 비교\n    // 3. true/false 반환\n    return /* 조건 만족 여부 */;\n}</code></pre>\n<p><strong>예시 1: 나무 자르기 (BOJ 2805)</strong></p>\n<pre><code class=\"language-java\">/**\n * 높이 height로 나무를 잘랐을 때, 필요한 양(M) 이상을 얻을 수 있는가?\n */\nprivate static boolean canCut(int height, int[] trees, long needed) {\n    long total = 0;\n    for (int tree : trees) {\n        if (tree &gt; height) {\n            total += (tree - height);\n        }\n    }\n    return total &gt;= needed;\n}</code></pre>\n<p><strong>예시 2: 랜선 자르기 (BOJ 1654)</strong></p>\n<pre><code class=\"language-java\">/**\n * 각 랜선을 길이 length로 잘랐을 때, 필요한 개수(N) 이상을 만들 수 있는가?\n */\nprivate static boolean canMake(long length, long[] cables, int needed) {\n    long count = 0;\n    for (long cable : cables) {\n        count += cable / length;\n    }\n    return count &gt;= needed;\n}</code></pre>\n<p><strong>예시 3: 공유기 설치 (BOJ 2110)</strong></p>\n<pre><code class=\"language-java\">/**\n * 인접한 두 공유기 사이의 최소 거리를 dist 이상으로 하여 C개를 설치할 수 있는가?\n */\nprivate static boolean canInstall(int dist, int[] houses, int needed) {\n    int count = 1;           // 첫 번째 집에 무조건 설치\n    int lastInstalled = houses[0];\n\n    for (int i = 1; i &lt; houses.length; i++) {\n        if (houses[i] - lastInstalled &gt;= dist) {\n            count++;\n            lastInstalled = houses[i];\n            if (count &gt;= needed) return true;  // 조기 종료\n        }\n    }\n    return count &gt;= needed;\n}</code></pre>\n<h3 id=\"45-최솟값을-구할-때-vs-최댓값을-구할-때\">4.5 최솟값을 구할 때 vs 최댓값을 구할 때</h3>\n<p>매개변수 탐색에서 가장 중요한 부분이다. <strong>무엇을 구하느냐에 따라 이분탐색의 방향이 달라진다.</strong></p>\n<h4 id=\"case-1-조건을-만족하는-값-중-최댓값-구하기\">Case 1: 조건을 만족하는 값 중 <strong>최댓값</strong> 구하기</h4>\n<pre><code>정답 후보:  1  2  3  4  5  6  7  8  9  10\n가능 여부:  O  O  O  O  O  X  X  X  X  X\n                        ↑\n                    최댓값 = 5</code></pre><pre><code class=\"language-java\">// &quot;가능한 값 중 최댓값&quot;을 구하는 패턴\nlong left = MIN_VALUE, right = MAX_VALUE;\n\nwhile (left &lt; right) {\n    long mid = left + (right - left + 1) / 2;  // ⚠️ 올림!\n    if (canAchieve(mid)) {\n        left = mid;        // mid가 가능하면 → 더 큰 값도 가능할 수 있음\n    } else {\n        right = mid - 1;   // mid가 불가능하면 → mid 이상은 모두 불가능\n    }\n}\n// 정답: left (== right)</code></pre>\n<blockquote>\n<p>⚠️ <strong>올림 나눗셈 필수!</strong>: <code>(right - left + 1) / 2</code>로 올림해야 한다. 그렇지 않으면 <code>left + 1 == right</code>일 때 <code>mid = left</code>가 되어, <code>canAchieve(mid)</code>가 true면 <code>left = mid = left</code> → <strong>무한루프</strong>에 빠진다.</p>\n</blockquote>\n<h4 id=\"case-2-조건을-만족하는-값-중-최솟값-구하기\">Case 2: 조건을 만족하는 값 중 <strong>최솟값</strong> 구하기</h4>\n<pre><code>정답 후보:  1  2  3  4  5  6  7  8  9  10\n가능 여부:  X  X  X  X  X  O  O  O  O  O\n                           ↑\n                       최솟값 = 6</code></pre><pre><code class=\"language-java\">// &quot;가능한 값 중 최솟값&quot;을 구하는 패턴\nlong left = MIN_VALUE, right = MAX_VALUE;\n\nwhile (left &lt; right) {\n    long mid = left + (right - left) / 2;  // 내림 (기본)\n    if (canAchieve(mid)) {\n        right = mid;       // mid가 가능하면 → 더 작은 값도 가능할 수 있음\n    } else {\n        left = mid + 1;    // mid가 불가능하면 → mid 이하는 모두 불가능\n    }\n}\n// 정답: left (== right)</code></pre>\n<h4 id=\"패턴-정리-암기용\">패턴 정리 (암기용)</h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">구하려는 것</th>\n<th align=\"center\">mid 계산</th>\n<th align=\"center\">가능할 때</th>\n<th align=\"center\">불가능할 때</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>최댓값</strong></td>\n<td align=\"center\"><code>left + (right - left + 1) / 2</code> (올림)</td>\n<td align=\"center\"><code>left = mid</code></td>\n<td align=\"center\"><code>right = mid - 1</code></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>최솟값</strong></td>\n<td align=\"center\"><code>left + (right - left) / 2</code> (내림)</td>\n<td align=\"center\"><code>right = mid</code></td>\n<td align=\"center\"><code>left = mid + 1</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>💡 <strong>외우는 팁</strong>: &quot;답을 포함시키는 방향&quot;을 생각하자.</p>\n<ul>\n<li>최댓값: 가능하면 <code>left = mid</code> (왼쪽 경계를 올린다 → 더 큰 값 탐색)</li>\n<li>최솟값: 가능하면 <code>right = mid</code> (오른쪽 경계를 내린다 → 더 작은 값 탐색)</li>\n</ul>\n</blockquote>\n<h3 id=\"46-매개변수-탐색-전체-템플릿\">4.6 매개변수 탐색 전체 템플릿</h3>\n<p>실제 코딩 테스트에서 바로 사용할 수 있는 템플릿이다.</p>\n<h4 id=\"최댓값-구하기-템플릿-나무-자르기-랜선-자르기-등\">최댓값 구하기 템플릿 (나무 자르기, 랜선 자르기 등)</h4>\n<pre><code class=\"language-java\">import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // 입력 처리 ...\n\n        long left = 0, right = MAX_POSSIBLE_VALUE;\n\n        while (left &lt; right) {\n            long mid = left + (right - left + 1) / 2;  // 올림\n            if (canAchieve(mid)) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        System.out.println(left);\n    }\n\n    private static boolean canAchieve(long value) {\n        // 판별 함수 구현\n        return true;\n    }\n}</code></pre>\n<h4 id=\"최솟값-구하기-템플릿\">최솟값 구하기 템플릿</h4>\n<pre><code class=\"language-java\">long left = 0, right = MAX_POSSIBLE_VALUE;\n\nwhile (left &lt; right) {\n    long mid = left + (right - left) / 2;  // 내림\n    if (canAchieve(mid)) {\n        right = mid;\n    } else {\n        left = mid + 1;\n    }\n}\n\nSystem.out.println(left);</code></pre>\n<h3 id=\"47-매개변수-탐색-문제-접근-체크리스트\">4.7 매개변수 탐색 문제 접근 체크리스트</h3>\n<p>문제를 봤을 때, 아래 질문에 답해보자:</p>\n<ol>\n<li><p><strong>&quot;최솟값의 최댓값&quot; 또는 &quot;최댓값의 최솟값&quot; 같은 표현이 있는가?</strong>\n→ 높은 확률로 매개변수 탐색</p>\n</li>\n<li><p><strong>정답을 X라고 가정했을 때, X가 가능한지 판별할 수 있는가?</strong>\n→ Yes면 매개변수 탐색 적용 가능</p>\n</li>\n<li><p><strong>가능/불가능의 경계가 단조적인가?</strong>\n→ X가 가능하면 X-1도 가능한가? (또는 X+1도 가능한가?)\n→ 단조적이면 이분탐색 적용 가능</p>\n</li>\n<li><p><strong>탐색 범위를 정할 수 있는가?</strong>\n→ left(최솟값)와 right(최댓값)를 문제 조건에서 도출</p>\n</li>\n<li><p><strong>판별 함수의 시간복잡도가 허용 범위 내인가?</strong>\n→ 전체 시간복잡도 = <code>O(log(범위) × 판별함수)</code></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"reference\">Reference</h2>\n<ul>\n<li>『알고리즘 문제 해결 전략』(구종만 저) - 이분 탐색과 매개변수 탐색 챕터</li>\n<li>백준 온라인 저지 (<a href=\"https://www.acmicpc.net/\">https://www.acmicpc.net/</a>) - 문제 1920, 10816, 1654, 2805, 2110</li>\n<li>Java 공식 문서: <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Arrays.html\"><code>Arrays.binarySearch()</code></a></li>\n</ul>",
    "date": "2026-02-16T01:51:23.000Z",
    "url": "https://velog.io/@lmn/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89-Binary-Search-%EC%A0%95%EB%A0%AC-OlogN-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%ED%83%90%EC%83%89"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Repository",
    "partialText": "<p>비관적 락 사용:</p>\n<pre><code>@Lock(LockModeType.PESSIMISTIC_WRITE)\n@Query(&quot;select c from Concert c where c.id = :id&quot;)\nOptional&lt;Concert&gt; findByIdForUpdate(@Param(&quot;id&quot;) Long id);\n</code></pre><h2 id=\"질문-1-lockpessimistic_write가-붙으면-db에서-실제로-무슨-일이-일어날까-정확히-어떤-락이-걸리는가\">질문 1: @Lock(PESSIMISTIC_WRITE)가 붙으면 DB에서 실제로 무슨 일이 일어날까? 정확히 어떤 락이 걸리는가?</h2>\n<p>=&gt; row 잠금이 일어난다. PESSIMISTIC_WRITE는 보통 DB에서</p>\n<pre><code>SELECT ... FOR UPDATE\n</code></pre><p>를 사용한다.\n이건 해당 행에 대한 쓰기를 잠그고 다른 트랜잭션은 대기 시키며 읽기는 DB 설정에 따라 달라진다.</p>\n<p>중요한 점: 비관적 락은 DB 레벨 락이다. JPA가 아니라 DB가 제어한다.</p>\n<h2 id=\"질문-2-비관적-락은-왜-읽는-시점에-락을-거는-걸까\">질문 2: 비관적 락은 왜 &quot;읽는 시점&quot;에 락을 거는 걸까?</h2>\n<p>=&gt; UPDATE 시점은 너무 늦다. 이미 비즈니스 로직이 실행된 뒤에 잠그면 좌석 감소 판단은 이미 끝나있고 결제 API 호출까지 갔을 수도 있다. 그 상태에서 충돌하면 롤백 + 외부 API 보상이 필요하다.</p>\n<p>그래서 비관적 락은\n<strong><em>읽는 순간 부터 보호</em></strong> 이게 핵심이다.</p>\n<h4 id=\"이-글은-나의-생각을-적을-글로-사실과-다를-수-있습니다\">이 글은 나의 생각을 적을 글로 사실과 다를 수 있습니다.</h4>",
    "date": "2026-02-16T01:47:05.000Z",
    "url": "https://velog.io/@kang07/Repository"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "마이리얼트립 할인코드 안내",
    "partialText": "<p><a href=\"https://myreal-coupon.co.kr/\">마이리얼트립 할인코드</a> 및 2026년 2월 혜택을 한눈에 정리했습니다. 항공권·숙소·투어·티켓까지 적용 가능한 프로모션과 카드·간편결제 즉시할인을 함께 비교하면 체감 할인 폭을 크게 줄일 수 있습니다.</p>\n<p>기본 할인코드는 해외 투어·티켓 5만원 이상 결제 시 1천원, 15만원 이상 결제 시 3천원 할인이 적용됩니다. 여기에 항공 단독특가, 숙소 기획전, 초특가 투어 최대 50% 할인, eSIM 최대 50% 할인 등 기간 한정 프로모션이 수시로 운영됩니다.</p>\n<p>결제 단계에서는 토스페이·카카오페이·네이버페이 등 선착순 즉시할인과 삼성·우리·KB국민 등 주요 카드사 최대 15% 항공권 할인을 함께 확인하세요. 100만원 이상 고액 결제 시 6~12개월 무이자 할부도 가능해 장거리 항공권이나 고급 숙소 예약에 유리합니다.</p>\n<p>또한 신세계·신라·롯데 면세점 제휴 혜택과 최저가 보장제를 활용하면 추가 절약이 가능합니다. 예약 전 쿠폰 유효기간, 최소 결제금액, 적용 카테고리를 꼭 확인하는 것이 핵심입니다.</p>",
    "date": "2026-02-16T01:46:30.000Z",
    "url": "https://velog.io/@sky001i/%EB%A7%88%EC%9D%B4%EB%A6%AC%EC%96%BC%ED%8A%B8%EB%A6%BD-%ED%95%A0%EC%9D%B8%EC%BD%94%EB%93%9C-%EC%95%88%EB%82%B4-z0j28wtg"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "[YOUTUBE] 게으른 줄 알았는데, 알고 보니 뇌가 풀가동 중이었습니다",
    "partialText": "<p><a href=\"https://youtu.be/s5sRmZYgGtI?si=0LiQhs9nu8wVduNU\"><img src=\"https://i.ytimg.com/vi/s5sRmZYgGtI/hqdefault.jpg?sqp=-oaymwEnCNACELwBSFryq4qpAxkIARUAAIhCGAHYAQHiAQoIGBACGAY4AUAB&rs=AOn4CLBG8v3nW1z06-1DXEb1nrP6XaD7Dg\" alt=\"https://youtu.be/s5sRmZYgGtI?si=0LiQhs9nu8wVduNU\"></a></p>",
    "date": "2026-02-16T01:44:46.000Z",
    "url": "https://velog.io/@doggyfoot92/YOUTUBE-%EA%B2%8C%EC%9C%BC%EB%A5%B8-%EC%A4%84-%EC%95%8C%EC%95%98%EB%8A%94%EB%8D%B0-%EC%95%8C%EA%B3%A0-%EB%B3%B4%EB%8B%88-%EB%87%8C%EA%B0%80-%ED%92%80%EA%B0%80%EB%8F%99-%EC%A4%91%EC%9D%B4%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "도메인: Concert",
    "partialText": "<pre><code>@Entity\n@Getter\n@NoArgsConstructor\npublic class Concert {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Version\n    private Long version;\n\n    private int remainingSeats;\n\n    public Concert(int remainingSeats) {\n        this.remainingSeats = remainingSeats;\n    }\n\n    public void decreaseSeat() {\n        if (remainingSeats &lt;= 0) {\n            throw new NoSeatException();\n        }\n        remainingSeats--;\n    }\n}\n</code></pre><h2 id=\"질문-1-왜-remainingseats--를-서비스가-아니라-엔티티-내부에-넣었을까\">질문 1: 왜 remainingSeats--를 서비스가 아니라 엔티티 내부에 넣었을까?</h2>\n<p>=&gt; &quot;좌석 감소&quot;는 단순 상태 변경이 아니라 <strong>비즈니스 행위</strong>다. 즉 불변 로직이고 정합성 핵심이기 때문이다. 그래서 이 감소 행위는 외부에서 아무렇게나 바꾸면 안 되고 항상 조건 검사를 통과해야 하며 규칙이 바뀌면 여기 한 곳만 수정하면 되게 해야 한다. </p>\n<h2 id=\"질문-2-if-remainingseats--0-이-검사는-왜-서비스가-아니라-도메인에서-해야-할까\">질문 2: if (remainingSeats &lt;= 0) 이 검사는 왜 서비스가 아니라 도메인에서 해야 할까?</h2>\n<p>=&gt; 서비스는 &quot;조정자&quot;이고 도메인은 &quot;규칙의 주인&quot;이다. 서비스에서 배치 로직은 또 따로 구현해야 하는데 만약 A 서비스는 검사하고 B 서비스는 안 한다면 그 순간 규칙은 분산되고 도메인은 껍데기가 되므로 도메인에서 해야한다.</p>\n<h2 id=\"질문-3-version-필드는-정확히-언제-사용될까-정확히-어떤-시점에-충돌이-감지되는가\">질문 3: @Version 필드는 정확히 언제 사용될까? 정확히 어떤 시점에 충돌이 감지되는가?</h2>\n<p>=&gt; 커밋 시점이다. 정확히는 UPDATE SQL 실행 시점이다. JPA는 flush 단계에서 UPDATE를 날리면서 이런 쿼리를 만든다.</p>\n<pre><code>update concert\nset remaining_seats=?, version=?\nwhere id=? and version=?\n</code></pre><p>여기서 버전이 다르면 영향 받는 row 수가 0이 되고 그 순간 <strong><em>낙관적 락 실패 예외</em></strong>를 던진다. \n즉, 충돌 감ㅅ지는 flush/commit 시점이다.</p>\n<h4 id=\"이-글은-나의-생각을-정리해서-적은-글로-사실과-다를-수-있습니다\">이 글은 나의 생각을 정리해서 적은 글로 사실과 다를 수 있습니다.</h4>",
    "date": "2026-02-16T01:41:38.000Z",
    "url": "https://velog.io/@kang07/%EB%8F%84%EB%A9%94%EC%9D%B8-Concert"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "02. 물리 계층과 데이터 링크 계층 - (1) 이더넷",
    "partialText": "<p>안녕하세요! 오늘은 이더넷에 대해 알아보겠습니다.</p>\n<blockquote>\n<p>📖 이 글은 <strong>『혼자 공부하는 네트워크』</strong>를 읽고 공부한 내용을 정리한 기록입니다.</p>\n</blockquote>\n<blockquote>\n<h3 id=\"목차\">목차</h3>\n</blockquote>\n<ol>\n<li><strong>이더넷 표준</strong></li>\n<li><strong>통신 매체 표기 형태</strong></li>\n<li><strong>이더넷 프레임</strong></li>\n</ol>\n<hr>\n<h2 id=\"1-이더넷-표준\">1. 이더넷 표준</h2>\n<p><strong>이더넷(Ethernet)</strong>은 현대 LAN 환경에서 가장 대중적으로 사용되는 기술입니다. 다양한 통신 매체의 규격들과 송수신되는 프레임의 형태, 프레임을 주고받는 방법 등이 정의된 네트워크 기술입니다.</p>\n<p>전기전자공학자협회(<strong>IEEE</strong>, Institute of Electrical and Electronics Engineers)라는 국제 조직은 이더넷 관련 기술을 <strong>IEEE 802.3</strong>이라는 이름으로 표준화했습니다. 이더넷 표준에 따라 지원되는 네트워크 장비, 통신 매체의 종류와 전송 속도 등이 달라질 수 있습니다.</p>\n<hr>\n<h2 id=\"2-통신-매체-표기-형태\">2. 통신 매체 표기 형태</h2>\n<p><img src=\"https://velog.velcdn.com/images/zxader/post/8511be55-3bab-41b2-b6a7-09691b36edec/image.png\" alt=\"\"></p>\n<h3 id=\"1-전송-속도\">1) 전송 속도</h3>\n<table>\n<thead>\n<tr>\n<th align=\"center\">전송 속도 표기</th>\n<th align=\"left\">의미</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>10</strong></td>\n<td align=\"left\">10Mbps</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>100</strong></td>\n<td align=\"left\">100Mbps</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>1000</strong></td>\n<td align=\"left\">1000Mbps (1Gbps)</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>2.5G</strong></td>\n<td align=\"left\">2.5Gbps</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>5G</strong></td>\n<td align=\"left\">5Gbps</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>10G</strong></td>\n<td align=\"left\">10Gbps</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>40G</strong></td>\n<td align=\"left\">40Gbps</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>100G</strong></td>\n<td align=\"left\">100Gbps</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-base\">2) BASE</h3>\n<p><strong>베이스밴드(Baseband)</strong>의 약자로, 변조 타입을 의미합니다. 대부분의 이더넷 통신 매체는 BASE를 사용합니다. 이외에도 BROAD로 표기하는 브로드밴드(Broadband), PASS로 표기하는 패스밴드(Passband)도 있습니다.</p>\n<ul>\n<li><strong>변조 타입</strong>: 비트 신호로 변환된 데이터를 통신 매체로 전송하는 방법</li>\n</ul>\n<h3 id=\"3-추가-특성\">3) 추가 특성</h3>\n<p>통신 매체의 특성(전송 가능한 최대 거리, 물리 계층 인코딩 방식, 레인 수, 통신 매체의 종류 등)을 명시합니다. </p>\n<p><strong>[통신 매체 종류 표기]</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">추가 특성 표기</th>\n<th align=\"left\">케이블 종류</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>C</strong></td>\n<td align=\"left\">동축 케이블</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>T</strong></td>\n<td align=\"left\">트위스티드 페어 케이블</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>S</strong></td>\n<td align=\"left\">단파장 광섬유 케이블</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>L</strong></td>\n<td align=\"left\">장파장 광섬유 케이블</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>💡 이더넷의 발전</strong>\n이더넷은 지금도 발전하는 중입니다. 초기 이더넷은 10Mbps 정도의 속도를 지원했지만, 곧 10배 빠른 100Mbps 속도를 지원하는 이더넷 기술(<strong>고속 이더넷, Fast Ethernet</strong>)이 개발되었습니다.\n최근에는 고속 이더넷의 10배, 100배 혹은 그 이상의 속도를 지원하는 이더넷 표준들이 많이 만들어지고 있습니다.</p>\n<ul>\n<li><strong>기가비트 이더넷 (Gigabit Ethernet)</strong>: 1Gbps가량 속도를 내는 이더넷 표준</li>\n<li><strong>10기가비트 이더넷 (10 Gigabit Ethernet)</strong>: 10Gbps가량 속도를 내는 이더넷 표준</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"3-이더넷-프레임\">3. 이더넷 프레임</h2>\n<p>이더넷 기반 네트워크의 데이터 링크 계층에서 주고받는 프레임 형식입니다. 상위 계층으로부터 받아들인 정보에 헤더와 트레일러를 추가하는 캡슐화 과정을 통해 만들어집니다.</p>\n<p><img src=\"https://velog.velcdn.com/images/zxader/post/34cf8e44-09fd-4daf-8c16-f1fbe22ba9f9/image.png\" alt=\"\"></p>\n<h3 id=\"1-프리앰블-preamble\">1) 프리앰블 (Preamble)</h3>\n<p>이더넷 프레임의 시작을 알리는 8바이트 크기의 정보입니다. 첫 7바이트는 <code>10101010</code> 값을 가지고, 마지막 바이트는 <code>10101011</code> 값을 가집니다.</p>\n<h3 id=\"2-수신지-mac-주소와-송신지-mac-주소\">2) 수신지 MAC 주소와 송신지 MAC 주소</h3>\n<p><strong>MAC(Media Access Control) 주소</strong>는 네트워크 인터페이스마다 부여되는 6바이트 길이의 주소로, LAN 내의 수신지와 송신지를 특정할 수 있습니다. </p>\n<p>MAC 주소는 일반적으로 고유하며 변경되지 않는 주소로 네트워크 인터페이스마다 부여됩니다. 보통 <strong>NIC(Network Interface Controller)</strong>라는 장치가 이 네트워크 인터페이스 역할을 담당합니다.</p>\n<h3 id=\"3-타입길이-typelength\">3) 타입/길이 (Type/Length)</h3>\n<p>필드에 명시된 크기가 1500 이하일 경우 프레임의 <strong>길이(크기)</strong>를 나타내고, 1536 이상일 경우 <strong>타입</strong>을 나타내는 데 사용됩니다.</p>\n<p>타입이란 이더넷 프레임이 어떤 정보를 캡슐화했는지 나타내는 정보이며, <strong>이더타입(EtherType)</strong>이라고도 부릅니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">타입 (Hex)</th>\n<th align=\"left\">프로토콜</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>0800</strong></td>\n<td align=\"left\">IPv4</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>86DD</strong></td>\n<td align=\"left\">IPv6</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>0806</strong></td>\n<td align=\"left\">ARP</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-데이터-data\">4) 데이터 (Data)</h3>\n<p>상위 계층에서 전달받거나 상위 계층으로 전달해야 할 내용(페이로드)입니다. 최대 크기는 1500바이트이며, 반드시 46바이트 이상이어야 합니다. 만약 데이터 크기가 46바이트보다 작다면, 크기를 맞추기 위해 <strong>패딩(Padding, 0)</strong>이라는 데이터를 내부에 채워 넣습니다.</p>\n<h3 id=\"5-fcs-frame-check-sequence\">5) FCS (Frame Check Sequence)</h3>\n<p>수신한 이더넷 프레임에 오류가 있는지 확인하기 위한 트레일러 필드입니다. 이 필드에는 <strong>CRC(Cyclic Redundancy Check, 순환 중복 검사)</strong>라고 불리는 오류 검출용 값이 들어갑니다.</p>\n<blockquote>\n<p><strong>💡 토큰 링 (Token Ring)</strong>\n&#39;토큰&#39;을 통해 네트워크 내 다른 호스트에게 메시지를 송신하는 링 형태의 LAN 기술입니다. 토큰을 가지고 있지 않으면 데이터를 송신할 수 없어 충돌이 발생하지 않는다는 특징이 있습니다.</p>\n</blockquote>\n<hr>\n<h2 id=\"마치며\">마치며</h2>\n<p>오늘은 이더넷의 표준과 프레임 구조에 대해 정리했습니다.</p>\n<p>다음 글에서는 <strong>NIC와 케이블</strong>에 대해 알아보겠습니다!</p>",
    "date": "2026-02-16T01:23:42.000Z",
    "url": "https://velog.io/@zxader/02.-%EB%AC%BC%EB%A6%AC-%EA%B3%84%EC%B8%B5%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%A7%81%ED%81%AC-%EA%B3%84%EC%B8%B5-1-%EC%9D%B4%EB%8D%94%EB%84%B7"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "ControllerAdvice란?",
    "partialText": "<blockquote>\n<p>ControllerAdvice란?</p>\n</blockquote>\n<p>●ControllerAdvice란?</p>\n<ul>\n<li><p>@ControllerAdvice는 모든 컨트롤러에 대해 전역 기능을 제공하는 애너테이션이며, @ControllerAdvice가 선언된 클래스에 @ExceptionHandler, @InitBinder, @ModelAttribute를 등록하면 예외 처리, 바인딩 등을 한 곳에서 처리할 수 있어, 코드의 중복을 줄이고 유지보수성을 높일 수 있음</p>\n</li>\n<li><p>@ControllerAdvice는 내부에 @Component가 포함되어 있어 컴포넌트 스캔 과정에서 빈으로 등록되며, @RestControllerAdvice는 내부에 @ResponseBody를 포함하여 @ExceptionHandler와 함께 사용될 때 예외 응답을 Json 형태로 내려준다는 특징이 있음</p>\n</li>\n</ul>",
    "date": "2026-02-16T01:22:42.000Z",
    "url": "https://velog.io/@ekzm527/ControllerAdvice%EB%9E%80"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Java String, final, new, 그리고 컴파일 타임 상수 완전 정리",
    "partialText": "<h3 id=\"1-왜-이-글을-쓰게-되었나\">1. 왜 이 글을 쓰게 되었나</h3>\n<p>Java를 공부하다가 이런 코드에서 멈췄다.</p>\n<pre><code class=\"language-java\">String a = &quot;hello&quot;;\nString b = &quot;he&quot; + &quot;llo&quot;;\n\nSystem.out.println(a == b);</code></pre>\n<p>겉으로 보면 주소값 관련해서 생각을 하면 다른 연산처럼 보이는데\n결과는 <code>true</code>가 나온다.</p>\n<p>그런데 조금만 바꾸면 결과가 달라진다.</p>\n<hr>\n<h3 id=\"2--는-값-비교가-아니라-주소-비교다\">2. == 는 값 비교가 아니라 주소 비교다</h3>\n<pre><code class=\"language-java\">a == b</code></pre>\n<p>는 두 객체가 <strong>같은 메모리 주소를 가리키는지</strong> 비교한다.</p>\n<p>즉, 참조 비교다.</p>\n<hr>\n<h3 id=\"3-string-pool-이해하기\">3. String Pool 이해하기</h3>\n<pre><code class=\"language-java\">String a = &quot;hello&quot;;\nString b = &quot;hello&quot;;</code></pre>\n<p>메모리 구조:</p>\n<pre><code>String Constant Pool\n └── &quot;hello&quot;</code></pre><p>a와 b는 같은 주소를 가리킨다.</p>\n<pre><code class=\"language-java\">a == b // true</code></pre>\n<hr>\n<h3 id=\"4-new가-들어가면-항상-힙에-새-객체-생성\">4. new가 들어가면 항상 힙에 새 객체 생성</h3>\n<pre><code class=\"language-java\">String a = &quot;hello&quot;;\nString b = new String(&quot;hello&quot;);</code></pre>\n<p>메모리 구조:</p>\n<pre><code>String Pool\n └── &quot;hello&quot; ← a\n\nHeap\n └── new String(&quot;hello&quot;) ← b</code></pre><pre><code class=\"language-java\">a == b // false</code></pre>\n<blockquote>\n<p>new는 무조건 힙에 새로운 객체를 생성한다.</p>\n</blockquote>\n<hr>\n<h3 id=\"5-서로-다른-문자열을-new로-만들면\">5. 서로 다른 문자열을 new로 만들면?</h3>\n<pre><code class=\"language-java\">String a = new String(&quot;a&quot;);\nString b = new String(&quot;b&quot;);\n\nSystem.out.println(a == b);</code></pre>\n<p>결과는 당연히:</p>\n<pre><code class=\"language-java\">false</code></pre>\n<p>왜냐하면:</p>\n<ul>\n<li>a는 힙에 생성된 &quot;a&quot; 객체</li>\n<li>b는 힙에 생성된 &quot;b&quot; 객체</li>\n<li>서로 다른 주소</li>\n<li>심지어 내부 값도 다름</li>\n</ul>\n<p>메모리 구조:</p>\n<pre><code>Heap\n └── new String(&quot;a&quot;) ← a\n └── new String(&quot;b&quot;) ← b</code></pre><p><strong>포인트</strong></p>\n<p>이 경우는:</p>\n<ul>\n<li>값도 다름</li>\n<li>주소도 다름</li>\n</ul>\n<p>그래서 ==는 당연히 false.</p>\n<hr>\n<h3 id=\"6-그런데-같은-문자열을-new로-만들면\">6. 그런데 같은 문자열을 new로 만들면?</h3>\n<pre><code class=\"language-java\">String a = new String(&quot;a&quot;);\nString b = new String(&quot;a&quot;);</code></pre>\n<p>이 경우는 헷갈릴 수 있다.</p>\n<ul>\n<li>값은 같다</li>\n<li>하지만 new가 두 번 실행됨</li>\n</ul>\n<p>메모리 구조:</p>\n<pre><code>Heap\n └── new String(&quot;a&quot;) ← a\n └── new String(&quot;a&quot;) ← b</code></pre><p>두 객체는 완전히 다른 객체다.</p>\n<pre><code class=\"language-java\">a == b // false\na.equals(b) // true</code></pre>\n<p><strong>여기서 진짜 핵심</strong></p>\n<blockquote>\n<p>값이 같아도 객체가 다르면 ==는 false다.</p>\n</blockquote>\n<hr>\n<h3 id=\"7-컴파일-타임-상수란-무엇인가\">7. 컴파일 타임 상수란 무엇인가?</h3>\n<pre><code class=\"language-java\">String a = &quot;hello&quot;;\nString b = &quot;he&quot; + &quot;llo&quot;;</code></pre>\n<p>이건 컴파일 단계에서 이렇게 바뀐다:</p>\n<pre><code class=\"language-java\">String b = &quot;hello&quot;;</code></pre>\n<p>그래서</p>\n<pre><code class=\"language-java\">a == b // true</code></pre>\n<hr>\n<h3 id=\"8-변수-포함하면-런타임-결합\">8. 변수 포함하면 런타임 결합</h3>\n<pre><code class=\"language-java\">String a = &quot;hello&quot;\nString part = &quot;he&quot;;\nString b = part + &quot;llo&quot;;</code></pre>\n<p>이건 실행 중에 결합된다.</p>\n<p>내부적으로:</p>\n<pre><code class=\"language-java\">new StringBuilder()\n    .append(part)\n    .append(&quot;llo&quot;)\n    .toString();</code></pre>\n<p>새 객체 생성.</p>\n<pre><code class=\"language-java\">a == b // false</code></pre>\n<hr>\n<h3 id=\"9-final이-들어가면\">9. final이 들어가면?</h3>\n<pre><code class=\"language-java\">String a = &quot;hello&quot;\nfinal String part = &quot;he&quot;;\nString b = part + &quot;llo&quot;;</code></pre>\n<p>이건 컴파일 타임 상수로 인식된다.</p>\n<pre><code class=\"language-java\">a == b // true</code></pre>\n<hr>\n<h3 id=\"10-final--new-는\">10. final + new 는?</h3>\n<pre><code class=\"language-java\">String a = &quot;hello&quot;\nfinal String part = new String(&quot;he&quot;);\nString b = part + &quot;llo&quot;;</code></pre>\n<p>a == b 결과는??</p>\n<p>이건 false.</p>\n<p>왜냐하면 <code>new</code>는 <strong>런타임 객체 생성</strong>이기 때문.</p>\n<hr>\n<h3 id=\"전체-정리표\">전체 정리표</h3>\n<table>\n<thead>\n<tr>\n<th>코드</th>\n<th>힙 새 객체 생성</th>\n<th>컴파일 타임 상수</th>\n<th>== 결과</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&quot;hello&quot;</code></td>\n<td>X</td>\n<td>O</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>&quot;he&quot; + &quot;llo&quot;</code></td>\n<td>X</td>\n<td>O</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>new String(&quot;hello&quot;)</code></td>\n<td>O</td>\n<td>X</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>String part = &quot;he&quot;</code></td>\n<td>O</td>\n<td>X</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>final String part = &quot;he&quot;</code></td>\n<td>X</td>\n<td>O</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>final String part = new String(&quot;he&quot;)</code></td>\n<td>O</td>\n<td>X</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>new String(&quot;a&quot;)</code>, <code>new String(&quot;b&quot;)</code></td>\n<td>O</td>\n<td>X</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"오늘의-핵심-문장\">오늘의 핵심 문장</h3>\n<ul>\n<li>== 는 주소 비교다.</li>\n<li>new는 항상 힙에 새 객체를 만든다.</li>\n<li>String 리터럴은 Pool에 저장된다.</li>\n<li>컴파일 타임 상수는 미리 계산된다.</li>\n<li>final은 재할당 불가이지 항상 상수는 아니다.</li>\n</ul>\n<hr>\n<h3 id=\"객체지향-관점에서-본다면\">객체지향 관점에서 본다면</h3>\n<blockquote>\n<p>객체는 주소를 가진 실체다.</p>\n</blockquote>\n<p>값이 같아도\n객체가 다르면 다른 것이다.</p>\n<p>이걸 이해하면\nJava 문자열의 본질을 이해한 것이다.</p>",
    "date": "2026-02-16T01:12:33.000Z",
    "url": "https://velog.io/@scminy0527/Java-String-final-new-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%ED%83%80%EC%9E%84-%EC%83%81%EC%88%98-%EC%99%84%EC%A0%84-%EC%A0%95%EB%A6%AC"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "2026 경기창업 공모전 G-스타 오디션 예비초기리그",
    "partialText": "<h1 id=\"2026-경기창업-공모전-g-스타-오디션-예비초기리그\"><strong>2026 경기창업 <a href=\"https://www.wevity.com\">공모전</a> G-스타 오디션 예비초기리그</strong></h1>\n<p><img src=\"https://velog.velcdn.com/images/korea2/post/956f66a4-f317-4bd3-9731-c57ab3437915/image.png\" alt=\"\"></p>\n<p>경기 (예비)창업자를 위한 창업 경진대회를 통해 여러분의 꿈을 키우세요!</p>\n<p>■ 참가 자격 ※아래 중 하나에 해당</p>\n<ul>\n<li>경기도 거주 예비창업가</li>\n<li>경기도 소재 3년 이내 창업자</li>\n</ul>\n<p>■ 공모 분야</p>\n<ul>\n<li>기술 및 지식산업형 사업화 아이템\n(아이디어, 기술, 제품)</li>\n</ul>\n<p>■ 공모 주제</p>\n<ul>\n<li>기술 및 지식산업형 사업화 아이템\n(아이디어, 기술, 제품)</li>\n</ul>\n<p>■ <a href=\"https://www.wevity.com\">공모전</a> 시상내역</p>\n<ul>\n<li>최종 3개팀 총 20백만원 시상</li>\n<li>스타트업지원사업 공간 우대 및 경기스타트업서밋 부스/밋업 우대<ul>\n<li>대상(1팀) : 10백만원/팀</li>\n<li>최우수상(1팀) : 7백만원/팀</li>\n<li>우수상(1팀) : 3백만원/팀</li>\n</ul>\n</li>\n</ul>\n<p>■ 공모 일정 : 26.02.04(수) ~ 03.12(목) 15시까지</p>\n<p>■ 심사 방법</p>\n<ul>\n<li>모집공고(2~3월/온라인/예비,창업기업)</li>\n<li>예선(3~4월/서류평가/20팀선정)</li>\n<li>본선(4~5월/발표평가/10팀선정)</li>\n<li>역량강화(5~6월/멘토링 등/결선진출자 대상)</li>\n<li>결선(6~7월/발표평가/3팀 선정)</li>\n</ul>\n<p>■ 문의 사항</p>\n<ul>\n<li>경기도경제과학진흥원 스타트업전략팀 T.031-259-6094/6096 E. <a href=\"mailto:gstar@gbsa.or.kr\">gstar@gbsa.or.kr</a></li>\n</ul>",
    "date": "2026-02-16T00:37:46.000Z",
    "url": "https://velog.io/@korea2/2026-%EA%B2%BD%EA%B8%B0%EC%B0%BD%EC%97%85-%EA%B3%B5%EB%AA%A8%EC%A0%84-G-%EC%8A%A4%ED%83%80-%EC%98%A4%EB%94%94%EC%85%98-%EC%98%88%EB%B9%84%EC%B4%88%EA%B8%B0%EB%A6%AC%EA%B7%B8"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Không Gian Giải Trí Hiện Đại Cùng Vtc88",
    "partialText": "<p>Vtc88 mở ra một thế giới giải trí số đầy màu sắc, nơi người chơi có thể bắt đầu hành trình trải nghiệm ngay từ những phút đầu tiên một cách dễ dàng và thoải mái. Ngay khi truy cập, người chơi sẽ cảm nhận được sự chỉn chu trong thiết kế giao diện với bố cục rõ ràng, màu sắc hài hòa và cách sắp xếp hợp lý. Điều này giúp việc làm quen trở nên nhanh chóng, đặc biệt phù hợp với những ai lần đầu tiếp cận các nền tảng giải trí trực tuyến.</p>\n<p>Trải nghiệm tại <a href=\"https://vtc88.asia\">Vtc88</a> được xây dựng xoay quanh sự đa dạng và tính linh hoạt. Nội dung trò chơi phong phú mang đến nhiều lựa chọn khác nhau, từ những trò mang tính giải trí nhẹ nhàng đến các thử thách cần tư duy và phản xạ. Mỗi trò chơi đều được thiết kế với luật chơi dễ hiểu, giúp người chơi nhanh chóng tham gia mà không mất nhiều thời gian tìm hiểu. Sự cân bằng giữa yếu tố đơn giản và chiều sâu chính là điểm khiến người chơi cảm thấy hứng thú lâu dài.</p>\n<p>Một trong những điểm được đánh giá cao tại Vtc88 là sự ổn định trong quá trình trải nghiệm. Tốc độ tải nhanh cùng khả năng vận hành mượt mà giúp người chơi không bị gián đoạn cảm xúc. Dù sử dụng điện thoại di động hay máy tính, các thao tác đều trơn tru và liền mạch. Điều này tạo nên sự tiện lợi, cho phép người chơi tận hưởng giải trí ở bất kỳ đâu và bất kỳ thời điểm nào.</p>\n<p>Bên cạnh yếu tố kỹ thuật, Vtc88 còn chú trọng đến cảm xúc của người chơi thông qua hình ảnh và âm thanh. Đồ họa sắc nét kết hợp với hiệu ứng sinh động giúp mỗi khoảnh khắc trải nghiệm trở nên sống động hơn. Âm thanh được thiết kế phù hợp với từng bối cảnh, góp phần tạo nên không gian giải trí chân thực và cuốn hút. Những chi tiết nhỏ này giúp người chơi cảm thấy thư giãn và dễ dàng hòa mình vào trò chơi.</p>",
    "date": "2026-02-16T00:34:12.000Z",
    "url": "https://velog.io/@sitepage/Khng-Gian-Gii-Tr-Hin-i-Cng-Vtc88"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Không Gian Giải Trí Sáng Tạo Trên NK88",
    "partialText": "<p>NK88 đang dần trở thành một điểm đến quen thuộc đối với những người yêu thích giải trí trực tuyến nhờ vào cách xây dựng trải nghiệm người chơi toàn diện và hiện đại. Ngay từ phần giới thiệu ban đầu nền tảng này đã tạo được ấn tượng tích cực với giao diện rõ ràng màu sắc hài hòa và bố cục hợp lý. Người chơi dù mới hay đã có kinh nghiệm đều có thể dễ dàng tiếp cận và làm quen mà không gặp nhiều trở ngại. Cảm giác thân thiện và mạch lạc là yếu tố giúp NK88 ghi điểm trong mắt cộng đồng.</p>\n<p>Trải nghiệm chơi game trên <a href=\"https://www-nk88.com\">NK88</a> được chú trọng đến sự ổn định và mượt mà trong từng thao tác. Tốc độ tải nhanh giúp người chơi không bị gián đoạn và duy trì được sự tập trung trong suốt quá trình tham gia. Hình ảnh sắc nét kết hợp với âm thanh sống động tạo nên không gian giải trí chân thực và hấp dẫn. Mỗi trò chơi đều được thiết kế cẩn thận nhằm mang lại cảm giác trọn vẹn từ lúc bắt đầu cho đến khi kết thúc.</p>\n<p>Sự đa dạng trong nội dung là một trong những điểm nổi bật của NK88. Nền tảng liên tục mang đến nhiều lựa chọn khác nhau phù hợp với nhiều phong cách và sở thích. Có những trò chơi mang tính thư giãn giúp người chơi giải tỏa căng thẳng sau thời gian làm việc trong khi cũng có những thử thách đòi hỏi tư duy và khả năng quan sát. Việc cập nhật thường xuyên giúp trải nghiệm luôn mới mẻ và không bị lặp lại.</p>\n<p>NK88 cũng đặc biệt quan tâm đến yếu tố cá nhân hóa trải nghiệm. Hệ thống gợi ý thông minh dựa trên thói quen của người chơi giúp việc lựa chọn nội dung trở nên nhanh chóng và thuận tiện. Các chức năng hỗ trợ được bố trí khoa học giúp người dùng dễ dàng thao tác và quản lý thời gian giải trí của mình. Chính sự tinh tế trong thiết kế này khiến người chơi cảm thấy được tôn trọng và thấu hiểu.</p>\n<p>Bên cạnh đó yếu tố cộng đồng trên NK88 mang lại cảm giác gắn kết rõ rệt. Người chơi có thể theo dõi thành tích chia sẻ trải nghiệm và tham gia các hoạt động tương tác đầy hứng khởi. Bầu không khí sôi động này giúp trải nghiệm không còn mang tính cá nhân mà trở thành hành trình giải trí chung nơi mọi người cùng học hỏi và truyền cảm hứng cho nhau.</p>",
    "date": "2026-02-16T00:33:42.000Z",
    "url": "https://velog.io/@sitepage/Khng-Gian-Gii-Tr-Sng-To-Trn-NK88"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Hành Trình Giải Trí Sáng Tạo Cùng Ookk",
    "partialText": "<p>Trong bối cảnh công nghệ số phát triển mạnh mẽ, nhu cầu giải trí trực tuyến của người chơi ngày càng đa dạng và tinh tế hơn. Ookk xuất hiện như một không gian giải trí mới mẻ, mang đến cho người chơi cảm giác hứng thú ngay từ những trải nghiệm đầu tiên. Với cách tiếp cận hiện đại và tập trung vào người dùng, nền tảng này nhanh chóng tạo được ấn tượng nhờ sự thân thiện, dễ sử dụng và khả năng đáp ứng tốt nhiều phong cách chơi khác nhau.</p>\n<p>Trải nghiệm chơi tại <a href=\"https://ookk.asia\">Ookk</a> được xây dựng dựa trên sự mượt mà và ổn định. Người chơi có thể dễ dàng truy cập và tham gia trên nhiều thiết bị, từ máy tính cá nhân đến điện thoại thông minh. Giao diện được thiết kế trực quan, màu sắc hài hòa giúp giảm cảm giác mệt mỏi khi chơi trong thời gian dài. Các hiệu ứng hình ảnh và âm thanh được kết hợp tinh tế, tạo nên bầu không khí giải trí sống động nhưng vẫn giữ được sự dễ chịu cho người chơi.</p>\n<p>Một trong những điểm thu hút của Ookk là cách trò chơi được sắp xếp khoa học, giúp người chơi nhanh chóng tìm thấy nội dung phù hợp với sở thích của mình. Dù là người mới hay đã có kinh nghiệm, ai cũng có thể dễ dàng làm quen và tận hưởng trọn vẹn quá trình chơi. Các hướng dẫn được trình bày rõ ràng, từng bước giúp người chơi hiểu luật và nắm bắt nhịp độ một cách tự nhiên, từ đó tăng thêm sự tự tin khi tham gia.</p>\n<p>Bên cạnh yếu tố kỹ thuật, Ookk còn chú trọng đến cảm xúc và trải nghiệm tổng thể của người chơi. Mỗi lượt chơi không chỉ mang tính giải trí mà còn tạo cảm giác thử thách vừa đủ, kích thích sự tập trung và tư duy. Người chơi có thể cảm nhận rõ sự tiến bộ của bản thân qua từng lần tham gia, điều này mang lại động lực để tiếp tục khám phá và chinh phục những trải nghiệm mới.</p>\n<p>Không gian cộng đồng cũng là một phần quan trọng trong hành trình tại Ookk. Người chơi có cơ hội kết nối, chia sẻ kinh nghiệm và niềm vui với những người có cùng sở thích. Sự tương tác này giúp tạo nên một môi trường tích cực, nơi mọi người cùng nhau học hỏi và phát triển kỹ năng. Việc tham gia cộng đồng không chỉ làm tăng tính gắn kết mà còn giúp trải nghiệm chơi trở nên phong phú và ý nghĩa hơn.</p>\n<p>Ngoài ra, hệ thống hỗ trợ của Ookk được đánh giá cao nhờ sự nhanh chóng và chuyên nghiệp. Mọi thắc mắc hay vấn đề phát sinh trong quá trình trải nghiệm đều được tiếp nhận và xử lý kịp thời, mang lại cảm giác an tâm cho người chơi. Điều này cho thấy sự cam kết trong việc xây dựng một nền tảng giải trí bền vững và lấy người dùng làm trung tâm.</p>",
    "date": "2026-02-16T00:33:11.000Z",
    "url": "https://velog.io/@sitepage/Hnh-Trnh-Gii-Tr-Sng-To-Cng-Ookk"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Không Gian Giải Trí Sáng Tạo Trên Nền Tảng 678win",
    "partialText": "<p>678win được biết đến như một điểm đến giải trí số hiện đại, nơi người chơi có thể tìm thấy sự cân bằng giữa thư giãn và thử thách. Ngay từ phần giới thiệu, nền tảng này đã tạo ấn tượng bằng phong cách thiết kế gọn gàng, màu sắc hài hòa và cách bố trí rõ ràng. Người chơi mới có thể nhanh chóng làm quen, trong khi người chơi lâu năm vẫn cảm nhận được sự chuyên nghiệp và nhất quán trong từng chi tiết.</p>\n<p>Trải nghiệm chơi tại <a href=\"https://678win.site\">678win</a> mang lại cảm giác mượt mà và ổn định. Tốc độ tải nhanh cùng khả năng phản hồi tốt giúp mọi thao tác trở nên liền mạch. Khi tham gia, người chơi dễ dàng tập trung vào nội dung mà không bị gián đoạn bởi những yếu tố kỹ thuật không mong muốn. Điều này góp phần nâng cao sự hài lòng và tạo nên ấn tượng tích cực ngay từ những phút đầu tiên.</p>\n<p>Nội dung giải trí trên 678win được xây dựng đa dạng, phù hợp với nhiều phong cách khác nhau. Từ những trò chơi mang tính thư giãn nhẹ nhàng đến các lựa chọn đòi hỏi tư duy và phản xạ, người chơi luôn có cảm giác mới mẻ khi khám phá. Việc thường xuyên cập nhật nội dung giúp nền tảng duy trì sức hút và mang đến trải nghiệm không bị lặp lại.</p>\n<p>Hình ảnh và âm thanh là điểm mạnh nổi bật trong quá trình trải nghiệm. Đồ họa sắc nét, hiệu ứng chuyển động mượt mà cùng âm thanh sống động tạo nên không gian giải trí cuốn hút. Mọi chi tiết đều được chăm chút nhằm mang lại cảm giác chân thực và dễ chịu, giúp người chơi tận hưởng trọn vẹn từng khoảnh khắc giải trí.</p>\n<p>Một yếu tố quan trọng khác là tính thân thiện với người dùng. 678win chú trọng đến việc đơn giản hóa thao tác, từ khâu đăng nhập đến quá trình lựa chọn trò chơi. Hệ thống hướng dẫn rõ ràng giúp người mới nhanh chóng nắm bắt cách chơi, trong khi các tùy chọn linh hoạt hỗ trợ người chơi có kinh nghiệm cá nhân hóa trải nghiệm theo sở thích riêng.</p>\n<p>Bên cạnh đó, cộng đồng người chơi trên 678win cũng góp phần tạo nên sức sống cho nền tảng. Sự kết nối và tương tác giúp người chơi cảm thấy mình là một phần của môi trường giải trí năng động. Việc chia sẻ kinh nghiệm và cảm nhận không chỉ làm tăng tính gắn kết mà còn mang lại giá trị tinh thần tích cực.</p>",
    "date": "2026-02-16T00:32:47.000Z",
    "url": "https://velog.io/@sitepage/Khng-Gian-Gii-Tr-Sng-To-Trn-Nn-Tng-678win"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Trải Nghiệm Giải Trí Thông Minh Cùng 88abc",
    "partialText": "<p>88abc mang đến một không gian giải trí số hiện đại nơi người chơi có thể tận hưởng cảm giác thư giãn và hứng khởi ngay từ những phút đầu tiên. Với định hướng xây dựng trải nghiệm thân thiện và dễ tiếp cận, nền tảng này chú trọng vào sự mượt mà trong vận hành cũng như tính trực quan trong thiết kế. Khi bước vào 88abc, người chơi dễ dàng làm quen với cách bố trí rõ ràng, màu sắc hài hòa và các khu vực nội dung được sắp xếp hợp lý giúp thao tác trở nên nhanh chóng và thoải mái.</p>\n<p>Trải nghiệm chơi tại 88abc được đánh giá cao nhờ khả năng hoạt động ổn định trên nhiều thiết bị khác nhau. Dù sử dụng điện thoại hay máy tính, người chơi đều cảm nhận được sự nhất quán về hình ảnh và tốc độ phản hồi. Đồ họa được thiết kế sắc nét kết hợp với hiệu ứng chuyển động mượt mà tạo nên cảm giác sống động trong từng khoảnh khắc. Âm thanh được tinh chỉnh phù hợp giúp tăng sự tập trung và mang lại cảm giác thư giãn khi tham gia trong thời gian dài.</p>\n<p>Một trong những điểm nổi bật của <a href=\"https://88abc-vn.com\">88abc</a> là sự đa dạng trong nội dung trải nghiệm. Nền tảng liên tục đổi mới và cập nhật để mang lại cảm giác tươi mới cho người chơi. Mỗi trò chơi được xây dựng với nhịp độ khác nhau phù hợp với nhiều phong cách giải trí từ nhẹ nhàng đến thử thách. Điều này giúp người chơi dễ dàng lựa chọn hình thức tham gia phù hợp với tâm trạng và sở thích cá nhân mà không cảm thấy nhàm chán.</p>\n<p>Bên cạnh nội dung hấp dẫn 88abc còn chú trọng đến yếu tố tiện lợi trong quá trình sử dụng. Các thao tác truy cập và quản lý tài khoản được tối ưu hóa giúp tiết kiệm thời gian và giảm thiểu sự phức tạp. Hệ thống vận hành trơn tru giúp hạn chế gián đoạn tạo cảm giác liền mạch trong suốt quá trình trải nghiệm. Nhờ đó người chơi có thể tập trung hoàn toàn vào niềm vui giải trí mà không bị ảnh hưởng bởi các vấn đề kỹ thuật.</p>\n<p>Cộng đồng người chơi tại 88abc cũng là một điểm cộng đáng chú ý. Sự tương tác tích cực và tinh thần chia sẻ kinh nghiệm giúp tạo nên môi trường thân thiện và gắn kết. Người chơi mới có thể dễ dàng học hỏi và hòa nhập thông qua những trao đổi cởi mở. Những phản hồi từ cộng đồng được nền tảng ghi nhận và cải thiện thường xuyên góp phần nâng cao chất lượng trải nghiệm chung.</p>",
    "date": "2026-02-16T00:32:21.000Z",
    "url": "https://velog.io/@sitepage/Tri-Nghim-Gii-Tr-Thng-Minh-Cng-88abc"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "IOS에서 컴포넌트란?",
    "partialText": "<p>iOS 앱에서 말하는 <strong>컴포넌트(Component)</strong>는\n👉 <em>“재사용 가능한 UI 또는 기능 단위”</em></p>\n<p>쉽게 말하면,\n앱을 만들 때 반복해서 쓰는 <strong>조립 블록</strong> 같은 개념이야.</p>\n<hr>\n<h2 id=\"1️⃣-ui-관점에서의-컴포넌트\">1️⃣ UI 관점에서의 컴포넌트</h2>\n<p>예를 들어:</p>\n<ul>\n<li>버튼</li>\n<li>카드 뷰</li>\n<li>입력창</li>\n<li>탭바</li>\n<li>모달창</li>\n</ul>\n<p>이런 것들이 전부 컴포넌트야.</p>\n<p>SwiftUI로 보면 이런 식:</p>\n<pre><code class=\"language-swift\">struct PrimaryButton: View {\n    var title: String\n    var action: () -&gt; Void\n\n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(12)\n        }\n    }\n}</code></pre>\n<p>이걸 한 번 만들어두면\n앱 어디에서든 <code>PrimaryButton</code>을 재사용할 수 있어.</p>\n<hr>\n<h2 id=\"2️⃣-구조-관점에서의-컴포넌트\">2️⃣ 구조 관점에서의 컴포넌트</h2>\n<p>*<em>컴포넌트는 UI뿐 아니라 기능 단위로도 나뉘어.\n*</em>\n예:</p>\n<ul>\n<li>로그인 모듈</li>\n<li>네트워크 처리 모듈</li>\n<li>데이터 저장 모듈</li>\n<li>알림 처리 모듈</li>\n</ul>\n<p>즉,</p>\n<pre><code>앱 = 여러 개의 컴포넌트들의 조합</code></pre><hr>\n<h2 id=\"3️⃣-왜-컴포넌트를-쓰는-걸까\">3️⃣ 왜 컴포넌트를 쓰는 걸까?</h2>\n<h3 id=\"✅-1-재사용성\">✅ 1. 재사용성</h3>\n<p>같은 UI를 여러 화면에서 반복 사용 가능</p>\n<h3 id=\"✅-2-유지보수-용이\">✅ 2. 유지보수 용이</h3>\n<p>버튼 디자인을 바꾸면 → 컴포넌트만 수정하면 전체 반영</p>\n<h3 id=\"✅-3-구조-정리\">✅ 3. 구조 정리</h3>\n<p>코드가 깔끔해짐\n(HomeView에 모든 코드가 몰려 있지 않게 됨)</p>\n<hr>\n<h2 id=\"현재-내-사이드-프로젝트의-컴포넌트\">현재 내 사이드 프로젝트의 컴포넌트</h2>\n<p>예를 들어:</p>\n<ul>\n<li>중앙 원형 입력 버튼</li>\n<li>예산 카드 뷰</li>\n<li>카테고리 선택 카드</li>\n<li>인사이트 카드</li>\n</ul>\n<p>이걸 전부 개별 컴포넌트로 분리하면</p>\n<pre><code>HomeView\n ├── BudgetHeroCard\n ├── CentralInputNode\n ├── InsightCard</code></pre><p>이렇게 구조가 명확해져.</p>\n<p>지금 네가 SwiftUI에서 계속 레이아웃 튜닝하는 부분도\n사실은 <strong>컴포넌트 설계 문제</strong>일 가능성이 높아.</p>\n<hr>\n<h2 id=\"한-줄-정의\">한 줄 정의</h2>\n<blockquote>\n<p>컴포넌트 = 앱을 구성하는 재사용 가능한 UI/기능 단위</p>\n</blockquote>\n<hr>",
    "date": "2026-02-16T00:32:17.000Z",
    "url": "https://velog.io/@whynotpm/IOS%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%9E%80"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "[Google Photo] 픽셀폰1 어플리케이션 만들기 - 바이브코딩",
    "partialText": "<blockquote>\n<p>작업된 코드는 아래 github 주소로 올라갑니다.</p>\n</blockquote>\n<ul>\n<li>github 주소: <a href=\"https://github.com/bjkim1988/googlephoto-backup-android\">https://github.com/bjkim1988/googlephoto-backup-android</a></li>\n</ul>\n<p>Antigravity를 켜고 Android studio의 프로젝트가 생성된 디렉토리로 open을 한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/dev_4_sale/post/3418d1a2-8dd1-46a2-91ca-d783d7d5b219/image.png\" alt=\"\">\n상단 오른쪽 Login 버튼을 누르면 google login 하라는 창이 나온다.</p>\n<p><img src=\"https://velog.velcdn.com/images/dev_4_sale/post/d5db5eed-388a-4c9c-b5fa-26e106ac1ef1/image.png\" alt=\"\"></p>\n<p>Agent를 무엇을 사용할지도 선택할 수 있다. 코딩하면 Claude Sonnet이지만, 일단 의리의 Gemini 3 pro (High) 로 써보자.\n<img src=\"https://velog.velcdn.com/images/dev_4_sale/post/2d04526e-7192-4d4e-aff0-e1295a0f5e2d/image.png\" alt=\"\"></p>\n<p>이제 질문을 해보자\n<img src=\"https://velog.velcdn.com/images/dev_4_sale/post/de115ba9-d2e4-4ff3-8190-95ef1811a196/image.png\" alt=\"\"></p>\n<p>아래와 같이 Task List가 나왔다.\n<img src=\"https://velog.velcdn.com/images/dev_4_sale/post/f5345098-2b43-45c6-9559-e4f2a7c78560/image.png\" alt=\"\"></p>\n<p>뭔지 정확하게 모르겠지만 일단 그대로 진행해달라고 해보자</p>\n<p><img src=\"https://velog.velcdn.com/images/dev_4_sale/post/76e8293f-0f43-4e98-8a94-3bda290a1740/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/dev_4_sale/post/f1a9f943-5ef1-4ccd-93ba-0b156d2edf54/image.png\" alt=\"\">\nThinking... 이라고 나오면서 뭔가 계속 하고 있는 느낌이다.</p>\n<p>얼추 끝났는지, 어디에 어떤 코드가 변경되었는지 나온다.\n<img src=\"https://velog.velcdn.com/images/dev_4_sale/post/947a5198-2154-423d-a3a1-2ee14064b9c8/image.png\" alt=\"\"></p>\n<p>변경된 파일을 하나씩 눌러보면, 뭐가 얼마나 변경되었는지 알 수 있다.\n<img src=\"https://velog.velcdn.com/images/dev_4_sale/post/1442c7db-9945-4153-85d5-af0e70bc2e28/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/dev_4_sale/post/0fe82746-ae17-4081-9e09-14a8f3124c9d/image.png\" alt=\"\"></p>\n<p>일단 Accept all 을 눌러보자.</p>\n<p>그리고 Android studio에 돌아가서 run &#39;App&#39; 버튼을 눌러보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/dev_4_sale/post/c948d335-3489-4e46-8790-e3bd5c70942a/image.png\" alt=\"\"></p>\n<p>그리고.. 이런 저런 질문들을 하면서 꽤 기능적으로 완성도 높은 어플을 완성했다.</p>\n<p>아래는 제작된 어플리케이션 화면이다</p>\n<p>&lt;NAS Adrees 입력 화면&gt;\n<img src=\"https://velog.velcdn.com/images/dev_4_sale/post/13254645-cca9-4a65-a1c8-6983ee6f8b87/image.png\" alt=\"\">\n픽셀폰은 항상 wifi 에 연결되어있을테니, 같은 네트워크 (Wifi)에 연결되어있는 NAS를 찾아주는 기능을 만들었다.\n&quot;Find NAS Address&quot; 버튼을 누르면 subnet에 있는 ip주소를 검색해서 NAS를 찾아준다.</p>\n<p><img src=\"https://velog.velcdn.com/images/dev_4_sale/post/b72e38fc-e784-4695-827c-47474f40f933/image.png\" alt=\"\">\nNAS를 찾아주었다.</p>\n<p>검색된 NAS 주소를 클릭하면 주소창에 바로 입력이 된다. 그리고 Next를 누르면 ID, password를 입력하라는 창이 나온다.</p>\n<p>로그인을 하면 NAS의 경로에 파일 list가 나온다.\n<img src=\"https://velog.velcdn.com/images/dev_4_sale/post/3fb0e170-c8c3-4748-a708-b0dacbc2c097/image.png\" alt=\"\"></p>\n<p>Start Backup 버튼을 누르면 현재 디렉토리의 파일들을 local로 다운로드를 하고, 다운로드가 완료된 파일은 /homes/{user-name}/googlephoto_backup 디렉토리로 이동한다.</p>\n<p>추후에 google photo에 upload가 완료된 것이 확인되면 이 경로의 파일들을 삭제할 예정이다.</p>\n<p>특정 파일을 upload, delete 할 수 있는 기능도 추가해두었다.\n<img src=\"https://velog.velcdn.com/images/dev_4_sale/post/db92eba5-17dd-4a2c-a780-9f0bd6413fea/image.png\" alt=\"\">\n파일 목록을 길게 누르면 select 모드로 변환한다. checkbox가 on 된 파일들을 어떻게 처리할지 선택할 수 있다.</p>\n<p>Del: 삭제 / Download: 폰으로 다운로드 / Backup: 폰으로 다운로드 후 임시저장소로 이동</p>\n<p>Backup 이라는 문구는 동작에 대해 직관적이지 않아 다른 이름으로 교체해야 겠다.</p>",
    "date": "2026-02-16T00:31:05.000Z",
    "url": "https://velog.io/@dev_4_sale/Google-Photo-%ED%94%BD%EC%85%80%ED%8F%B01-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%94%EC%9D%B4%EB%B8%8C%EC%BD%94%EB%94%A9"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Hành Trình Giải Trí Số Cùng Kwin68",
    "partialText": "<p><a href=\"https://kwin68-vn.com\">Kwin68</a> mang đến một không gian giải trí số hiện đại nơi người chơi có thể tận hưởng những phút giây thư giãn trọn vẹn ngay từ lần trải nghiệm đầu tiên. Với giao diện được thiết kế thân thiện và bố cục rõ ràng, nền tảng này tạo cảm giác gần gũi và dễ sử dụng cho cả người mới lẫn người đã quen với các trò chơi trực tuyến. Màu sắc hài hòa cùng hiệu ứng mượt mà giúp người chơi nhanh chóng hòa mình vào thế giới giải trí sống động và hấp dẫn.</p>\n<p>Điểm nổi bật trong trải nghiệm tại Kwin68 nằm ở sự đa dạng của nội dung. Mỗi trò chơi đều được xây dựng với cốt lõi rõ ràng, luật chơi dễ hiểu nhưng vẫn đủ chiều sâu để giữ chân người chơi lâu dài. Từ những trò chơi mang tính thư giãn nhẹ nhàng cho đến những thử thách đòi hỏi tư duy và phản xạ nhanh, người chơi luôn có nhiều lựa chọn phù hợp với tâm trạng và sở thích của mình. Sự phong phú này giúp mỗi lần đăng nhập đều trở nên mới mẻ và không bị nhàm chán.</p>\n<p>Bên cạnh nội dung phong phú, trải nghiệm người dùng cũng được Kwin68 chú trọng phát triển. Tốc độ tải nhanh và khả năng tương thích tốt trên nhiều thiết bị giúp người chơi có thể tham gia bất cứ lúc nào và ở bất kỳ đâu. Dù sử dụng máy tính hay điện thoại di động, các thao tác đều mượt mà và ổn định, tạo nên cảm giác liền mạch trong suốt quá trình trải nghiệm. Điều này đặc biệt quan trọng với những người chơi yêu thích sự tiện lợi và linh hoạt.</p>\n<p>Yếu tố cộng đồng cũng góp phần làm nên sức hút của Kwin68. Người chơi có cơ hội kết nối và giao lưu thông qua các hoạt động chung, từ đó tạo nên bầu không khí sôi động và thân thiện. Sự tương tác này không chỉ mang lại niềm vui mà còn giúp người chơi học hỏi thêm kinh nghiệm và chiến lược từ những người khác. Cảm giác đồng hành cùng cộng đồng khiến mỗi trải nghiệm trở nên ý nghĩa hơn.</p>\n<p>Ngoài ra, Kwin68 còn chú trọng đến cảm xúc của người chơi trong từng chi tiết nhỏ. Âm thanh sống động kết hợp với hình ảnh sắc nét tạo nên không gian giải trí chân thực. Những hiệu ứng khi hoàn thành thử thách hay đạt được thành tích mang lại cảm giác hào hứng và động lực để tiếp tục khám phá. Chính sự chăm chút này giúp người chơi luôn cảm thấy được trân trọng và khích lệ.</p>",
    "date": "2026-02-16T00:29:38.000Z",
    "url": "https://velog.io/@sitepage/Hnh-Trnh-Gii-Tr-S-Cng-Kwin68"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Openclaw gateway 터미널 창 없애기 (백그라운드 전환)",
    "partialText": "<p>Openclaw 를 실행하기 위해서는 <code>gateway</code> 를 실행시켜줘야한다.</p>\n<p>일반적으로 Openclaw 를 설치하면 이는 자동으로 백그라운드 상황에서 돌아가기 때문에 우리가 따로 설정해주지 않아도 되지만, 이상하게 내 윈도우 환경에서는 포그라운드에서 돌아가는 문제가 있었다. (즉, 터미널이 켜져있고, 터미널을 끄면 gateway 가 종료되었다.)</p>\n<p>이러한 상황에서 백그라운드로 전환을 어떻게 하나 했는데, 1개의 파일 생성과 간단한 설정만 마치면 되었다.</p>\n<hr>\n<h3 id=\"1-vbs-파일-생성\">1. VBS 파일 생성</h3>\n<p><code>C:\\Users\\유저이름\\.openclaw\\</code> 경로에 <code>run_gateway_silent.vbs</code> 라는 파일을 생성해주자.</p>\n<p>그 다음 다음을 내용으로 입력한다.</p>\n<pre><code class=\"language-bash\">Set WshShell = CreateObject(&quot;WScript.Shell&quot;)\nWshShell.Run &quot;&quot;&quot;C:\\Users\\Gyu\\.openclaw\\gateway.cmd&quot;&quot;&quot;, 0, False</code></pre>\n<p>윈도우 환경의 경우 <code>Text 파일 생성 -&gt; 다른 이름으로 저장 -&gt; 파일 형식 모든파일</code> 로 설정하면 된다.</p>\n<h3 id=\"2-작업-스케줄러-편집\">2. 작업 스케줄러 편집</h3>\n<blockquote>\n</blockquote>\n<ol>\n<li>Win + R → taskschd.msc</li>\n<li>작업 스케줄러 라이브러리 → OpenClaw Gateway 우클릭 → 속성</li>\n<li>동작(Actions) 탭</li>\n<li>기존 “C:\\Users\\유저.openclaw\\gateway.cmd” 실행 Action을 편집(Edit)</li>\n<li>프로그램/스크립트(Program/script):wscript.exe</li>\n<li>인수 추가(Add arguments): &quot;C:\\Users\\유저.openclaw\\run_gateway_silent.vbs&quot;</li>\n<li>저장</li>\n</ol>\n<p><code>wscript.exe</code> 의 위치는 일반적으로 다음과 같다.</p>\n<pre><code>C:\\Windows\\System32\\wscript.exe (64-bit)\nC:\\Windows\\SysWOW64\\wscript.exe (32-bit)</code></pre><h3 id=\"완료\">완료</h3>\n<p>이제 컴퓨터 재시작 후 확인해보면 터미널 창이 뜨지 않고 백그라운드 상태로 돌아가는 것을 확인할 수 있다 !</p>",
    "date": "2026-02-16T00:29:22.000Z",
    "url": "https://velog.io/@devgyu/Openclaw-gateway-%ED%84%B0%EB%AF%B8%EB%84%90-%EC%B0%BD-%EC%97%86%EC%95%A0%EA%B8%B0-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%A0%84%ED%99%98"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Hành Trình Giải Trí Sống Động Trên VJ88",
    "partialText": "<p>VJ88 được nhiều người chơi biết đến như một không gian giải trí trực tuyến hiện đại nơi trải nghiệm người dùng được đặt lên hàng đầu. Ngay từ lần đầu tiếp cận nền tảng này người chơi có thể cảm nhận rõ sự đầu tư vào giao diện và cách sắp xếp nội dung. Màu sắc hài hòa bố cục gọn gàng giúp người mới dễ dàng làm quen trong khi vẫn mang lại cảm giác chuyên nghiệp cho người chơi lâu năm. Sự thân thiện trong thiết kế tạo nên ấn tượng ban đầu tích cực và khuyến khích người dùng khám phá sâu hơn.</p>\n<p>Trải nghiệm chơi game trên VJ88 được xây dựng xoay quanh yếu tố mượt mà và ổn định. Các trò chơi tải nhanh hạn chế tình trạng gián đoạn và duy trì nhịp chơi liên tục. Điều này đặc biệt quan trọng với những người yêu thích cảm giác liền mạch và tập trung. Âm thanh hình ảnh được tối ưu rõ nét mang đến không khí sống động giống như đang tham gia trực tiếp vào thế giới giải trí ảo đầy màu sắc. Sự kết hợp giữa công nghệ và sáng tạo giúp mỗi phiên chơi trở nên cuốn hút hơn.</p>\n<p>Một điểm nổi bật khác của <a href=\"https://vj88-online.com\">VJ88</a> là sự đa dạng trong nội dung giải trí. Người chơi có thể dễ dàng tìm thấy nhiều thể loại khác nhau phù hợp với sở thích cá nhân từ những trò chơi mang tính thư giãn đến các thử thách đòi hỏi tư duy và phản xạ. Việc liên tục cập nhật nội dung mới giúp nền tảng luôn giữ được sức hút và tránh cảm giác nhàm chán. Người chơi vì thế luôn có động lực quay lại để khám phá những trải nghiệm mới mẻ.</p>\n<p>Bên cạnh nội dung phong phú VJ88 còn chú trọng đến trải nghiệm cá nhân hóa. Hệ thống gợi ý thông minh giúp người chơi nhanh chóng tìm được trò chơi phù hợp với thói quen của mình. Các tính năng hỗ trợ được bố trí rõ ràng giúp thao tác trở nên thuận tiện hơn. Sự quan tâm đến chi tiết nhỏ này cho thấy nền tảng không chỉ tập trung vào số lượng trò chơi mà còn chú trọng đến cảm nhận thực tế của người dùng trong suốt quá trình tham gia.</p>\n<p>Yếu tố cộng đồng cũng góp phần tạo nên sức hấp dẫn của VJ88. Người chơi có thể cảm nhận được sự kết nối thông qua các hoạt động tương tác và bảng xếp hạng mang tính khích lệ. Điều này tạo ra bầu không khí sôi động nơi mọi người cùng chia sẻ niềm vui và thành tích. Trải nghiệm không còn mang tính cá nhân đơn lẻ mà trở thành hành trình giải trí chung đầy cảm hứng.</p>",
    "date": "2026-02-16T00:28:59.000Z",
    "url": "https://velog.io/@sitepage/Hnh-Trnh-Gii-Tr-Sng-ng-Trn-VJ88"
  },
  {
    "publisherId": "velog",
    "publisherName": "Velog",
    "specTitle": "개발자 블로그",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://v2.velog.io/rss/",
    "title": "Trải Nghiệm Giải Trí Số Hiện Đại Cùng VJ88",
    "partialText": "<p>Trong những năm gần đây, thế giới trò chơi trực tuyến đã có nhiều thay đổi mạnh mẽ, mang đến cho người chơi những trải nghiệm ngày càng đa dạng và hấp dẫn hơn. VJ88 xuất hiện như một điểm đến quen thuộc đối với cộng đồng yêu thích giải trí số, nơi người chơi có thể tận hưởng cảm giác thư giãn và thử thách trong một môi trường được thiết kế hiện đại. Ngay từ lần đầu tiếp cận, người chơi dễ dàng cảm nhận được sự đầu tư nghiêm túc vào giao diện, tốc độ truy cập và cách sắp xếp nội dung rõ ràng, giúp việc khám phá trở nên thuận tiện và thoải mái.</p>\n<p>Trải nghiệm chơi tại <a href=\"https://vj88-vn.com\">VJ88</a> được xây dựng xoay quanh sự mượt mà và ổn định. Các trò chơi được tối ưu hóa để hoạt động tốt trên nhiều thiết bị khác nhau, từ máy tính đến điện thoại thông minh. Điều này cho phép người chơi linh hoạt tham gia bất cứ lúc nào, dù đang ở nhà hay di chuyển. Âm thanh sống động kết hợp với hình ảnh sắc nét tạo nên không gian giải trí chân thực, giúp người chơi dễ dàng đắm chìm vào từng khoảnh khắc trải nghiệm.</p>\n<p>Một điểm nổi bật khác của VJ88 chính là sự đa dạng trong cách chơi. Người chơi có thể lựa chọn nhiều phong cách giải trí khác nhau, từ nhẹ nhàng thư giãn đến những thử thách đòi hỏi sự tập trung cao. Mỗi trò chơi đều có hướng dẫn rõ ràng, giúp người mới nhanh chóng làm quen, trong khi người chơi lâu năm vẫn tìm thấy sự mới mẻ và hứng thú. Cảm giác tiến bộ qua từng vòng chơi mang lại động lực để người chơi tiếp tục khám phá và chinh phục.</p>\n<p>Bên cạnh nội dung trò chơi, yếu tố cộng đồng cũng được VJ88 chú trọng phát triển. Người chơi có cơ hội giao lưu, chia sẻ kinh nghiệm và cảm xúc với những người có cùng sở thích. Sự tương tác này không chỉ làm tăng tính kết nối mà còn tạo ra một không gian giải trí thân thiện và tích cực. Việc tham gia cộng đồng giúp người chơi học hỏi thêm nhiều chiến thuật mới, đồng thời cảm nhận được niềm vui khi cùng nhau trải nghiệm.</p>\n<p>Hệ thống hỗ trợ và dịch vụ khách hàng của VJ88 cũng góp phần nâng cao trải nghiệm tổng thể. Các vấn đề kỹ thuật hoặc thắc mắc trong quá trình chơi được phản hồi nhanh chóng, mang lại cảm giác an tâm cho người dùng. Sự chuyên nghiệp trong cách vận hành cho thấy nỗ lực xây dựng một môi trường giải trí bền vững, nơi người chơi luôn được đặt ở vị trí trung tâm.</p>",
    "date": "2026-02-16T00:28:19.000Z",
    "url": "https://velog.io/@sitepage/Tri-Nghim-Gii-Tr-S-Hin-i-Cng-VJ88"
  }
]