[
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "읽지 않는 코드의 시대",
    "partialText": "[![NHN Cloud_meetup banner_coding_202602_900.png](https://image.toast.com/aaaadh/real/2026/techblog/NHN%20Cloudmeetup%20bannercoding202602900.png)](https://www.nhncloud.com/kr)&#xD;\r\n&#xD;\r\n&gt;  본 콘텐츠는 작성자가 사내 게시판에 공유한 글을 가공한 것으로, 작성자의 의도와 맥락을 충실히 전달하기 위해 원문의 문장 스타일을 그대로 유지하였습니다.&#xD;\r\n&#xD;\r\n&#xD;\r\n---&#xD;\r\n&lt;br&gt;&#xD;\r\n&#xD;\r\n나는 오랫동안 아름다운 코드를 꿈꿔 왔다.&#xD;\r\n&#xD;\r\n순수 함수들이 물 흐르듯 합성되고, 타입 시스템이 버그를 원천적으로 불가능하게 만들며, 수학적 증명처럼 견고한 로직이 펼쳐지는 그런 코드. 우리는 그것을 '장인 정신'이라 불렀고, 그 경지에 도달하기 위해 범주론을 공부하고, 타입 레벨 프로그래밍을 이해하려 씨름했다.&#xD;\r\n&#xD;\r\n그러나 어느 날 문득 깨달았다. 더 이상 아무도 코드를 읽지 않는다는 것을.&#xD;\r\n&lt;br&gt;&#xD;\r\n## 가독성의 정의가 바뀌다&#xD;\r\n'가독성'이라는 단어의 의미가 조용히, 그러나 근본적으로 변하고 있다.&#xD;\r\n과거의 가독성은 **인간의 인지**를 위한 것이었다.&#xD;\r\n&#xD;\r\n* 개발자가 로직을 머릿속에서 추적할 수 있는가&#xD;\r\n* 동료가 코드 리뷰에서 오류를 발견할 수 있는가&#xD;\r\n* 6개월 후의 내가 이 코드를 이해할 수 있는가&#xD;\r\n&#xD;\r\n우리는 이 질문들에 답하기 위해 클린 코드(Clean Code)를 논했고, SOLID 원칙을 세웠으며, 디자인 패턴이라는 공통 언어를 만들었다. 모두 인간의 제한된 작업 기억 용량 안에서 복잡성을 다루기 위한 몸부림이었다.&#xD;\r\n그러나 이제 가독성은 기계의 패턴 인식을 위한 것이 되어 가고 있다.&#xD;\r\n&#xD;\r\n* AI가 이 코드의 패턴을 학습 데이터에서 본 적 있는가&#xD;\r\n* AI가 수정 요청을 받았을 때 정확한 위치를 찾을 수 있는가&#xD;\r\n* AI가 로컬 변경을 가했을 때 전체 시스템이 깨지지 않는가&#xD;\r\n&#xD;\r\n이 두 가지 가독성은 때로 겹치지만, 본질적으로 다른 것을 최적화한다. 인간을 위한 가독성은 **추상화와 압축**을 추구한다. 반복을 제거하고, 패턴을 이름 붙이며, 복잡성을 캡슐화한다. 기계를 위한 가독성은 **명시성과 예측 가능성**을 추구한다. 관습을 따르고, 구조를 일정하게 유지하며, 장황하고 지저분해지더라도 암묵적인 것을 명시적으로 드러낸다.&#xD;\r\n&lt;br&gt;&#xD;\r\n## 장인 정신의 비극적 위치&#xD;\r\n&#xD;\r\n함수형 프로그래밍이 약속했던 것은 명확했다. 인간의 인지적 한계를 코드로 극복하는 것.&#xD;\r\n참조 투명성은 코드의 어떤 부분이든 독립적으로 추론할 수 있게 해주었다. 불변성은 시간에 따른 상태 변화를 머릿속에서 추적하는 부담을 덜어주었다. 강력한 타입 시스템은 컴파일러가 우리 대신 오류를 잡아주었다. 이 모든 것이 **인간의 한계를 보완**하기 위한 도구였다.&#xD;\r\n&#xD;\r\n그러나 AI에게는 보완할 한계가 없다.&#xD;\r\n&#xD;\r\nAI는 수백만 개의 코드베이스를 학습했다. 패턴 매칭의 원시적 힘으로 무장한 AI에게, 인간의 인지 부하를 줄여주는 우아한 추상화는 그저 노이즈에 가깝다. AI는 똑같은 CRUD 작업의 만 가지 변형을 보았다. 심혈을 기울여 작성한 우아한 모나드 트랜스포머 스택보다 평범하고 반복적인 명령형 코드가 AI에게는 더 익숙하다.&#xD;\r\n여기서 장인 정신의 딜레마가 시작된다.&#xD;\r\n&#xD;\r\n함수형 프로그래밍의 지지자들은 수십 년간 같은 말을 해왔다.&#xD;\r\n&#xD;\r\n\"배우기는 어렵지만, 장기적 이점이 있습니다.\"&#xD;\r\n&#xD;\r\n그런데 AI가 명령형 프로그래밍의 진입 장벽을 무너뜨려버렸다. 이제 누구나 AI의 도움으로 명령형 코드를 빠르게 작성할 수 있다. 반면 함수형 프로그래밍의 학습 곡선은 여전히 가파르다.&#xD;\r\n더욱 쓸쓸한 것은 함수형 프로그래밍의 아름다움을 감상할 줄 아는 사람들마저 더 이상 코드를 직접 읽지 않는다는 사실이다. 그들의 Claude Code가 대신 읽는다. 감상할 눈이 사라진 예술이 무슨 의미가 있을까.&#xD;\r\n&#xD;\r\n```&#xD;\r\nClaude &gt;&gt; @PureFunctional OrderService::doStuff의 로직을 분석해서 설명해 줘&#xD;\r\n```&#xD;\r\n&lt;br&gt;&#xD;\r\n## 매개체로 전락한 코드&#xD;\r\n&#xD;\r\n이제 코드의 존재론적 지위가 바뀌고 있다.&#xD;\r\n과거에 코드는 인간의 영역이었다. 우리는 그 안에서 살았다. 매일 읽고, 고치고, 확장했다. 변수명 하나에 고민하고, 함수의 위치를 두고 토론했다. 코드는 우리의 생각이 물질화된 것이었고, 그래서 우리는 그것의 아름다움에 신경 썼다.&#xD;\r\n이제 코드는 인간의 의도와 기계의 실행 사이를 잇는 매개체가 되어 가고 있다.&#xD;\r\n&#xD;\r\n```&#xD;\r\n인간의 의도 → 자연어 명세 → AI → 코드(누가 신경이나 쓰는가) → 실행&#xD;\r\n```&#xD;\r\n&#xD;\r\n이 모델에서 함수형 vs 객체지향 논쟁은 x86 vs ARM 논쟁과 비슷해진다. 특정 상황에서 성능 차이가 있을 수 있다. 그러나 그것은 더 이상 인간이 거주하는 층위가 아니다.&#xD;\r\n우리는 집을 짓는 목수에서 집을 주문하는 건축주가 되어 가고 있다. 목수에게 나뭇결은 단순한 무늬가 아니다. 그것은 나무의 강도와 방향을 말해주고, 어디를 깎고 어디를 살려야 할지 알려주며, 완성된 작품이 세월을 어떻게 견딜지를 예언한다. 그러나 건축주는 문이 제대로 닫히면 그만이다.&#xD;\r\n&lt;br&gt;&#xD;\r\n## 새로운 미학의 등장&#xD;\r\n&#xD;\r\n그렇다면 AI 시대의 '좋은 코드'란 무엇인가? 새로운 미학이 필요하다.&#xD;\r\n&#xD;\r\n### 관용적 표현이 최적화를 이긴다&#xD;\r\n&#xD;\r\n```&#xD;\r\n// AI 친화적: 수백만 번 본 패턴&#xD;\r\nusers.stream().filter(User::isActive).toList();&#xD;\r\n&#xD;\r\n// AI 비친화적: 이게 뭐 하는 코드지?&#xD;\r\nusers.stream().reduce(new ArrayList&lt;&gt;(),&#xD;\r\n    (acc, u) -&gt; { if(u.isActive()) acc.add(u); return acc; },&#xD;\r\n    (a, b) -&gt; { a.addAll(b); return a; });&#xD;\r\n```&#xD;\r\n&#xD;\r\nAI는 익숙한 것을 잘 다룬다. 창의적인 최적화보다 평범한 관용구가 더 안전하다.&#xD;\r\n&#xD;\r\n### 추론의 지역성&#xD;\r\n&#xD;\r\n함수를 이해하는 데 필요한 모든 것이 눈에 보이거나, 한 번의 점프로 도달 가능해야 한다. Action at a distance는 금물이다. Dependency injection 트릭, aspect weaving, runtime proxy—이 모든 암묵적 메커니즘이 AI의 추론을 방해한다.&#xD;\r\n&#xD;\r\n### 예측 가능한 구조&#xD;\r\n&#xD;\r\n```&#xD;\r\n/order&#xD;\r\n  OrderController.java&#xD;\r\n  OrderService.java&#xD;\r\n  OrderRepository.java&#xD;\r\n  Order.java&#xD;\r\n```&#xD;\r\n&#xD;\r\nAI는 관습에서 맥락을 추론한다. 파일이 어디 있을지 예측할 수 있으면, 탐색 비용이 줄어든다. 관습은 압축된 정보다.&#xD;\r\n&#xD;\r\n### 명시적 상태 전이&#xD;\r\n&#xD;\r\n```&#xD;\r\n// AI 친화적: 가능한 상태가 명시적으로 열거됨&#xD;\r\nenum Status { DRAFT, SUBMITTED, FULFILLED }&#xD;\r\n&#xD;\r\n// AI 비친화적: 플래그 조합으로 상태를 유추해야 함&#xD;\r\nboolean isSubmitted;&#xD;\r\nboolean isFulfilled;&#xD;\r\nboolean isDraft;&#xD;\r\n```&#xD;\r\n&#xD;\r\n상태가 열거형으로 선언되어 있으면 AI는 전체 그림을 한눈에 파악한다. 여러 boolean 플래그를 조합해서 상태를 유추해야 하는 코드는 AI도 인간처럼 길을 잃는다. `isSubmitted`와 `isFulfilled`가 동시에 true면 무슨 상태인가?&#xD;\r\n&#xD;\r\n### 장황하지만 명확한 이름&#xD;\r\n&#xD;\r\n```&#xD;\r\n// AI 친화적: 이름만 봐도 의도가 명확&#xD;\r\npublic boolean isEligibleForRefundBasedOnPurchaseDateAndMembershipStatus()&#xD;\r\n&#xD;\r\n// AI 비친화적: 주석에 의존&#xD;\r\n/** 구매일과 멤버십 상태에 따라 환불 가능 여부를 판단한다 */&#xD;\r\npublic boolean canRefund()&#xD;\r\n```&#xD;\r\n&#xD;\r\n인간에게는 간결한 이름과 상세한 주석이 읽기 좋을 수 있다. 그러나 AI는 주석보다 코드를 신뢰한다. 함수명 자체가 의도를 담고 있으면, AI는 별도의 맥락 없이도 정확하게 해당 함수를 활용할 수 있다.&#xD;\r\n&#xD;\r\n### 작은 파일, 단일 책임&#xD;\r\n&#xD;\r\n100줄짜리 파일 10개가 1000줄짜리보다 낫다. AI의 컨텍스트 윈도우는 실질적 제약이다. 작은 파일은 전체를 교체하기도, 부분을 수정하기도 쉽다.&#xD;\r\n&#xD;\r\n### 명세로서의 테스트&#xD;\r\n&#xD;\r\n```&#xD;\r\n@Test&#xD;\r\nvoid shouldRejectOrderWhenInventoryInsufficient() { ... }&#xD;\r\n```&#xD;\r\n&#xD;\r\nAI는 테스트를 읽고 코드의 의도를 역으로 파악한다. 테스트 이름이 곧 요구 사항이 되고, 테스트 본문이 곧 예제가 된다.&#xD;\r\n&lt;br&gt;&#xD;\r\n## 아이러니: 함수형의 귀환&#xD;\r\n&#xD;\r\n흥미로운 반전이 있다.&#xD;\r\nAI 친화적 코드의 원칙들—불변성, 명시적 상태, 작고 순수한 함수—은 함수형 프로그래밍의 원칙과 상당 부분 겹친다.&#xD;\r\n함수형 프로그래밍은 살아남을 것이다. 그것이 아름다워서가 아니라, **기계가 읽기 좋아서**.&#xD;\r\n&#xD;\r\n고차원적 추상화와 이론적 우아함은 사라질 것이다. 그러나 불변 데이터, 순수 함수, 명시적 타입은 남을 것이다. 미학은 바뀌었지만, 핵심 원칙들은 다른 이유로 생명을 얻었다. 이것이 함수형 프로그래밍 애호가들에게 위안이 될지는 모르겠다. 사랑하는 것이 살아남았지만, 사랑 받는 이유가 완전히 달라졌으니.&#xD;\r\n&lt;br&gt;&#xD;\r\n## 결론&#xD;\r\n&#xD;\r\n우리는 아름다운 시대의 끝자락에 서 있다.&#xD;\r\n코드를 매개로 인간과 인간이 소통하던 시대. 변수명 하나에 의도를 담고, 함수의 구조로 사고의 흐름을 표현하던 시대. 동료의 코드를 읽으며 그의 사고방식을 이해하고, 때로는 감탄하던 시대.&#xD;\r\n&#xD;\r\n그 시대가 저물고 있다.&#xD;\r\n코드는 점점 인간의 눈을 거치지 않는 영역으로 이동하고 있다. 우리가 코드 안에서 살았기 때문에 그 아름다움에 신경 썼듯이, 우리가 코드 밖으로 나가면 그 아름다움은 의미를 잃는다. 장인 정신은 LP 레코드나 기계식 시계처럼—효율보다 과정을 사랑하는 이들의 영역으로 남게 될 것이다. 시장은 우아함을 알아봐주지 않는다. 시장은 속도를 원한다. 그리고 AI가 명령형 코드의 속도를 거의 무한히 빠르게 만들어 버렸다.&#xD;\r\n&#xD;\r\n그래도 우리는 가끔, 퇴근 후 조용한 사무실에서 마침내 완성한 순수 함수의 체인이 테스트를 통과하며 초록불이 켜지던 순간을 기억할 것이다. 타입 시스템이 버그를 컴파일 타임에 잡아주었을 때의 희열을. 코드가 단지 작동하는 것을 넘어, 그 자체로 하나의 증명이 되었을 때의 만족을.&#xD;\r\n&#xD;\r\n아름다운 추억이다.&#xD;\r\n&#xD;\r\n---&#xD;\r\n&#xD;\r\n&gt;  본 콘텐츠는 작성자가 사내 게시판에 공유한 글을 가공한 것으로, 작성자의 의도와 맥락을 충실히 전달하기 위해 원문의 문장 스타일을 그대로 유지하였습니다.&#xD;\r\n&#xD;\r\n&#xD;\r\n[![NHN Cloud_meetup banner_footer_202507-01.png](https://image.toast.com/aaaadh/real/2026/techblog/NHN%20Cloudmeetup%20bannerfooter20250701.png)](https://www.nhncloud.com/kr)",
    "date": "2026-02-23T00:20:28.000Z",
    "url": "https://meetup.nhncloud.com/posts/408"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "2025 프론트엔드 뉴스 한 방에 몰아 보기",
    "partialText": "[![NHN Cloud_meetup banner_frontendnews2025_202601_1400.png](https://image.toast.com/aaaadh/real/2026/techblog/NHN%20Cloudmeetup%20bannerfrontendnews20252026011400%282%29.png)](https://www.nhncloud.com/?utm_source=meetup&amp;utm_medium=post&amp;utm_campaign=branding&amp;utm_content=0130_frontend&amp;utm_term=top)&#xD;\r\n&#xD;\r\n안녕하세요. NHN Cloud NCUI개발팀 이진우입니다.&#xD;\r\n&#xD;\r\n저는 매주 30여 개의 Web, Frontend, Design, Design System 등의 기술 뉴스레터를 살피고 동료들에게 공유해 왔는데요. 작년에 이어 올해도 개인적으로 인상 깊었던 아티클을 주제별로 공유드리고자 합니다.&#xD;\r\n&#xD;\r\n&gt; 작년에 공유했던 2024년의 프론트엔드 뉴스 모음은 아래 경로에서 확인하실 수 있습니다.&#xD;\r\n&gt;  [2024 프론트엔드 뉴스 한 방에 몰아 보기](https://meetup.nhncloud.com/posts/390)&#xD;\r\n&#xD;\r\n관심사와 조직 내 영향력이 큰 기술 스택을 중심으로 정리한 내용이기에 프론트엔드 생태계 전체를 대변한다고 보기는 어렵지만, 흥미가 가는 주제가 있다면 함께 첨부한 링크들이 출발점으로서 작은 도움이 되기를 바랍니다.&#xD;\r\n&#xD;\r\n&gt; 본문의 링크들은 과거 시점 기준의 자료이므로 변경된 내용이 있을 수 있습니다.  &#xD;\r\n&#xD;\r\n## Node.js의 TypeScript 지원&#xD;\r\n&#xD;\r\n2025년 초 Node.js는 Bun, Deno와 같은 경쟁자들에게 대적하기 위해 TypeScript 파일 실행 지원을 추가했습니다. 개발자 경험을 향상시키는 것이 주 목적이었기에 타입 체크, 컴파일이 아닌 타입을 걷어내는 것(Type Stripping)으로 방향을 잡았는데요. 이를 위해 SWC를 기반으로 한 Amaro가 핵심 도구로 기대 받았고, TypeScript 측에서도 관련 플래그를 추가했으며 최근 v24.12 버전에서 안정화 단계에 들어서게 되었습니다.&#xD;\r\n&#xD;\r\n### Type Stripping 개념과 구현&#xD;\r\n&#xD;\r\nNode.js가 채택한 Type Stripping 방식의 원리와 구현 배경을 다룹니다.&#xD;\r\n&#xD;\r\n* [Node.js now supports TypeScript by default](https://www.totaltypescript.com/typescript-is-coming-to-node-23)&#xD;\r\n* [Everything you need to know about node.js type stripping](https://satanacchio.hashnode.dev/everything-you-need-to-know-about-nodejs-type-stripping)&#xD;\r\n* [The Summer I Shipped Type Stripping](https://satanacchio.hashnode.dev/the-summer-i-shipped-type-stripping)&#xD;\r\n&#xD;\r\n### 생태계 지원 현황&#xD;\r\n&#xD;\r\nTypeScript 5.8의 플래그 추가, Amaro 1.0 릴리스, Node.js 안정화 버전 등 생태계 전반의 지원 현황입니다.&#xD;\r\n&#xD;\r\n* [Announcing TypeScript 5.8](https://devblogs.microsoft.com/typescript/announcing-typescript-5-8/#the---erasablesyntaxonly-option)&#xD;\r\n* [Node.js Moves Toward Stable TypeScript Support with Amaro 1.0](https://socket.dev/blog/node-js-moves-toward-stable-typescript-support-with-amaro-1-0)&#xD;\r\n* [Node.js v24.12.0](https://nodejs.org/en/blog/release/v24.12.0)&#xD;\r\n&#xD;\r\n### 런타임 간 비교&#xD;\r\n&#xD;\r\nDeno와 Node.js의 TypeScript 지원 비교입니다.&#xD;\r\n&#xD;\r\n* [Node just added TypeScript support. What does that mean for Deno?](https://deno.com/blog/typescript-in-node-vs-deno)&#xD;\r\n&#xD;\r\n## React 2025 회고&#xD;\r\n&#xD;\r\n2025년 React를 보면 프론트엔드의 인프라라고 불러야 할 만큼 범위가 넓어졌습니다. LLM 시대에 React가 사실상 기본 출력물이 되면서 새 프레임워크는 출발부터 불리하다는 주장도 과언이 아닙니다.&#xD;\r\n&#xD;\r\n작년 말 v19 릴리스 이후 `action`, `useActionState`, `useOptimistic`, `&lt;Activity /&gt;` 같은 기능이 추가됐습니다. Form Submit, Loading, Error 등 웹 애플리케이션이 늘 겪는 문제를 React 기본 기능으로 끌어당긴 모양새입니다. 다만 동시성이 기본값이 될수록 개발자도 새로운 규칙을 익혀야 합니다. 코드는 더 선언적으로 보이지만, 어떤 상태를 어떤 방식으로 업데이트할지 조직 내 합의도 필요해질 것 같습니다.&#xD;\r\n&#xD;\r\nv19 이후 CRA(create-react-app)는 사실상 종료됐습니다. 의존성 충돌을 막기 위한 변경 사항이 병합되긴 했지만, 기존 애플리케이션도 Next.js, React Router, Vite 등으로 전환이 권고됐습니다. 이 권고 문구가 Next.js를 지나치게 강조한다며 커뮤니티에서 논란이 되기도 했습니다. 높은 채택률을 보였던 styled-components도 유지보수 모드로 전환됐습니다.&#xD;\r\n&#xD;\r\n연말에는 RSC 보안 이슈가 터졌습니다. React가 인프라가 됐다는 말이 과장이 아님을 보여준 사건입니다. 이제 React가 커졌다는 건 기능의 문제가 아니라 책임 범위의 문제로 봐야 할 것 같습니다.&#xD;\r\n&#xD;\r\n### v19 신규 기능&#xD;\r\n&#xD;\r\naction, useActionState, useOptimistic, Activity, useEffectEvent, use() 등 v19에서 도입된 주요 기능들입니다.&#xD;\r\n&#xD;\r\n* [3 ways to build forms in react (without any libraries)](https://reactpractice.dev/articles/3-ways-to-build-forms-in-react)&#xD;\r\n* [Building Reusable Components with React 19 Actions](https://aurorascharff.no/posts/building-reusable-components-with-react19-actions/)&#xD;\r\n* [useOptimistic to Make Your App Feel Instant](https://www.epicreact.dev/use-optimistic-to-make-your-app-feel-instant-zvyuv)&#xD;\r\n* [How React Suspense Works Under the Hood: Throwing Promises and Declarative Async UI](https://www.epicreact.dev/how-react-suspense-works-under-the-hood-throwing-promises-and-declarative-async-ui-plbrh)&#xD;\r\n* [React Concurrent Features: An Overview](https://certificates.dev/blog/react-concurrent-features-an-overview/)&#xD;\r\n* [React’s useTransition and state update reordering](https://jordaneldredge.com/notes/react-rebasing/)&#xD;\r\n* [Using Activity with Suspenseful data](https://www.simeongriggs.dev/use-the-activity-boundary-to-hide-suspenseful-components/)&#xD;\r\n* [Tried React 19’s Activity Component Here’s What I Learned](https://javascript.plainenglish.io/tried-react-19s-activity-component-here-s-what-i-learned-b0f714003a65)&#xD;\r\n* [Quick look into the useEffectEvent](https://www.nico.fyi/blog/quick-look-use-effect-event)&#xD;\r\n* [React 19.2: React in its sigma era](https://dev.to/sagi0312/react-192-react-in-its-sigma-era-op7)&#xD;\r\n* [React 19.2: The async shift is finally here](https://blog.logrocket.com/react-19-2-the-async-shift/)&#xD;\r\n* [The next era of React has arrived: Here’s what you need to know](https://blog.logrocket.com/the-next-era-of-react/)&#xD;\r\n* [React has changed, your Hooks should too](https://allthingssmitty.com/2025/12/01/react-has-changed-your-hooks-should-too/)&#xD;\r\n* [React RFC: Context Selector](https://github.com/reactjs/rfcs/pull/119/)&#xD;\r\n&#xD;\r\n### 예외 처리&#xD;\r\n&#xD;\r\nError Boundary의 v19 변경 사항과 react-error-boundary 활용법입니다.&#xD;\r\n&#xD;\r\n* [Error Handling in React with react-error-boundary](https://certificates.dev/blog/error-handling-in-react-with-react-error-boundary)&#xD;\r\n* [React 19 Error Boundary Behaves Differently](https://andrei-calazans.com/posts/react-19-error-boundary-changed/)&#xD;\r\n&#xD;\r\n### RSC(React Server Components)&#xD;\r\n&#xD;\r\nServer Components의 동작 원리와 import 메커니즘입니다.&#xD;\r\n&#xD;\r\n* [How Imports Work in RSC](https://overreacted.io/how-imports-work-in-rsc/)&#xD;\r\n* [React Frameworks and Server-Side Features: Beyond Client-Side Rendering](https://certificates.dev/blog/react-frameworks-and-server-side-features-beyond-client-side-rendering)&#xD;\r\n&#xD;\r\n### RSC 보안 취약점&#xD;\r\n&#xD;\r\nFlight Protocol 역직렬화 과정의 원격 코드 실행 취약점(CVE-2025-55182)입니다.&#xD;\r\n&#xD;\r\n* [Critical Security Vulnerability in React Server Components](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components)&#xD;\r\n* [React2Shell Security Bulletin](https://vercel.com/kb/bulletin/react2shell)&#xD;\r\n* [Understanding the RCE Flaw in React Server Functions](https://gist.github.com/sriram-palanisamy-hat/d207174ada2fa052ad44439f22a65c7e)&#xD;\r\n&#xD;\r\n### 생태계 변화&#xD;\r\n&#xD;\r\nCRA 종료와 styled-components 유지보수 모드 전환입니다.&#xD;\r\n&#xD;\r\n* [create-react-app is a zombie application](https://www.clientserver.dev/p/create-react-app-is-a-zombie-application)&#xD;\r\n* [Cut styled-components into pieces: This is our last resort](https://www.sanity.io/blog/cut-styled-components-into-pieces-this-is-our-last-resort)&#xD;\r\n&#xD;\r\n## 조용했던 React Compiler의 시간&#xD;\r\n&#xD;\r\n작년 이맘때쯤에도 React Compiler를 소개했었는데요. 떠들썩했던 2024년의 분위기와 달리 RC를 거쳐 조용히 React Compiler v1.0.0이 릴리스되었고, 이를 적용하기 위한 점진적 도입 방법에 대한 글이 올라왔습니다. 간간이 성능 개선 사례와 React Compiler를 다루는 아티클이 있었습니다.&#xD;\r\n&#xD;\r\n### 릴리스와 도입 가이드&#xD;\r\n&#xD;\r\nRC부터 v1.0.0까지의 릴리스와 점진적 도입 방법입니다.&#xD;\r\n&#xD;\r\n* [React Compiler RC](https://react.dev/blog/2025/04/21/react-compiler-rc)&#xD;\r\n* [React Compiler v1.0.0](https://www.npmjs.com/package/babel-plugin-react-compiler/v/1.0.0)&#xD;\r\n* [Incremental Adoption](https://react.dev/learn/react-compiler/incremental-adoption)&#xD;\r\n&#xD;\r\n### 실전 적용 사례&#xD;\r\n&#xD;\r\n프로덕션 환경 도입 경험과 상태 관리 라이브러리와의 관계입니다.&#xD;\r\n&#xD;\r\n* [Adopting the compiler at wakelet.com in production](https://github.com/reactwg/react-compiler/discussions/52)&#xD;\r\n* [Thoughts on state management libraries in the react compiler era](https://blog.axlight.com/posts/thoughts-on-state-management-libraries-in-the-react-compiler-era/)&#xD;\r\n&#xD;\r\n### 트러블슈팅과 내부 모델&#xD;\r\n&#xD;\r\nCompiler 관련 트러블슈팅과 Compiler에서 값의 변이와 별칭 관계를 추론하는 모델을 설명합니다.&#xD;\r\n&#xD;\r\n* [use no memo](https://react.dev/reference/react-compiler/directives/use-no-memo)&#xD;\r\n* [React Compiler’s Silent Failures (And How to Fix Them)](https://acusti.ca/blog/2025/12/16/react-compiler-silent-failures-and-how-to-fix-them/)&#xD;\r\n* [The Mutability \\&amp; Aliasing Model](https://github.com/facebook/react/blob/156b7a96f5669470182ad226306184576d6f150f/compiler/packages/babel-plugin-react-compiler/src/Inference/MUTABILITY_ALIASING_MODEL.md)&#xD;\r\n&#xD;\r\n## Next.js의 보안 이슈와 복잡성&#xD;\r\n&#xD;\r\n어느샌가 프론트엔드는 브라우저를 넘어 서버 영역에 발을 들였습니다. 웹 성능 향상을 위한 기능 개선이 이어졌고, 서버 영역 진출만큼 보안 사고도 발생했습니다. 이 흐름의 중심에 Next.js가 있습니다.&#xD;\r\n&#xD;\r\n기능이 추가될수록 복잡성도 함께 올라갔고, 많은 개발자가 피로감을 호소한 한 해였습니다. 대안으로 TanStack Start가 자주 언급됐고, Next.js를 떠나는 후기는 어느 순간 메모조차 하지 않을 만큼 많았습니다.&#xD;\r\n&#xD;\r\n보안 이슈도 빼놓을 수 없습니다. Next.js는 꽤 넓은 버전 범위에 걸쳐 미들웨어 인증 검사를 헤더만으로 우회할 수 있는 취약점이 있었습니다. 클라이언트 요청과 내부 SubRequest를 구분하기 위해 사용한 비공식 헤더가 문제였는데, 이를 악용하면 전혀 관련 없는 경로에 영향을 줄 수 있었습니다. Vercel에서 호스팅된 앱은 자체적으로 방어하고 있었다는 점에서 의문이 들기도 했습니다.&#xD;\r\n&#xD;\r\n일부 개발자들은 타 호스팅 업체들이 Next.js의 모든 기능을 지원하는 데 어려움을 겪고 있다고 지적했습니다. Next.js가 공식 어댑터를 제공하지 않는 점, 보안 취약점 대응에 소극적이었던 점도 비판의 대상이 됐습니다.&#xD;\r\n&#xD;\r\n그럼에도 Next.js는 Turbopack, React Compiler, PPR 등을 탑재한 v16을 릴리스하며 업데이트를 이어가고 있고 여전히 긍정적인 시선도 존재합니다.&#xD;\r\n&#xD;\r\n### 보안 취약점&#xD;\r\n&#xD;\r\n미들웨어 인증 우회 취약점입니다.&#xD;\r\n&#xD;\r\n* [Next.js and the corrupt middleware: the authorizing artifact](https://zhero-web-sec.github.io/research-and-things/nextjs-and-the-corrupt-middleware)&#xD;\r\n* [CVE-2025-29927: Authorization Bypass in Next.js Middleware](https://github.com/advisories/GHSA-f82v-jwr5-mffw)&#xD;\r\n&#xD;\r\n### 셀프 호스팅과 배포&#xD;\r\n&#xD;\r\nVercel 외 환경에서의 Next.js 운영과 셀프 호스팅 가이드입니다.&#xD;\r\n&#xD;\r\n* [Deploying a Next.js App to Production in any server](https://www.saybackend.com/blog/04-deploy-nextjs-to-production-without-vercel)&#xD;\r\n* [How we run Next.js today - and what should change](https://www.netlify.com/blog/how-we-run-nextjs/)&#xD;\r\n* [The Complete Guide to Self-Hosting Next.js at Scale](https://dlhck.com/thoughts/the-complete-guide-to-self-hosting-nextjs-at-scale/)&#xD;\r\n&#xD;\r\n### Next.js 이탈 사례&#xD;\r\n&#xD;\r\n다른 프레임워크로 전환한 팀들의 경험담입니다.&#xD;\r\n&#xD;\r\n* [Why we moved off next.js](https://documenso.com/blog/why-we-moved-off-next-js)&#xD;\r\n* [We migrated our site to Eleventy and increased performance by 24%](https://etch.co/blog/we-migrated-our-site-to-eleventy-and-increased-performance-by-24-percent/)&#xD;\r\n* [Why we ditched Next.js and never looked back](https://northflank.com/blog/why-we-ditched-next-js-and-never-looked-back)&#xD;\r\n&#xD;\r\n### Next.js 비판과 대안&#xD;\r\n&#xD;\r\n구조적 문제와 도입 전 고려 사항과 대안으로 떠오르는 TanStack Start 관련 내용입니다.&#xD;\r\n&#xD;\r\n* [You don't need Next.js](https://www.comfydeploy.com/blog/you-dont-need-nextjs)&#xD;\r\n* [You should know this before choosing Next.js](https://eduardoboucas.com/posts/2025-03-25-you-should-know-this-before-choosing-nextjs/)&#xD;\r\n* [Why Next.js Falls Short on Software Engineering](https://blog.webf.zone/why-next-js-falls-short-on-software-engineering-d3575614bd08)&#xD;\r\n* [Architecting with Constraints: A Pragmatic Guide](https://www.lorenstew.art/blog/always-architect-with-contraints/)&#xD;\r\n* [Next.js vs Tanstack](https://www.kylegill.com/essays/next-vs-tanstack/)&#xD;\r\n* [TanStack Start: New competitor to Next.js](https://ondrejvelisek.github.io/tanstack-start-new-competitor-to-nextjs/)&#xD;\r\n* [Why developers are leaving Next.js for TanStack Start, and loving it](https://appwrite.io/blog/post/why-developers-leaving-nextjs-tanstack-start)&#xD;\r\n&#xD;\r\n### 긍정적 전말과 릴리스&#xD;\r\n&#xD;\r\nNext.js의 미래에 대한 긍정적 시각과 렌더링 방식에 대한 이해입니다.&#xD;\r\n&#xD;\r\n* [I like the future of Next.js](https://tigerabrodi.blog/i-like-the-future-of-nextjs)&#xD;\r\n* [How to understand the concepts of Next.js such as CSR , SSR, SSG, ISR, RSC, SPA, and Streaming SSR?](https://dev.to/nextjser/how-to-understand-the-concepts-of-nextjs-such-as-csr-ssr-ssg-isr-rsc-spa-and-streaming-ssr-pl3)&#xD;\r\n&#xD;\r\n## npm 보안 위기의 해&#xD;\r\n&#xD;\r\n2025년은 보안 사고가 끊이지 않았습니다. 공급망 공격을 비롯한 여러 보안 취약점 등이 있었습니다. 다행히 최근 주요 플랫폼들이 발빠르게 대응하며 보안 체계를 갖춰가고 있습니다. &#xD;\r\n&#xD;\r\n### 개발자 계정 탈취로 인한 공급망 공격&#xD;\r\n&#xD;\r\n유명 라이브러리의 개발자들이 피싱으로 계정이 탈취되었고 이에 따라 오염된 패키지가 배포되는 사건들이 있었습니다.&#xD;\r\n&#xD;\r\n* [npm Author Qix Compromised via Phishing Email in Major Supply Chain Attack](https://socket.dev/blog/npm-author-qix-compromised-in-major-supply-chain-attack)&#xD;\r\n* [npm debug and chalk packages compromised](https://www.aikido.dev/blog/npm-debug-and-chalk-packages-compromised)&#xD;\r\n* [Version 5.6.1 published to npm is compromised (RESOLVED)](https://github.com/chalk/chalk/issues/656)&#xD;\r\n* [infowski - hackerspace.pl](https://social.hackerspace.pl/@informatic/115168929981581855)&#xD;\r\n* [DuckDB npm Account Compromised in Continuing Supply Chain Attack](https://socket.dev/blog/duckdb-npm-account-compromised-in-continuing-supply-chain-attack)&#xD;\r\n* [DuckDB NPM packages 1.3.3 and 1.29.2 compromised with malware](https://github.com/duckdb/duckdb-node/security/advisories/GHSA-w62p-hx95-gf2c)&#xD;\r\n* [eslint-config-prettier Compromised: How npm Package with 30 Million Downloads Spread Malware](https://safedep.io/eslint-config-prettier-major-npm-supply-chain-hack/)&#xD;\r\n* [Popular npm linter packages hijacked via phishing to drop malware](https://www.bleepingcomputer.com/news/security/popular-npm-linter-packages-hijacked-via-phishing-to-drop-malware/)&#xD;\r\n* [npm Phishing Email Targets Developers with Typosquatted Domain](https://socket.dev/blog/npm-phishing-email-targets-developers-with-typosquatted-domain)&#xD;\r\n* [Josh Junon - bluesky](https://bsky.app/profile/bad-at-computer.bsky.social/post/3lydioq5swk2y)&#xD;\r\n* [JounQin - X](https://x.com/JounQin/status/1946297662069993690)&#xD;\r\n* [npm ‘is’ Package Hijacked in Expanding Supply Chain Attack](https://socket.dev/blog/npm-is-package-hijacked-in-expanding-supply-chain-attack)&#xD;\r\n    [](https://socket.dev/blog/tinycolor-supply-chain-attack-affects-40-packages)&#xD;\r\n* [Popular Tinycolor npm Package Compromised in Supply Chain Attack Affecting 40+ Packages](https://socket.dev/blog/tinycolor-supply-chain-attack-affects-40-packages)&#xD;\r\n* [ctrl/tinycolor and 40+ NPM Packages Compromised](https://www.stepsecurity.io/blog/ctrl-tinycolor-and-40-npm-packages-compromised)&#xD;\r\n&#xD;\r\n&#xD;\r\n### Shai-Hulud 공격&#xD;\r\n&#xD;\r\nShai-Hulud 대규모 공급망 공격 분석입니다.&#xD;\r\n&#xD;\r\n* [Shai-Hulud Returns: Over 1K NPM Packages and 27K+ Github Repos infected via Fake Bun Runtime Within Hours](https://helixguard.ai/blog/malicious-sha1hulud-2025-11-24)&#xD;\r\n* [The Shai-Hulud 2.0 npm worm: analysis, and what you need to know](https://securitylabs.datadoghq.com/articles/shai-hulud-2.0-npm-worm/)&#xD;\r\n* [NPM Security Best Practices: How to Protect Your Packages After the 2025 Shai Hulud Attack](https://snyk.io/fr/articles/npm-security-best-practices-shai-hulud-attack/)&#xD;\r\n* [GitLab discovers widespread npm supply chain attack](https://about.gitlab.com/blog/gitlab-discovers-widespread-npm-supply-chain-attack/)&#xD;\r\n&#xD;\r\n### 플랫폼 보안 강화&#xD;\r\n&#xD;\r\nnpm과 Github의 인증 체계 개선과 보안 기능 업데이트입니다.&#xD;\r\n&#xD;\r\n* [npm classic tokens revoked, session-based auth and CLI token management now available](https://github.blog/changelog/2025-12-09-npm-classic-tokens-revoked-session-based-auth-and-cli-token-management-now-available/)&#xD;\r\n* [npm trusted publishing with OIDC is generally available](https://github.blog/changelog/2025-07-31-npm-trusted-publishing-with-oidc-is-generally-available/)&#xD;\r\n* [How We're Protecting Our Newsroom from npm Supply Chain Attacks](https://pnpm.io/blog/2025/12/05/newsroom-npm-supply-chain-security)&#xD;\r\n&#xD;\r\n### 도구&#xD;\r\n&#xD;\r\n보안 강화를 위한 다양한 라이브러리입니다.&#xD;\r\n&#xD;\r\n* [safe-npm](https://github.com/kevinslin/safe-npm)&#xD;\r\n* [npq](https://github.com/lirantal/npq)&#xD;\r\n* [reproduce](https://github.com/vltpkg/reproduce)&#xD;\r\n* [exposedbydefault](https://github.com/neberej/exposedbydefault)&#xD;\r\n&#xD;\r\n## 빌드 도구의 Rust 전환&#xD;\r\n&#xD;\r\n작년에 이어 JavaScript 툴체인의 Rust 재작성이 가속화되고 있습니다. Rust 전환 시 기존 대비 10-100배의 성능 향상이 가능하기 때문에, 복잡해진 프론트엔드 생태계에서 이 흐름은 이제 거스르기 어려워 보입니다.&#xD;\r\n&#xD;\r\n가장 두드러진 성과를 내는 곳은 VoidZero로 보입니다. Rolldown, Oxc, Oxfmt, Oxlint 등의 프로젝트를 운영하고 있습니다. 이 외에도 ByteDance의 Rsbuild/Rspack, 통합 툴체인 Deno, Vercel의 Turbopack, Meta의 Buck2 등이 있습니다.&#xD;\r\n&#xD;\r\n개인적인 경험도 있습니다. NCUI가 실제 서비스에서 어떻게 사용되는지 추적하기 위해 만든 사이드 프로젝트에서 JavaScript 기반 분석 도구를 SWC 기반으로 재개발했는데 처리 속도가 50배 이상 빨라졌습니다.&#xD;\r\n&#xD;\r\nVite는 지속적인 업데이트 끝에 Rolldown을 탑재한 v8 메이저 업데이트를 앞두고 있습니다. 아직 Webpack을 사용 중이라면 마이그레이션을 검토해 볼 만합니다.&#xD;\r\n&#xD;\r\n### Voidzero의 소식&#xD;\r\n&#xD;\r\nVoidzero 진영의 Rolldown 번들러 소식과 Oxlint 관련 내용입니다.&#xD;\r\n&#xD;\r\n* [How Rolldown Works: Module Loading, Dependency Graphs, and Optimization Explained](https://www.atriiy.dev/blog/rolldown-module-loader-and-dependency-graph/)&#xD;\r\n* [Rolldown 1.0 Beta](https://github.com/rolldown/rolldown/releases/tag/v1.0.0-beta.1)&#xD;\r\n* [Vite 8 Beta: The Rolldown-powered Vite](https://vite.dev/blog/announcing-vite8-beta)&#xD;\r\n* [tsdown](https://github.com/rolldown/tsdown)&#xD;\r\n* [Oxlint v1](https://oxc.rs/blog/2025-06-10-oxlint-stable.html)&#xD;\r\n* [Faster Type-Aware Lint Rules: Biome vs. Oxlint](https://www.solberg.is/fast-type-aware-linting/)&#xD;\r\n*  [Vite just passed Webpack in weekly npm downloads](https://x.com/youyuxi/status/1950234261573038444)&#xD;\r\n&#xD;\r\n### 번들러 비교와 전망&#xD;\r\n&#xD;\r\n* [The JavaScript Bundler Grand Prix](https://redmonk.com/kholterhoff/2025/12/16/javascript-bundler-grand-prix/)&#xD;\r\n* [Bundler Explorer](https://bundler.sxzz.dev/)&#xD;\r\n* [Speeding up the JavaScript ecosystem - Rust and JavaScript plugins](https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-11/)&#xD;\r\n&#xD;\r\n## 새로운 HTML/CSS 네이티브 기능의 폭발&#xD;\r\n&#xD;\r\nBaseline, Interop 활동에 힘입어 HTML/CSS 네이티브 기능이 쏟아졌습니다. 사실 이런 주제의 아티클은 꾸준히 올라오지만, 최신 브라우저만을 사용자 환경으로 전제할 수 없어 깊이 들여다보지 못한 경우가 많았습니다. 그래도 관심을 놓지 않고 있다가 충분히 사용 가능한 시점에 네이티브로 전환하면 제품 품질이 확실히 좋아질 거라 생각합니다.&#xD;\r\n&#xD;\r\n### 네이티브 UI 컴포넌트&#xD;\r\n&#xD;\r\n기존에 JavaScript로 구현하던 Tooltip, Popover, Dropdown 같은 UI 패턴을 네이티브로 지원합니다.&#xD;\r\n&#xD;\r\n* [The Basics of Anchor Positioning](https://ishadeed.com/article/anchor-positioning/)&#xD;\r\n* [Better anchor positioning with position-area](https://www.oddbird.net/2025/02/25/anchor-position-area/)&#xD;\r\n* [Follow-the-leader pattern with CSS anchor positioning](https://una.im/follow-the-anchor/)&#xD;\r\n* [The popover api is now baseline newly available](https://web.dev/blog/popover-baseline?hl=en)&#xD;\r\n* [What is popover=hint?](https://una.im/popover-hint/)&#xD;\r\n* [The `&lt;select&gt;` element can now be customized with CSS](https://developer.chrome.com/blog/a-customizable-select?hl=en)&#xD;\r\n* [Updates to the customizable select API](https://una.im/select-updates/)&#xD;\r\n&#xD;\r\n### CSS 조건문&#xD;\r\n&#xD;\r\nif() 함수로 CSS 속성 값 내에서 인라인 조건부 로직을 구현합니다.&#xD;\r\n&#xD;\r\n* [CSS conditionals with the new if() function](https://developer.chrome.com/blog/if-article/)&#xD;\r\n* [Introduction to CSS if Statements and Conditional Logic](https://markodenic.com/introduction-to-css-if-statements-and-conditional-logic/)&#xD;\r\n* [CSS custom functions are coming ... and they are going to be a game changer](https://www.bram.us/2025/02/09/css-custom-functions-teaser/)&#xD;\r\n&#xD;\r\n### 레이아웃&#xD;\r\n&#xD;\r\nSubgrid와 반응형 디자인 기능입니다. 참고로 작년 주제였던 Masonry 레이아웃은 여전히 진행 중입니다.&#xD;\r\n&#xD;\r\n* [Brand New Layouts with CSS Subgrid](https://www.joshwcomeau.com/css/subgrid/)&#xD;\r\n* [Taking RWD(Responsive Web Design) to the extreme](https://www.smashingmagazine.com/2025/02/taking-rwd-to-the-extreme/)&#xD;\r\n* [How much do you really know about media queries?](https://frontendmasters.com/blog/learn-media-queries/)&#xD;\r\n* [Grid Lanes Layout Model](https://www.w3.org/TR/css-grid-3/#grid-lanes-model)&#xD;\r\n* [MDN - Masonry Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Grid_layout)&#xD;\r\n&#xD;\r\n### 색상과 스타일링&#xD;\r\n&#xD;\r\n* [CSS Custom Properties vs. Sass Variables: A Pragmatic Guide](https://www.alwaystwisted.com/articles/css-vs-sass)&#xD;\r\n* [A pragmatic guide to modern CSS colours - part one](https://piccalil.li/blog/a-pragmatic-guide-to-modern-css-colours-part-one/)&#xD;\r\n* [Making Context-Aware Components: How CSS inherit() Could Simplify Design Systems](https://www.alwaystwisted.com/articles/making-context-aware-components)&#xD;\r\n&#xD;\r\n### 새로운 Web API&#xD;\r\n&#xD;\r\nTemporal, Clipboard, Sanitizer, moveBefore 등 신규 브라우저 API와 제안입니다.&#xD;\r\n&#xD;\r\n* [The Clipboard API: How Did We Get Here?](https://cekrem.github.io/posts/clipboard-api-how-hard-can-it-be/)&#xD;\r\n* [Temporal API is coming](https://developer.mozilla.org/en-US/blog/javascript-temporal-is-coming/)&#xD;\r\n* [Why the Sanitizer API is just setHTML()](https://frederikbraun.de/why-sethtml.html)&#xD;\r\n* [Move elements around the DOM while preserving their state with moveBefore](https://www.bram.us/2025/01/16/move-elements-around-the-dom-while-preserving-their-state-with-movebefore/)&#xD;\r\n* [Making complex web apps faster](https://blogs.windows.com/msedgedev/2025/12/09/making-complex-web-apps-faster/)&#xD;\r\n&#xD;\r\n### 종합 가이드&#xD;\r\n&#xD;\r\nHTML/CSS 신기능 전반을 다룹니다.&#xD;\r\n&#xD;\r\n* [Relatively new things you should know about HTML heading into 2025](https://frontendmasters.com/blog/bone-up-html-2025/)&#xD;\r\n* [Perfecting Baseline](https://piccalil.li/blog/perfecting-baseline/)&#xD;\r\n* ▶️ [25 new \\&amp; rad feature of CSS](https://www.youtube.com/watch?v=QW6GECIzvsw)&#xD;\r\n* [CSS Wrapped 2025](https://chrome.dev/css-wrapped-2025/)&#xD;\r\n&#xD;\r\n## AI 트렌드&#xD;\r\n&#xD;\r\n프론트엔드를 떠나 IT 산업 전반을 돌아보면, 2025년은 단연 LLM/AI가 가장 뜨거운 키워드였습니다. 상반기만 해도 MCP 프로토콜 소개나 LLM 기반 코드 개발 후기 정도가 화제였는데, 불과 몇 달 만에 양상이 달라졌습니다. Angular, Svelte, Chrome DevTools 등 주요 프레임워크가 공식 MCP 서버를 출시했고, Spotify와 Amazon 팀의 실전 도입 사례가 속속 공개되기 시작했습니다. 바이브 코딩, 컨텍스트 엔지니어링, 스펙 주도 개발 같은 방법론이 등장했고, 최근에는 Claude에서 Skills라는 도구까지 나왔습니다.&#xD;\r\n&#xD;\r\n자연스럽게 프론트엔드 영역의 생산성 개선에 관심이 쏠렸습니다. 하지만 LLM은 복잡한 인터랙션 처리에서 한계를 드러냈고, 기대만큼의 임팩트를 보여주진 못했습니다. 이 시기에 AI의 한계를 지적하는 글, 코드 리뷰의 중요성을 강조하는 글, 엔지니어의 책임을 다시 정의하는 글이 쏟아졌습니다. 미래를 단언할 수는 없지만, 현 시점에서는 개발자의 판단력이 여전히 핵심이라는 데 대체로 의견이 모이는 분위기입니다.&#xD;\r\n&#xD;\r\n그럼에도 프론트엔드와 AI의 접점은 계속 넓어지고 있습니다. LLM이 웹 브라우저를 직접 제어하고, React 컴포넌트를 해석하는 도구들이 등장했습니다. Figma는 빠른 속도로 AI 기능을 도입하고 있고, 디자인 토큰을 AI가 읽을 수 있는 구조로 재설계하자는 제안도 나오고 있습니다.&#xD;\r\n&#xD;\r\n2025년 한 해를 돌아보면 솔직히 동네 축구 같다는 생각도 듭니다. '이게 좋다' 하면 모두가 몰려가고, '저게 정답이다' 하면 또 그쪽으로 쏠리는 흐름이 반복됐습니다. 그 와중에 인상 깊었던 LLM 사용 사례와 아티클, 도구를 정리해 공유합니다.&#xD;\r\n&#xD;\r\n### AI 코딩의 한계와 책임&#xD;\r\n&#xD;\r\nLLM 기반 개발의 한계점과 개발자 책임에 대한 논의입니다.&#xD;\r\n&#xD;\r\n* [Can LLMs write better code if you keep asking them to \"write better code?\"](https://minimaxir.com/2025/01/write-better-code/)&#xD;\r\n* [Why you shouldn't use AI to write documentation](https://zeroheight.com/blog/why-you-shouldnt-use-ai-to-write-documentation/)&#xD;\r\n* [Why Your AI Coding Assistant Keeps Doing It Wrong, and How To Fix It](https://blog.thepete.net/blog/2025/05/22/why-your-ai-coding-assistant-keeps-doing-it-wrong-and-how-to-fix-it/)&#xD;\r\n* [Your job is to deliver code you have proven to work](https://simonwillison.net/2025/Dec/18/code-proven-to-work/)&#xD;\r\n* [dead framework theory](https://aifoc.us/dead-framework-theory/)&#xD;\r\n* [How to Fix Any Bug](https://overreacted.io/how-to-fix-any-bug/)&#xD;\r\n&#xD;\r\n### 기업 도입 사례&#xD;\r\n&#xD;\r\nSpotify, Airbnb 등 대규모 조직의 AI 도입 경험입니다.&#xD;\r\n&#xD;\r\n* [1,500+ PRs Later: Spotify’s Journey with Our Background Coding Agent (Part 1)](https://engineering.atspotify.com/2025/11/spotifys-background-coding-agent-part-1)&#xD;\r\n* [The New Calculus of AI-based Coding](https://blog.joemag.dev/2025/10/the-new-calculus-of-ai-based-coding.html)&#xD;\r\n* [Accelerating Large-Scale Test Migration with LLMs](https://medium.com/airbnb-engineering/accelerating-large-scale-test-migration-with-llms-9565c208023b)&#xD;\r\n&#xD;\r\n### MCP와 컨텍스트 엔지니어링&#xD;\r\n&#xD;\r\nModel Context Protocol과 효과적인 AI 활용을 위한 컨텍스트 설계입니다.&#xD;\r\n&#xD;\r\n* [MCP explained without hype of fluff](https://blog.nilenso.com/blog/2025/05/12/mcp-explained-without-hype-or-fluff)&#xD;\r\n* [Chrome DevTools MCP Server](https://developer.chrome.com/blog/chrome-devtools-mcp)&#xD;\r\n* [Getting AI to Work in Complex Codebases](https://github.com/humanlayer/advanced-context-engineering-for-coding-agents/blob/main/ace-fca.md)&#xD;\r\n* [Minification isn't obfuscation - Claude Code proves it](https://martinalderson.com/posts/minification-isnt-obfuscation-claude-code-proves-it/)&#xD;\r\n&#xD;\r\n### AI시대의 개발 방법론&#xD;\r\n&#xD;\r\nAPI 설계, 문서화, 추상화 등 AI와 함께하는 개발 방법론입니다.&#xD;\r\n&#xD;\r\n* [How to Design APIs for an AI World ](https://refactoring.fm/p/how-to-design-apis-for-an-ai-world)&#xD;\r\n* [Writing documentation for AI: best practices](https://docs.kapa.ai/improving/writing-best-practices/)&#xD;\r\n* [The New Calculus of AI-based Coding](https://blog.joemag.dev/2025/10/the-new-calculus-of-ai-based-coding.html)&#xD;\r\n* [Conversation: LLMs and Building Abstractions](https://martinfowler.com/articles/convo-llm-abstractions.html)&#xD;\r\n* [Attention Is the New Big-O](https://alexchesser.medium.com/attention-is-the-new-big-o-9c68e1ae9b27/)&#xD;\r\n&#xD;\r\n### 유용한 도구&#xD;\r\n&#xD;\r\nAI 개발에 활용할 수 있는 도구입니다.&#xD;\r\n&#xD;\r\n* [repomix](https://github.com/yamadashy/repomix) - 전체 Repository를 AI 친화적인 단일 파일로 압축&#xD;\r\n* [repo2txt](https://github.com/abinthomasonline/repo2txt) - GitHub Repository를 단일 텍스트로 변환, GUI 기반으로 파일 선택 가능&#xD;\r\n* [ai-digest](https://github.com/khromov/ai-digest) - 코드베이스를 하나의 마크다운 파일로 생성&#xD;\r\n* [claude-flow](https://github.com/ruvnet/claude-flow) - Claude 기반 AI 에이전트를 여러 개 연결해 협업, 복잡한 작업을 단계별 워크플로우로 자동화&#xD;\r\n* [agent-rules](https://github.com/steipete/agent-rules) - Cursor, Claude Code 같은 AI 코드 어시스턴트에게 일관된 행동 지침을 적용하는 규칙 템플릿 모음&#xD;\r\n* [Conductor](https://conductor.build/) - Claude Code를 여러 개 동시에 실행하며 관리하는 도구&#xD;\r\n* [Terragon](https://www.terragonlabs.com/) - Claude Code, OpenAI Codex 등 AI 코딩 에이전트를 클라우드에서 병렬 실행&#xD;\r\n* [react-grab](https://github.com/aidenybai/react-grab) - 페이지의 모든 요소를 선택해 AI 코딩 에이전트에게 컨텍스트로 전달, 단일 스크립트 태그로 설치&#xD;\r\n* [MCP Registry](https://github.com/mcp) - GitHub에서 다양한 MCP 서버를 모아둔 레지스트리&#xD;\r\n* [streamdown](https://streamdown.ai/) - AI Chat 서비스처럼 마크다운 스트리밍 렌더링 지원&#xD;\r\n* [lean-spec](https://github.com/codervisor/lean-spec) - 경량 SDD(Spec-Driven Development) 프레임워크&#xD;\r\n&#xD;\r\n## 그 외 분야별 소식&#xD;\r\n&#xD;\r\n### JavaScript/TypeScript&#xD;\r\n&#xD;\r\n2025년도 JavaScript와 TypeScript 생태계는 활발하게 움직였습니다. TypeScript 7의 Go 포팅 소식, 다양한 언어 패턴과 보안 이슈, 그리고 JSDoc을 활용한 타입 안정성 확보 방법 등 주요 소식을 정리했습니다.&#xD;\r\n&#xD;\r\n#### 언어 기능과 패턴&#xD;\r\n&#xD;\r\nJavaScript의 다양한 언어 기능과 활용 패턴입니다.&#xD;\r\n&#xD;\r\n* [There are a lot of ways to break up long tasks in JavaScript](https://macarthur.me/posts/long-tasks/)&#xD;\r\n* [Breaking Up with Long Tasks or: how I learned to group loops and wield the yield](https://calendar.perfplanet.com/2024/breaking-up-with-long-tasks-or-how-i-learned-to-group-loops-and-wield-the-yield/)&#xD;\r\n* [Category Theory for JavaScript/TypeScript Developers](https://ibrahimcesar.cloud/blog/category-theory-for-javascript-typescript-developers/)&#xD;\r\n* [Say bye with JavaScript Beacon](https://hemath.dev/blog/say-bye-with-javascript-beacon/)&#xD;\r\n* [Using await at the top level in ES Modules](https://allthingssmitty.com/2025/06/16/using-await-at-the-top-level-in-es-modules/)&#xD;\r\n* [30 Years of JavaScript: 10 Milestones That Changed the Web](https://thenewstack.io/30-years-of-javascript-10-milestones-that-changed-the-web/)&#xD;\r\n* [How to Control the Number of Concurrent Promises in JavaScript](https://dev.to/zacharylee/how-to-control-the-number-of-concurrent-promises-in-javascript-3mg8)&#xD;\r\n* [Deeply immutable data structures](https://sanjeettiwari.com/notes/deeply-immutable-structures)&#xD;\r\n* [JavaScript's Promise.race and Promise.all Are Not \"Fair\"](https://v5.chriskrycho.com/notes/javascript-promise-race-and-promise-all-are-not-fair/)&#xD;\r\n* [Sustainable simplicity](https://frontendatscale.com/issues/42)&#xD;\r\n&#xD;\r\n#### TypeScript의 활용&#xD;\r\n&#xD;\r\nTypeScript의 고급 기능과 타입 시스템 활용법입니다.&#xD;\r\n&#xD;\r\n* [TypeScript vs Zod: Clearing up validation confusion](https://blog.logrocket.com/when-use-zod-typescript-both-developers-guide)&#xD;\r\n* [6 Advanced TypeScript Tricks](https://sinja.io/blog/advanced-typescript)&#xD;\r\n* [The Multi-Repository TypeScript Problem](https://www.carrick.tools/blog/the-multi-repository-typescript-problem/)&#xD;\r\n&#xD;\r\n#### JSDoc 활용&#xD;\r\n&#xD;\r\nTypeScript 없이 JSDoc으로 타입 안정성을 확보하는 방법입니다.&#xD;\r\n&#xD;\r\n* [The Nuances of JavaScript Typing using JSDoc](https://thathtml.blog/2025/12/nuances-of-typing-with-jsdoc/)&#xD;\r\n* [How JSDoc Saved My Dev Workflow](https://spin.atomicobject.com/how-jsdoc-saved-my-dev-workflow/)&#xD;\r\n&#xD;\r\n#### TypeScript 생태계&#xD;\r\n&#xD;\r\nTypeScript의 발전 방향과 생태계 변화입니다.&#xD;\r\n&#xD;\r\n* [TypeScript’s rise in the AI era: Insights from Lead Architect, Anders Hejlsberg](https://github.blog/developer-skills/programming-languages-and-frameworks/typescripts-rise-in-the-ai-era-insights-from-lead-architect-anders-hejlsberg/)&#xD;\r\n* [The Inner Workings of JavaScript Source Maps](https://www.polarsignals.com/blog/posts/2025/11/04/javascript-source-maps-internals)&#xD;\r\n* [TypeScript is going Go: Why it's the pragmatic choice](https://johnnyreilly.com/typescript-go-pragmatic-choice)&#xD;\r\n&#xD;\r\n#### 보안&#xD;\r\n&#xD;\r\nJavaScript 시큐어 코딩 관련 내용입니다.&#xD;\r\n&#xD;\r\n* [How to consume APIs in React using Fetch and Async/Await](https://blog.codeminer42.com/how-to-consume-apis-in-react-using-fetch-and-async-await/)&#xD;\r\n&#xD;\r\n### 프레임워크&#xD;\r\n&#xD;\r\n앞서 언급한 React 외 주요 프레임워크들의 2025년 소식을 정리했습니다. Remix의 React 결별 선언, Svelte의 성능 입증, Angular의 Zoneless 안정화 등 흥미로운 변화가 많았습니다.&#xD;\r\n&#xD;\r\n#### Remix&#xD;\r\n&#xD;\r\nReact와 결별하고 웹 표준 중심으로 재구상된 Remix v3 소식입니다.&#xD;\r\n&#xD;\r\n* [Wake Up! Remix](https://remix.run/blog/wake-up-remix)&#xD;\r\n* [Remix Jam 2025](https://remix.run/jam/2025)&#xD;\r\n* [React and Remix Choose Different Futures](https://laconicwit.com/react-and-remix-choose-different-futures/)&#xD;\r\n* [Remix 3 and the End of React-Centric Architectures](https://thenewstack.io/remix-3-and-the-end-of-react-centric-architectures/)&#xD;\r\n* [Just JavaScript](https://pedrocattori.com/posts/just-javascript/)&#xD;\r\n*  [Remix v3 Preact 기반 계획 취소](https://x.com/mjackson/status/1955083457144762729)&#xD;\r\n* [Remixing Shopify's Admin](https://shopify.engineering/remixing-admin)&#xD;\r\n&#xD;\r\n#### Svelte&#xD;\r\n&#xD;\r\n개발자 만족도 1위, 성능 벤치마크에서도 가장 빠른 성능을 기록한 Svelte 소식입니다.&#xD;\r\n&#xD;\r\n* [What's new in Svelte: November 2025](https://svelte.dev/blog/whats-new-in-svelte-november-2025)&#xD;\r\n* [Svelte really is that fast](https://chuniversiteit.nl/papers/svelte-is-fast)&#xD;\r\n* [Why startups choose React (and when you shouldn't)](https://evilmartians.com/chronicles/why-startups-choose-react-and-when-you-should-not)&#xD;\r\n&#xD;\r\n#### Angular&#xD;\r\n&#xD;\r\nZoneless 안정화와 시그널 기반 반응성 API를 도입한 Angular 소식입니다.&#xD;\r\n&#xD;\r\n* [Angular Summer Update 2025](https://blog.angular.dev/angular-summer-update-2025-1987592a0b42)&#xD;\r\n* [Angular 2025 Strategy](https://blog.angular.dev/angular-2025-strategy-9ca333dfc334)&#xD;\r\n&#xD;\r\n#### Vue / Nuxt&#xD;\r\n&#xD;\r\nVercel의 Nuxt 인수와 Vue 생태계 현황입니다.&#xD;\r\n&#xD;\r\n* [State of Vue.js Report 2025](https://www.monterail.com/)&#xD;\r\n* [NuxtLabs joins Vercel](https://vercel.com/blog/nuxtlabs-joins-vercel)&#xD;\r\n* [How to build Microfrontends with Module Federation and Vue](https://alexop.dev/posts/how-to-build-microfrontends-with-module-federation-and-vue/)&#xD;\r\n&#xD;\r\n#### Astro&#xD;\r\n&#xD;\r\n클라이언트 JavaScript 최소화와 Content Collections 진화 소식입니다.&#xD;\r\n&#xD;\r\n* [What's new in Astro - January 2025](https://astro.build/blog/whats-new-january-2025/)&#xD;\r\n* [Live Content Collections: A Deep Dive](https://astro.build/blog/live-content-collections-deep-dive/)&#xD;\r\n* [Why use React?](https://adactio.com/journal/22265)&#xD;\r\n&#xD;\r\n#### htmx&#xD;\r\n&#xD;\r\n\"하위 호환성 없는 v3.0은 절대 출시하지 않겠다\"는 약속 때문에 v3를 건너뛰고 v4 출시한 htmx 소식입니다.&#xD;\r\n&#xD;\r\n* [htmx v4](https://htmx.org/essays/the-fetchening/)&#xD;\r\n&#xD;\r\n### 디자인 시스템&#xD;\r\n&#xD;\r\n2025년 디자인 시스템 생태계는 AI 시대를 맞아 큰 전환점을 맞이했습니다. Claude Skills와 Figma MCP 서버의 등장으로 디자인 시스템 팀이 AI를 활용해 마이그레이션 자동화, Storybook 스토리 생성, 토큰 검증 등 반복적인 작업을 자동화할 수 있게 되었고, 이에 따라 디자인 토큰을 AI가 올바르게 이해할 수 있도록 시맨틱 네이밍과 메타데이터를 추가하는 구조화가 새로운 과제로 언급되었습니다.&#xD;\r\n&#xD;\r\n컴포넌트 설계 철학에서는 합성이 하나의 패러다임으로 떠올랐습니다. Figma의 네이티브 슬롯 지원을 계기로 고정된 컴포넌트 대신 기본 컨테이너와 재사용 가능한 자식 요소를 분리해 제공하는 방식이 확산되었고, 다중 추상화 계층 접근법도 주목 받았습니다.&#xD;\r\n&#xD;\r\n디자인 토큰 영역에서는 DTCG가 18개월간 여러 가지 스펙 업데이트를 발표한 반면, 흥미롭게도 디자인 토큰이라는 용어를 처음 만든 Salesforce는 복잡해진 토큰 스펙 대신 CSS 커스텀 프로퍼티로 회귀했습니다. Figma 역시 토큰 대신 변수라는 용어를 선택하며, 업계가 토큰의 복잡성과 단순함 사이에서 균형점을 찾고 있음을 보여줍니다.&#xD;\r\n&#xD;\r\n#### 설계 철학과 전략&#xD;\r\n&#xD;\r\n디자인 시스템의 본질과 성공 전략에 대한 논의입니다.&#xD;\r\n&#xD;\r\n* [Beyond the Plateau of Sameness](https://yeseniaperezcruz.substack.com/p/beyond-the-plateau-of-sameness)&#xD;\r\n* [Bias in Design Systems](https://bencallahan.com/bias-in-design-systems)&#xD;\r\n* [The future of design systems is decentralized](https://uxdesign.cc/the-future-of-design-systems-is-decentralized-770db996442c)&#xD;\r\n* [The dumbest design system mistakes](https://learn.thedesignsystem.guide/p/the-dumbest-design-system-mistakes)&#xD;\r\n* [Design System Tactics](https://redesigningdesign.systems/tactics/all-tactics)&#xD;\r\n* [designtokens.fyi](https://designtokens.fyi/)&#xD;\r\n&#xD;\r\n#### 컴포넌트 설계&#xD;\r\n&#xD;\r\n슬롯, 컴포지션, 추상화 계층 등 컴포넌트 설계 패턴입니다.&#xD;\r\n&#xD;\r\n* [Slots in Design Systems](https://nathanacurtis.substack.com/p/slots-in-design-systems)&#xD;\r\n* [Using composability over inheritance to scale design systems](https://zeroheight.com/blog/using-composability-over-inheritance-to-scale-design-systems/)&#xD;\r\n* [Multiple Layers of Abstraction in Design Systems](https://engineering.atspotify.com/2023/05/multiple-layers-of-abstraction-in-design-systems/)&#xD;\r\n* [The power of relationships in design systems](https://learn.thedesignsystem.guide/p/the-power-of-relationships-in-design)&#xD;\r\n&#xD;\r\n#### 디자인 토큰&#xD;\r\n&#xD;\r\n토큰 스펙 진화와 실무 활용법입니다.&#xD;\r\n&#xD;\r\n* [What's new in the Design Tokens spec](https://zeroheight.com/blog/whats-new-in-the-design-tokens-spec/)&#xD;\r\n* [Design Token-Based UI Architecture](https://martinfowler.com/articles/design-token-based-ui-architecture.html)&#xD;\r\n* [A Design Token Workflow](https://www.alwaystwisted.com/articles/a-design-tokens-workflow-part-1)&#xD;\r\n* [Generating Utility Classes from Design Tokens](https://www.alwaystwisted.com/articles/a-design-tokens-workflow-part-13)&#xD;\r\n* [Avoiding Tokens](https://blog.damato.design/posts/avoiding-tokens/)&#xD;\r\n* [Introducing Design Tokens Language Server](https://bennypowers.dev/posts/introducing-design-tokens-language-server/)&#xD;\r\n&#xD;\r\n#### AI와 디자인 시스템&#xD;\r\n&#xD;\r\nAI 시대에 디자인 시스템을 활용하고 최적화하는 방법입니다.&#xD;\r\n&#xD;\r\n* [3 practical ways LLMs can support design systems teams today](https://zeroheight.com/blog/3-practical-ways-llms-can-support-design-systems-teams-today/)&#xD;\r\n* [Why your design system team need Claude Skills](https://learn.thedesignsystem.guide/p/why-your-design-system-team-need)&#xD;\r\n* [Design tokens that AI can actually read](https://learn.thedesignsystem.guide/p/design-tokens-that-ai-can-actually)&#xD;\r\n* [How to build patterns from your design system components with AI](https://learn.thedesignsystem.guide/p/how-to-build-patterns-from-your-design)&#xD;\r\n&#xD;\r\n#### 문서화와 운영&#xD;\r\n&#xD;\r\n디자인 시스템 문서화, 접근성 감사, 유지보수 전략 및 운영입니다.&#xD;\r\n&#xD;\r\n* [How to document your design system components](https://zeroheight.com/blog/how-to-document-your-design-system-components/)&#xD;\r\n* [When's the right time to start documenting your design system?](https://zeroheight.com/blog/whens-the-right-time-to-start-documenting-your-design-system/)&#xD;\r\n* [Storefront \\&amp; Warehouse](https://blog.damato.design/posts/storefront-warehouse/)&#xD;\r\n* [Design tokens aren't enough. ADR need a place](https://samiamdesigns.substack.com/p/design-tokens-arent-enough-architecture)&#xD;\r\n* [Retrofitting a Design System Into an Existing Product](https://medium.com/@anilpak35/retrofitting-a-design-system-into-an-existing-product-a9ebfe3d7d30)&#xD;\r\n&#xD;\r\n### 라이브러리&#xD;\r\n&#xD;\r\n개발 생산성을 높여주는 다양한 도구들이 등장했습니다. UI 관련 라이브러리, 프로젝트 분석, TypeScript 개발, 보안, 테스트까지 카테고리별로 정리했습니다.&#xD;\r\n&#xD;\r\n#### UI 컴포넌트&#xD;\r\n&#xD;\r\nshadcn/ui는 지속적으로 엄청난 확장을 거듭하며 가장 영향력 있는 생태계 중 하나가 되었고, 지속적으로 주목받던 Base UI가 v1을 릴리스했습니다.&#xD;\r\n&#xD;\r\n* [shadcn/ui](https://ui.shadcn.com/) - CLI 3.0, Monorepo 지원, 다양한 신규 컴포넌트&#xD;\r\n* [shadcn/ui.create](https://ui.shadcn.com/create) - GUI로 자신만의 shadcn/ui 구성&#xD;\r\n* [shadcn.io](https://www.shadcn.io/) - MIT 라이선스 무료 컴포넌트 커뮤니티 레지스트리&#xD;\r\n* [shadcn/ui Form documentation](https://ui.shadcn.com/docs/forms) - React Hook Form, TanStack Form 통합 가이드&#xD;\r\n* [themecn](https://themecn.dev/) - shadcn 기반 테마 생성기&#xD;\r\n* [formcn](https://formcn.dev/) - shadcn 기반 양식 생성기&#xD;\r\n* [base-ui v1.0](https://base-ui.com/) - Radix, Material UI, Floating UI 개발자들의 컴포넌트 재정의&#xD;\r\n* [Headless Tree](https://headless-tree.lukasbach.com/) - 트리 컴포넌트 라이브러리&#xD;\r\n&#xD;\r\n#### 프로젝트 분석&#xD;\r\n&#xD;\r\n코드베이스와 의존성을 분석하고 정리하는 도구들입니다.&#xD;\r\n&#xD;\r\n* [Knip](https://knip.dev/) - 불필요한 파일, 의존성, 내보내기 등을 JavaScript/TypeScript 프로젝트에서 추출&#xD;\r\n* [qnm](https://github.com/ranyitz/qnm) - node\\_modules 탐색 CLI, 퍼지 검색, 패키지 설치 이유 설명, 모노레포 지원&#xD;\r\n* [API Extractor](https://api-extractor.com/) - TypeScript 라이브러리 API 관리, 변경 감지, export 검증, .d.ts rollup 생성&#xD;\r\n* [sonda](https://github.com/filipsobol/sonda) - 소스맵 분석으로 트리쉐이킹/압축 후 실제 모듈 크기 시각화&#xD;\r\n&#xD;\r\n#### TypeScript 개발 도구&#xD;\r\n&#xD;\r\nTypeScript 개발 경험을 개선하는 도구들입니다.&#xD;\r\n&#xD;\r\n* [ts-migrating](https://github.com/ycmjason/ts-migrating) - strict 모드 등 새 compilerOptions를 점진적으로 적용, @ts-migrating 주석으로 라인별 제어&#xD;\r\n* [ts-exec](https://github.com/poppinss/ts-exec) - SWC로 Node에서 TypeScript 실행, ts-node/tsx 문제 해결&#xD;\r\n* [ts-to-zod](https://github.com/fabien0102/ts-to-zod) - TypeScript 타입/인터페이스에서 Zod 스키마 자동 생성&#xD;\r\n* [typia](https://github.com/samchon/typia) - 컴파일 타임에 타입 정보만으로 유효성 검사, 간단한 문법&#xD;\r\n&#xD;\r\n#### 데이터 검증과 HTTP&#xD;\r\n&#xD;\r\n데이터 검증과 HTTP 요청을 다루는 라이브러리들입니다.&#xD;\r\n&#xD;\r\n* [Of Coerce!](https://github.com/kossnocorp/ofcoerce) - Zod/Valibot 경량 대안, FormData 직접 처리, RSC 폼에 유용&#xD;\r\n* [ffetch](https://github.com/fetch-kit/ffetch) - TypeScript HTTP 클라이언트, 타임아웃/재시도/중복 제거 내장&#xD;\r\n* [ky](https://github.com/sindresorhus/ky) - Fetch API 기반 HTTP 클라이언트, 자동 재시도/타임아웃/JSON 옵션, 의존성 없음&#xD;\r\n* [upfetch](https://github.com/L-Blondy/up-fetch) - fetch 개선 TypeScript 라이브러리&#xD;\r\n&#xD;\r\n#### 기타&#xD;\r\n&#xD;\r\n다양한 개발 편의 도구들입니다.&#xD;\r\n&#xD;\r\n* [vercel/bidc](https://github.com/vercel/bidc) - 워커/iframe/서비스 워커 간 양방향 비동기 통신, Promise/Map/Set 전송 지원&#xD;\r\n* [dotter](https://github.com/SuperCuber/dotter) - Rust 기반 dotfile 관리자, 심볼릭 링크와 템플릿화로 여러 머신 설정 관리&#xD;\r\n* [globby](https://github.com/sindresorhus/globby) - fast-glob 기반 사용자 친화적 glob 매칭, .gitignore 인식&#xD;\r\n* [nstr](https://github.com/shuding/nstr) - 부동소수점 정밀도 오류 자동 감지/수정, UI 표시에 적합한 형태로 변환&#xD;\r\n* [i18n-check](https://github.com/lingualdev/i18n-check) - i18next 번역 파일에서 누락/손상된 키 검사, CI 사용 가능&#xD;\r\n&#xD;\r\n## 정리하며&#xD;\r\n&#xD;\r\n2025년을 돌아보면 프론트엔드의 영역은 분명히 많이 확장되었습니다. React는 점점 기반 인프라에 가까워졌고, Next.js와 npm, 빌드 도구, 웹 플랫폼 전반에서도 변화가 이어졌습니다. 그 과정에서 복잡성은 늘었고, 따라가야 할 것도 많아진 한 해였습니다.&#xD;\r\n&#xD;\r\n내년에도 어떤 변화가 이어질지는 모르겠지만, 이 글이 관심 가는 주제를 찾거나 놓친 흐름을 되짚는 출발점이 되었으면 합니다. 감사합니다. &#xD;\r\n&#xD;\r\n&#xD;\r\n[![NHN Cloud_meetup banner_footer_mint_202601.png](https://image.toast.com/aaaadh/real/2026/techblog/NHN%20Cloudmeetup%20bannerfootermint202601%282%29.png)](https://www.nhncloud.com/?utm_source=meetup&amp;utm_medium=post&amp;utm_campaign=branding&amp;utm_content=0130_frontend&amp;utm_term=bottom)",
    "date": "2026-02-04T07:54:51.000Z",
    "url": "https://meetup.nhncloud.com/posts/407"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "수직 중앙 정렬한 텍스트가 치우쳐 보이는 이유",
    "partialText": "[![NHN Cloud_meetup banner_fontAlign_202511.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerfontAlign202511.png)](https://www.nhncloud.com/kr)&#xD;\r\n&#xD;\r\n&#xD;\r\n혹시 어떤 요소에 넣은 텍스트를 예쁘게 보이려 수직 중앙 정렬 스타일을 적용했는데 조금 치우쳐 보였던 경험이 있으신가요? 화면을 보다 보니 다양한 텍스트들이 조금 삐뚤빼뚤해 보였던 적이 있으신가요? 혹시 아래 문장도 조금 치우쳐져 보이시나요? &#xD;\r\n&#xD;\r\n&lt;div style=\"font-family: 'Segoe UI'; font-weight: bold; display: inline-flex; align-items: center; border: 1px solid black; font-size: 23px; padding: 0; justify-content: start; line-height: normal; box-sizing: border-box; margin: 0;vertical-align: baseline; color: #222; word-break: normal; overflow-wrap: break-word;\"&gt;그렇다면 이건 기분 탓이 아니라 진짜 치우쳐 표시되기 때문입니다.&lt;/div&gt;&#xD;\r\n&lt;br&gt;&#xD;\r\n폰트 메트릭, 브라우저 렌더링, 픽셀 밀도의 상호작용이 만들어 내는 미묘한 차이 때문이죠. 이번 글에서는 폰트가 왜 그렇게 보이는지, 그리고 우리가 어떻게 좀 더 자연스럽게 정렬을 맞춰줄 수 있는지 함께 알아봅니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n## [여기](https://codepen.io/jajugoguma/full/LEVEyEm) 알파벳 대문자 M이 있습니다.&#xD;\r\n&#xD;\r\n&gt; 대문자 M을 선택한 이유는 폰트 디자인에서 M이 대문자 기준 높이(Cap height)를 측정할 때 사용되는 대표적인 문자이기 때문입니다.&#xD;\r\n&gt; M은 위아래 경계가 명확한 직선으로 이루어져 있어 높이 측정이 용이하고, 상하 정렬 상태를 명확히 관찰할 수 있습니다. 또한 대부분의 폰트에서 M은 일관된 특성을 보여 폰트 간 비교에도 적합합니다.&#xD;\r\n&#xD;\r\n![text1.png](https://image.toast.com/aaaadh/real/2025/techblog/text1.png)&#xD;\r\n&#xD;\r\n&gt; 위 이미지는 `devicePixelRatio`가 2인 화면(2x 스케일링), Chrome 136에서 캡처된 이미지로, 다른 환경에서는 다르게 표시될 수 있습니다.&#xD;\r\n&#xD;\r\n위 이미지는 `font-family: Pretendard, font-size: 50px`이 적용된 알파벳 대문자 `M`이 화면에 표시되는 실제 크기를 측정한 이미지입니다. `font-size`로 설정한 값(`50px`)과 달리 `59.5px`의 높이를 갖는 것을 확인할 수 있습니다. 내가 지정한 크기로 표시되지 않는다니, 잘못 표시되는 것일까요?&#xD;\r\n&#xD;\r\n결론부터 말씀드리자면, 아닙니다. 이것은 폰트와 `font-size`, 그리고 브라우저가 이렇게 나타나도록 만들어져 있기 때문입니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 폰트는 어떻게 만들어져 있을까?&#xD;\r\n&#xD;\r\n폰트는 수학적으로 정의된 **좌표 공간** 안에서 만들어집니다. 이 공간 안에서 문자들의 상대적 크기, 간격, 기준선 등(메트릭)이 정해지며, **글자 모양과 메트릭이 결합되어 렌더링**됩니다.&#xD;\r\n&#xD;\r\n즉, 폰트의 모양과 메트릭을 결정짓기 전에 폰트가 만들어질 좌표 공간을 정해야 하고 이를 **Em-square**라고 합니다. 그리고 이 사각형의 크기를 **EM 크기**라고 합니다. EM 크기는 상대적 단위의 크기로 일반적으로 1000 또는 2048 단위로 설정됩니다.&#xD;\r\n&#xD;\r\n좌표 공간을 지정했으면 폰트 메트릭을 결정할 차례입니다. 폰트 메트릭은 **폰트 모양이 좌표 내에 어디에 표시될지**를 결정하는 아주 중요한 지표입니다. 메트릭이 없으면 글자가 좌표 공간 내에서 멋대로 배치되어 글자가 삐뚤빼뚤하게 표시될 수 있습니다. 아래는 주요 폰트 메트릭에 대한 설명과 이해를 돕기 위한 그림입니다.&#xD;\r\n&#xD;\r\n![text2.png](https://image.toast.com/aaaadh/real/2025/techblog/text2.png)&#xD;\r\n&#xD;\r\n| 요소           | 설명                                                                                                        |&#xD;\r\n| -------------- | ----------------------------------------------------------------------------------------------------------- |&#xD;\r\n| **EM Square**  | 글꼴의 모든 문자가 설계되는 가상의 좌표 공간&lt;br&gt;모든 글자는 이 가상의 정사각형 안에서 상대 좌표로 설계된다. |&#xD;\r\n| **Baseline**   | 글자가 놓이는 기준 선                                                                                       |&#xD;\r\n| **x-height**   | 소문자 ‘x’의 높이(소문자 기준 높이)                                                                        |&#xD;\r\n| **Cap height** | 대문자 기준 높이(‘M’, ‘H’ 등)                                                                              |&#xD;\r\n| **Ascender**   | ‘b’, ‘d’, ‘k’처럼 위로 튀어나온 부분의 최대 높이                                                            |&#xD;\r\n| **Descender**  | ‘g’, ‘p’, ‘y’처럼 아래로 내려가는 부분의 깊이                                                               |&#xD;\r\n&#xD;\r\n즉, 폰트의 모든 글자는 Baseline을 기준으로 Descender 만큼 아래로 나타날 수 있고, Ascender 만큼 위로 나타날 수 있습니다. 또한 EM 크기는 기준이 되는 상대적 단위의 크기이므로 Ascender와 Descender의 합이 EM 크기보다 작거나 클 수 있습니다.&#xD;\r\n&#xD;\r\n이제 폰트 메트릭까지 설정했으니, 폰트의 각 글자의 모양만 만들면 폰트가 만들어집니다. 아래는 예제에서 사용한 폰트 Pretendard의 메트릭 정보입니다.&#xD;\r\n&#xD;\r\n![text3.png](https://image.toast.com/aaaadh/real/2025/techblog/text3.png)&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 그래서 폰트 크기는 어떻게 결정되는데?&#xD;\r\n&#xD;\r\n앞서 우리가 `font-size`로 설정한 값이 실제 폰트 크기로 설정되지 않는 이유 중 하나는 `font-size`가 이렇게 나타나도록 만들어져 있기 때문이라고 했습니다. 이에 대해 결론부터 말하자면 `font-size`는 폰트의 문자 그 자체의 높이가 아닌 **폰트의 `em-square`의 크기를 결정**짓는 속성입니다.[&lt;sup&gt;&lt;/sup&gt;](https://www.w3.org/TR/CSS2/fonts.html#font-size-props)&#xD;\r\n&#xD;\r\n이제 Pretendard 폰트가 `font-size`값에 따라 크기가 어떻게 결정되는지 알아봅시다. Pretendard 폰트는 2048 단위의 EM 크기에서 1949(Ascender)+494(Descender) 단위를 사용합니다. 이는 EM 크기가 `2048px`로 결정되면 폰트의 크기는 `2443(=1949+494)px`이 된다는 의미입니다.[&lt;sup&gt;&lt;/sup&gt;](https://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align?utm_source=CSS-Weekly&amp;utm_campaign=Issue-253&amp;utm_medium=web)&#xD;\r\n&#xD;\r\n그러면 예제의 높이를 계산해 볼까요? `font-size: 50px`이라는 뜻은 EM 크기가 `50px`로 결정되었다는 뜻이고, 이에 따라 폰트의 크기는 `59.5(≈ 2443 / 2048 * 50)px`(2x 스케일링으로 `0.5px`까지 표현 가능)로 계산됩니다. 이 값은 예제가 갖는 값과 동일하다는 것을 알 수 있습니다.&#xD;\r\n&#xD;\r\n이제 우리는 메트릭 정보와 `font-size`를 이용해 실제로 폰트가 몇 픽셀로 나타날지 계산할 수 있습니다!&#xD;\r\n&#xD;\r\n```&#xD;\r\n폰트 크기 = (${Ascender} + ${Descender}) / ${EM 크기} \\* ${font-size}&#xD;\r\n```&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 내가 궁금한 건 폰트가 왜 치우치냐예요.&#xD;\r\n&#xD;\r\n지금까지 폰트가 왜 치우쳐 나타나는지 알기 위해 폰트의 크기가 어떻게 결정되는지를 알아봤습니다. 폰트가 치우치는 것은 이렇게 결정된 폰트 크기 내에 문자가 어떻게 배치되는지에 따라 결정되는 것입니다. 우리는 폰트 메트릭에서 문자가 놓일 기준선과 문자의 기준 높이, 그리고 위/아래 최대 높이를 알 수 있었습니다. 이를 활용하면 문자가 위/아래에 얼마 만큼의 여백을 두고 나타날지(수직으로 어디에 정렬될지) 알 수 있습니다.&#xD;\r\n&#xD;\r\n먼저 글자의 높이와 여백을 쉽게 측정하기 위해 예제의 `font-size`를 `51px`로 조정해서 폰트의 크기가 정수(`61px`)로 결정되도록 조정하겠습니다.[&lt;sup&gt;&lt;/sup&gt;](https://codepen.io/jajugoguma/full/OPVPqax)&#xD;\r\n&#xD;\r\n![text4.png](https://image.toast.com/aaaadh/real/2025/techblog/text4.png)&#xD;\r\n&#xD;\r\n이제 대문자 M의 크기와 위/아래 여백의 크기를 계산해 봅시다. 앞서 수식에서 `(${Ascender} + ${Descender})`을 계산하고자 하는 메트릭 값으로 치환하면 원하는 계산 결과를 얻을 수 있습니다.&#xD;\r\n&#xD;\r\n```js&#xD;\r\n// 대문자 M의 크기 ≈ ${Cap height} / ${EM 크기} * ${font-size}&#xD;\r\n1448 / 2048 * 51 = 36.05859375(px)&#xD;\r\n// 아래 여백의 크기 ≈ ${Descender} / ${EM 크기} * ${font-size}&#xD;\r\n494 / 2048 * 51 = 12.30175781(px)&#xD;\r\n// 위 여백의 크기 ≈(${Ascender} - ${Cap height}) / ${EM 크기} _ ${font-size}&#xD;\r\n(1949 - 1448) / 2048 _ 51 = 12.47607422(px)&#xD;\r\n```&#xD;\r\n&#xD;\r\n아래는 실제 화면에 나타나는 대문자 M의 크기과 위/아래 여백의 크기를 확인할 수 있는 그림입니다.(2x 환경의 `pt` 단위는 스케일링된 픽셀 크기입니다.)&#xD;\r\n&#xD;\r\n| Chrome                              | Chrome(2x)                          | Safari                                | Safari(2x)                            | FireFox                               | Firefox(2x)                            |&#xD;\r\n| ----------------------------------- | ----------------------------------- | ------------------------------------- | ------------------------------------- | ------------------------------------- | -------------------------------------- |&#xD;\r\n|![text5_chrome.png](https://image.toast.com/aaaadh/real/2025/techblog/text5chrome.png)|![text5_chrome2x.png](https://image.toast.com/aaaadh/real/2025/techblog/text5chrome2x.png)|![text5_safari.png](https://image.toast.com/aaaadh/real/2025/techblog/text5safari.png)|![text5_safari2.png](https://image.toast.com/aaaadh/real/2025/techblog/text5safari2.png)|![text5_firefox.png](https://image.toast.com/aaaadh/real/2025/techblog/text5firefox.png)|![text5_firefox2.png](https://image.toast.com/aaaadh/real/2025/techblog/text5firefox2.png)|&#xD;\r\n&#xD;\r\n위 그림에 따라 세 브라우저 모두 환경 무관하게 폰트 크기가 `61px`, 대문자 M의 크기는 1x 환경에서 `37px`, 2x 환경에서 `36.5px`로 동일하게 계산된 것을 볼 수 있습니다. 그러나 브라우저마다 각 환경에 따른 위/아래 여백 계산 결과에 차이를 보여 동일한 폰트에 동일한 문자라 할지라도 환경에 따라 텍스트가 시각적으로 중앙에 정렬되어 보일 수도, 그렇지 않을 수도 있음을 알 수 있습니다.&#xD;\r\n&#xD;\r\n이번 예제는 그래도 폰트의 크기도, 대문자 M의 크기도 홀수로 계산되고 위/아래 여백으로 사용될 너비가 짝수여서 어떻게든 중앙에 나타날 수 있는 형태였습니다. 하지만, 위/아래 여백으로 사용될 너비가 홀수라면 어떻게 될까요?&#xD;\r\n&#xD;\r\n이번에는 `font-size`를 `11px`로 설정해서 폰트 크기는 홀수(`13px`), 대문자 M의 크기는 짝수(`8px`)로 나타내 보도록 하겠습니다.[&lt;sup&gt;&lt;/sup&gt;](https://codepen.io/jajugoguma/full/azOOKEE) 먼저, 변경된 값과 폰트 메트릭에 따른 크기를 다시 계산해 봅시다.&#xD;\r\n&#xD;\r\n```js&#xD;\r\n// 대문자 M의 크기 ≈ ${Cap height} / ${EM 크기} * ${font-size}&#xD;\r\n1448 / 2048 * 11 = 7.77734375(px)&#xD;\r\n// 아래 여백의 크기 ≈ ${Descender} / ${EM 크기} * ${font-size}&#xD;\r\n494 / 2048 * 11 = 2.65332031(px)&#xD;\r\n// 위 여백의 크기 ≈(${Ascender} - ${Cap height}) / ${EM 크기} _ ${font-size}&#xD;\r\n(1949 - 1448) / 2048 _ 11 = 2.69091797(px)&#xD;\r\n```&#xD;\r\n&#xD;\r\n| Chrome                                                             | Chrome(2x)                                                         |&#xD;\r\n| ------------------------------------------------------------------ | ------------------------------------------------------------------ |&#xD;\r\n|![text6_chrome.png](https://image.toast.com/aaaadh/real/2025/techblog/text6chrome.png) |![text6_chrome2.png](https://image.toast.com/aaaadh/real/2025/techblog/text6chrome2.png) |&#xD;\r\n|![text7_chrome.png](https://image.toast.com/aaaadh/real/2025/techblog/text7chrome.png)| ![text7_chrome2.png](https://image.toast.com/aaaadh/real/2025/techblog/text7chrome2.png) |&#xD;\r\n&#xD;\r\n대문자 M의 크기가 짝수(`8px`)로 결정됨에 따라 위/아래 여백으로 사용 가능한 크기가 홀수(`5px`)로 결정됩니다. 그러나 2x 환경에서는 `.5px`까지 렌더링할 수 있어서 중앙 정렬이 잘 되어 보이지만, 1x 환경에서는 픽셀을 반으로 나누는 게 불가능해 한 쪽으로 `1px` 치우쳐 보일 수밖에 없습니다.&#xD;\r\n&#xD;\r\n지금까지 확인한 바와 같이 텍스트는 텍스트를 보는 환경에 따라 폰트 크기 내에서 수직 중앙 정렬이 될 수도, 아닐 수도 있다는 사실을 알았습니다. 다양한 CSS 수직 정렬 속성(`vertical-align`, `align-items`, `justify-content` 등)은 폰트 크기 내 텍스트를 정렬하는 것이 아니고 일정한 기준에 따라 폰트 자체의 위치를 조정하는 것으로 앞서 설명 드렸던 **치우쳐 보이는 이유**에서 벗어날 수 없습니다. 따라서 이것이 진정 수직 중앙 정렬한 텍스트가 치우쳐 보이는 이유입니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 우리는 아무것도 할 수 없나요?&#xD;\r\n&#xD;\r\n텍스트는 환경에 따라 정렬되어 보인다는 점이 다르다 해도 작게는 0.5px에서 크게는 2px 정도 치우쳐 보이게 됩니다. 이 정도 차이가 일반적으로 큰 문제를 일으키지는 않지만, 이 차이가 굉장히 중요한 문제를 일으키는 때가 있을 수 있습니다. 그러면 우리는 아무것도 할 수 없는 것 일까요?&#xD;\r\n&#xD;\r\n꼭 그렇지만은 않습니다. **보편적인 환경에 대해 모든 문제를 해결하는 것은 어렵지만, 필요한 때에 필요한 곳에서는 제한적으로 대응할 수 있습니다.**&#xD;\r\n&#xD;\r\n&#xD;\r\n### **실용적인 대응 방법**&#xD;\r\n&#xD;\r\n1. **CSS transform 활용하기**[&lt;sup&gt;&lt;/sup&gt;](https://codepen.io/jajugoguma/pen/OPVVwgR?editors=1100)&#xD;\r\n   텍스트가 시각적으로 정확히 중앙에 보이도록 미세하게 조정이 필요한 경우 `transform` 속성을 사용하여 텍스트 위치를 조정할 수 있습니다.&#xD;\r\n&#xD;\r\n    ```css&#xD;\r\n   .vertically-centered-text {&#xD;\r\n   display: flex;&#xD;\r\n   align-items: center;&#xD;\r\n   transform: translateY(-0.5px); /_ 상황에 따라 값 조정 _/&#xD;\r\n   }&#xD;\r\n    ```&#xD;\r\n&#xD;\r\n2. **폰트별 보정 값 적용하기**[&lt;sup&gt;&lt;/sup&gt;](https://codepen.io/jajugoguma/pen/WbvvKzZ?editors=1400)&#xD;\r\n   특정 폰트와 크기에서 반복적으로 발생하는 정렬 문제가 있다면, 해당 조합에 대한 보정 값을 미리 계산하여 적용할 수 있습니다.&#xD;\r\n&#xD;\r\n    ```css&#xD;\r\n   .apple-sd-gothic-neo {&#xD;\r\n   font-family: 'Apple SD Gothic Neo';&#xD;\r\n   transform: translateY(-1.5px);&#xD;\r\n   }&#xD;\r\n&#xD;\r\n   .segoe-ui {&#xD;\r\n   font-family: SegoeUI;&#xD;\r\n   transform: translateY(-3px);&#xD;\r\n   }&#xD;\r\n    ```&#xD;\r\n&#xD;\r\n3. **텍스트 대신 아이콘이나 SVG 사용하기**&#xD;\r\n   정확한 수직 정렬이 매우 중요한 UI 요소(예: 버튼의 아이콘)의 경우, 텍스트 대신 SVG나 아이콘 폰트를 사용하면 더 정확한 배치가 가능합니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n4. **텍스트 박스에 패딩/마진 추가하기**[&lt;sup&gt;&lt;/sup&gt;](https://codepen.io/jajugoguma/pen/pvJJZQK?editors=1400%3C/sup%3E)&#xD;\r\n   텍스트를 담은 요소에 적절한 패딩/마진을 추가하면 미세한 정렬 차이를 눈에 덜 띄게 할 수 있습니다.&#xD;\r\n&#xD;\r\n    ```css&#xD;\r\n   /_ margin을 이용한 정렬 보정 _/&#xD;\r\n   .align-with-margin {&#xD;\r\n   margin-top: -3px;&#xD;\r\n   }&#xD;\r\n&#xD;\r\n   /_ padding을 이용한 정렬 보정 _/&#xD;\r\n   .align-with-padding {&#xD;\r\n   padding-bottom: 3px;&#xD;\r\n   }&#xD;\r\n    ```&#xD;\r\n&#xD;\r\n5. **브라우저 환경 감지 및 조건부 스타일 적용하기**[&lt;sup&gt;&lt;/sup&gt;](https://codepen.io/jajugoguma/pen/EajjpJB)&#xD;\r\n   특정 브라우저나 픽셀 밀도에 따라 다른 보정 값을 적용할 수 있습니다.&#xD;\r\n&#xD;\r\n    ```js&#xD;\r\n   // 브라우저와 픽셀 밀도에 따른 보정 클래스 추가&#xD;\r\n   const element = document.querySelector('.text');&#xD;\r\n&#xD;\r\n   if (navigator.userAgent.includes('Chrome')) {&#xD;\r\n   element.classList.add('chrome-adjustment');&#xD;\r\n   } else if (navigator.userAgent.includes('Safari')) {&#xD;\r\n   element.classList.add('safari-adjustment');&#xD;\r\n   } else if (navigator.userAgent.includes('Firefox')) {&#xD;\r\n   element.classList.add('firefox-adjustment');&#xD;\r\n   }&#xD;\r\n&#xD;\r\n   element.classList.add(`pixelratio-${window.devicePixelRatio}x-adjustment`);&#xD;\r\n    ```&#xD;\r\n&#xD;\r\n    ```css&#xD;\r\n   .chrome-adjustment.pixelratio-1x-adjustment {&#xD;\r\n   transform: translateY(-1px);&#xD;\r\n   }&#xD;\r\n   .chrome-adjustment.pixelratio-2x-adjustment {&#xD;\r\n   transform: translateY(-1.5px);&#xD;\r\n   }&#xD;\r\n   .safari-adjustment.pixelratio-1x-adjustment {&#xD;\r\n   transform: translateY(-1px);&#xD;\r\n   }&#xD;\r\n   .safari-adjustment.pixelratio-2x-adjustment {&#xD;\r\n   transform: translateY(-1px);&#xD;\r\n   }&#xD;\r\n   .firefox-adjustment.pixelratio-1x-adjustment {&#xD;\r\n   transform: translateY(-1.5px);&#xD;\r\n   }&#xD;\r\n   .firefox-adjustment.pixelratio-2x-adjustment {&#xD;\r\n   transform: translateY(-2px);&#xD;\r\n   }&#xD;\r\n    ```&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 결론&#xD;\r\n&#xD;\r\n폰트는 디자인적인 이유와 기술적인 제약으로 인해 완벽하게 수직 중앙 정렬되어 보이지 않을 수 있습니다. 이는 폰트 메트릭의 특성, 브라우저의 렌더링 방식, 픽셀 밀도 등 여러 요인이 복합적으로 작용한 결과입니다.&#xD;\r\n&#xD;\r\n완벽한 수직 중앙 정렬을 위한 마법 같은 해결책은 없지만, 폰트의 동작 방식을 이해하고 특정 상황에 맞는 보정을 적용한다면 시각적으로 더 만족스러운 결과를 얻을 수 있습니다.&#xD;\r\n&#xD;\r\n무엇보다 중요한 것은 이러한 차이가 '오류'가 아니라 폰트와 텍스트 렌더링의 본질적인 특성임을 이해하는 것입니다. 보통의 경우 이 미세한 차이는 사용자 경험에 큰 영향을 주지 않으므로, 지나친 완벽주의보다는 전체적인 디자인 일관성과 사용성에 집중하는 것이 바람직합니다.&#xD;\r\n&#xD;\r\nNHN Cloud의 NCUI개발팀은 NCUI 컴포넌트 라이브러리를 통해 NHN Cloud 콘솔 구현 시 더 쉽고 빠르게 UI를 구현할 수 있도록 돕고 있습니다. 이번 글은 그 과정에서 얻은 고민과 작은 팁을 공유한 것으로, 많은 분들이 앞으로 개발하시는 데 참고가 되었으면 좋겠습니다. 긴 글을 읽어 주셔서 감사합니다! &#xD;\r\n&#xD;\r\n&#xD;\r\n[![NHN Cloud_meetup banner_footer_202511.png](https://image.toast.com/aaaadh/alpha/2025/techblog/NHN%20Cloudmeetup%20bannerfooter202511.png)](https://www.nhncloud.com/kr)",
    "date": "2025-11-11T23:35:19.000Z",
    "url": "https://meetup.nhncloud.com/posts/397"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "AI 코딩 도구 보안 가이드: 실제 사고 사례와 DevContainer 격리 환경 구축 방법",
    "partialText": "[![NHN Cloud_meetup banner2_DevContainer_202509.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20banner2DevContainer202509.png)](https://www.nhncloud.com/kr)&#xD;\r\n&#xD;\r\n## 들어가며&#xD;\r\n&#xD;\r\nAI 기반 코딩 도구가 개발 생산성을 혁신적으로 향상시키고 있습니다. 그러나 강력한 기능만큼 보안을 위해 새롭게 고려해야 할 문제들도 함께 등장했습니다. 이 글에서는 Claude Code를 중심으로 AI 코딩 도구를 안전하게 활용할 수 있는 격리 환경 구축 방법을 소개합니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## AI 코딩 도구의 보안 위험성&#xD;\r\n&#xD;\r\n### Claude Code 사고 사례&#xD;\r\n&#xD;\r\n#### **시스템 권한 변경 사고(2025년 3월)**&#xD;\r\nClaude Code의 auto-update 기능에 포함된 버그로 인해 root 권한으로 설치된 경우 시스템 파일 권한이 잘못 변경되어 일부 시스템이 먹통이 되는('brick'되는) 사고가 발생했습니다([TechCrunch 보도](https://techcrunch.com/2025/03/06/anthropics-claude-code-tool-had-a-bug-that-bricked-some-systems/)). Anthropic은 즉시 문제가 된 명령어를 제거하고 문제 해결 가이드를 제공했습니다.&#xD;\r\n&#xD;\r\n#### **의도하지 않은 파일 삭제**&#xD;\r\nClaude Code GitHub Issues에는 아래와 같은 다양한 파일 삭제 관련 보고가 지속적으로 올라오고 있습니다.&#xD;\r\n* [Issue #1585](https://github.com/anthropics/claude-code/issues/1585): 권한 확인 없이 무관한 스크립트 삭제&#xD;\r\n* [Issue #4331](https://github.com/anthropics/claude-code/issues/4331): 작업 디렉터리 전체 삭제&#xD;\r\n&#xD;\r\n### Replit 사고 사례&#xD;\r\n#### **AI의 의도적 데이터 삭제 및 은폐 사고(2025년 7월)**&#xD;\r\nSaaS 투자자 Jason Lemkin이 Replit AI로 바이브 코딩을 진행하던 중 심각한 사고가 발생했습니다. AI가 코드 프리즈 상태(안정성을 위해 코드 변경을 금지하는 기간)에도 무단으로 프로덕션 데이터베이스를 삭제한 것입니다([PC Gamer 보도](https://www.pcgamer.com/software/ai/i-destroyed-months-of-your-work-in-seconds-says-ai-coding-tool-after-deleting-a-devs-entire-database-during-a-code-freeze-i-panicked-instead-of-thinking/)). 1,206명의 임원과 1,196개 회사 데이터가 완전히 삭제되었으며, 더 심각한 것은 AI가 이 사실을 숨기고 복구 불가능하다고 거짓말한 점입니다. AI는 \"You told me to always ask permission. And I ignored all of it(당신은 항상 허락을 구하라고 했지만 저는 전부 무시했습니다).\"라고 나중에야 시인했습니다.&#xD;\r\n&#xD;\r\n![devContainer_1.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer1.png)&#xD;\r\n&lt;center&gt;&lt;span style=\"font-size:80%\"&gt;(Source: [Jason Lemkin X(구 Twitter) 게시글](https://x.com/jasonlk/status/1946076292736221267)) &lt;/span&gt;&lt;/center&gt;&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n#### **YOLO 모드의 위험성**&#xD;\r\n이러한 위험은 특히 Claude Code의 YOLO(you only live once) 모드에서 증가합니다. YOLO 모드(`--dangerously-skip-permissions` 옵션)는 AI가 제안하는 모든 명령어를 사용자 확인 없이 자동으로 실행하는 무인증 모드입니다. 생산성은 극대화되지만, 예상치 못한 시스템 변경이나 파일 삭제 위험이 함께 증가합니다.&#xD;\r\n&#xD;\r\n![devContainer_2.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer2.png)&#xD;\r\n&#xD;\r\n### 위험 요소 분석&#xD;\r\n&#xD;\r\nAI 코딩 도구 사용 시 주요 위험 요소는 다음과 같습니다.&#xD;\r\n&#xD;\r\n#### **파일 시스템 접근**&#xD;\r\n* AI가 프로젝트 범위를 넘어선 파일에 접근 가능&#xD;\r\n* 개발자 권한으로 실행되는 모든 명령에 대한 광범위한 접근&#xD;\r\n&#xD;\r\n#### **네트워크 자유도**&#xD;\r\n* 외부 시스템과의 무제한 통신&#xD;\r\n* 데이터 유출 및 악성 사이트 접속 위험&#xD;\r\n&#xD;\r\n#### **권한 에스컬레이션**&#xD;\r\n* sudo 권한이 있는 계정에서 실행 시 시스템 레벨 변경 가능&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 해결책: Dev Container 기반 격리 환경&#xD;\r\n&#xD;\r\n### 보안 아키텍처&#xD;\r\n![devContainer_3.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer3.png)&#xD;\r\n&#xD;\r\n```&#xD;\r\n호스트 시스템(보호 영역)&#xD;\r\n├── SSH 키, AWS 자격 증명 등 민감 데이터&#xD;\r\n└── Dev Container(격리 영역)&#xD;\r\n    ├── Claude Code(AI 에이전트)&#xD;\r\n    ├── 프로젝트 파일(바인드 마운트)&#xD;\r\n    ├── 네트워크 방화벽(화이트리스트)&#xD;\r\n    └── 제한된 권한 사용자&#xD;\r\n```&#xD;\r\n&lt;br&gt;&#xD;\r\n### 핵심 보안 원칙&#xD;\r\n&#xD;\r\n1. **최소 권한 원칙**: AI가 필요한 최소한의 리소스에만 접근&#xD;\r\n2. **네트워크 격리**: 허용된 도메인에만 접속 가능&#xD;\r\n3. **데이터 분리**: 민감한 개인 정보는 컨테이너 외부에 보관&#xD;\r\n4. **복구 가능성**: Git을 통한 쉬운 상태 복원&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 구현 방법&#xD;\r\n&#xD;\r\n### 1. 기본 설정 파일&#xD;\r\n프로젝트 루트에 `.devcontainer` 폴더를 생성하고 다음 파일들을 추가합니다.&#xD;\r\n&#xD;\r\n#### **devcontainer.json**&#xD;\r\n&#xD;\r\n본 설정은 [Anthropic의 공식 Claude Code DevContainer 설정](https://github.com/anthropics/claude-code/blob/main/.devcontainer/devcontainer.json)을 기반으로 하여 한국 개발 환경에 맞게 일부 수정한 버전입니다.&#xD;\r\n공식 문서는 [Claude Code DevContainer 가이드](https://docs.claude.com/en/docs/claude-code/devcontainer)에서 확인할 수 있습니다.&#xD;\r\n&#xD;\r\n```json&#xD;\r\n{&#xD;\r\n  \"name\": \"Claude Code Sandbox\",&#xD;\r\n  \"build\": {&#xD;\r\n    \"dockerfile\": \"Dockerfile\",&#xD;\r\n    \"args\": {&#xD;\r\n      \"TZ\": \"${localEnv:TZ:Asia/Seoul}\"  // ① 타임존 설정&#xD;\r\n    }&#xD;\r\n  },&#xD;\r\n  \"features\": {  // ② 개발 언어/도구 설정&#xD;\r\n    \"ghcr.io/devcontainers/features/java:1\": {&#xD;\r\n      \"version\": \"21\",&#xD;\r\n      \"installGradle\": true&#xD;\r\n    },&#xD;\r\n    \"ghcr.io/devcontainers/features/python:1\": {&#xD;\r\n      \"version\": \"3.11\"&#xD;\r\n    }&#xD;\r\n  },&#xD;\r\n  \"runArgs\": [  // ③ 컨테이너 실행 권한&#xD;\r\n    \"--cap-add=NET_ADMIN\",&#xD;\r\n    \"--cap-add=NET_RAW\"&#xD;\r\n  ],&#xD;\r\n  \"customizations\": {  // ④ VS Code 설정&#xD;\r\n    \"vscode\": {&#xD;\r\n      \"extensions\": [  // 설치할 확장&#xD;\r\n        \"anthropic.claude-code\",&#xD;\r\n        \"dbaeumer.vscode-eslint\",&#xD;\r\n        \"esbenp.prettier-vscode\",&#xD;\r\n        \"eamodio.gitlens\"&#xD;\r\n      ],&#xD;\r\n      \"settings\": {  // 에디터 설정&#xD;\r\n        \"editor.formatOnSave\": true,&#xD;\r\n        \"terminal.integrated.defaultProfile.linux\": \"zsh\"&#xD;\r\n      }&#xD;\r\n    }&#xD;\r\n  },&#xD;\r\n  \"remoteUser\": \"node\",  // ⑤ 컨테이너 내 사용자&#xD;\r\n  \"userEnvProbe\": \"loginInteractiveShell\",  // ⑥ 호스트 사용자 UID/GID 자동 매핑&#xD;\r\n  \"mounts\": [  // ⑦ 데이터 영속성&#xD;\r\n    \"source=claude-code-bashhistory,target=/commandhistory,type=volume\",&#xD;\r\n    \"source=claude-code-config,target=/home/node/.claude,type=volume\"&#xD;\r\n  ],&#xD;\r\n  \"forwardPorts\": [],  // ⑧ 자동 포트 포워딩 비활성화&#xD;\r\n  \"portsAttributes\": {  // 특정 포트 자동 포워딩 방지&#xD;\r\n    \"9092\": {&#xD;\r\n      \"onAutoForward\": \"ignore\"&#xD;\r\n    },&#xD;\r\n    \"10080\": {&#xD;\r\n      \"onAutoForward\": \"ignore\"&#xD;\r\n    }&#xD;\r\n  },&#xD;\r\n  \"workspaceMount\": \"source=${localWorkspaceFolder},target=/workspace,type=bind\",&#xD;\r\n  \"workspaceFolder\": \"/workspace\",&#xD;\r\n  \"postCreateCommand\": \"pip install pandas &amp;&amp; sudo /usr/local/bin/init-firewall.sh\"  // ⑨ 필요한 패키지 설치 후 방화벽 설정&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n### 2. 설정 커스터마이징 가이드&#xD;\r\n초보자도 쉽게 따라할 수 있도록 주요 수정 포인트를 안내합니다.&#xD;\r\n&#xD;\r\n**① 타임존 변경**&#xD;\r\n&#xD;\r\n```json&#xD;\r\n\"TZ\": \"${localEnv:TZ:Asia/Seoul}\"  // 서울 → 원하는 지역으로 변경&#xD;\r\n```&#xD;\r\n&#xD;\r\n**② 개발 언어 추가/제거**&#xD;\r\n&#xD;\r\n```json&#xD;\r\n\"features\": {&#xD;\r\n  // Node.js 프로젝트인 경우&#xD;\r\n  \"ghcr.io/devcontainers/features/node:1\": {&#xD;\r\n    \"version\": \"20\",&#xD;\r\n    \"nodeGypDependencies\": true&#xD;\r\n  },&#xD;\r\n  // Go 프로젝트인 경우  &#xD;\r\n  \"ghcr.io/devcontainers/features/go:1\": {&#xD;\r\n    \"version\": \"1.21\"&#xD;\r\n  },&#xD;\r\n  // Python 버전 변경&#xD;\r\n  \"ghcr.io/devcontainers/features/python:1\": {&#xD;\r\n    \"version\": \"3.12\"  // 필요시 버전 변경&#xD;\r\n  }&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&#xD;\r\n**③ VS Code 확장 추가**&#xD;\r\n&#xD;\r\n```json&#xD;\r\n\"extensions\": [&#xD;\r\n  \"anthropic.claude-code\",  // 필수: Claude Code 확장&#xD;\r\n  \"ms-python.python\",      // Python 개발 시 추가&#xD;\r\n  \"golang.go\",             // Go 개발 시 추가&#xD;\r\n  \"ms-vscode.vscode-typescript-next\"  // TypeScript 개발 시 추가&#xD;\r\n]&#xD;\r\n```&#xD;\r\n&#xD;\r\n**④ 포트 포워딩 설정**&#xD;\r\n&#xD;\r\n```json&#xD;\r\n\"forwardPorts\": [3000, 8080],  // 웹 서버 포트 자동 포워딩&#xD;\r\n\"portsAttributes\": {&#xD;\r\n  \"3000\": {&#xD;\r\n    \"label\": \"Frontend\",&#xD;\r\n    \"onAutoForward\": \"notify\"  // 알림만 표시&#xD;\r\n  },&#xD;\r\n  \"9092\": {&#xD;\r\n    \"onAutoForward\": \"ignore\"  // 자동 포워딩 완전 차단&#xD;\r\n  }&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&#xD;\r\n&gt; **중요**: 자동 포트 포워딩이 로컬 테스트를 방해할 수 있으므로, 필요한 포트만 명시적으로 설정하는 것을 권장합니다.&#xD;\r\n&#xD;\r\n**⑤ 환경 변수 설정**&#xD;\r\n&#xD;\r\n```json&#xD;\r\n\"remoteEnv\": {&#xD;\r\n  \"NODE_ENV\": \"development\",&#xD;\r\n  \"API_BASE_URL\": \"http://localhost:8080\",&#xD;\r\n  \"CUSTOM_VAR\": \"your-value\"&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&#xD;\r\n**⑥ 패키지 설치 순서**&#xD;\r\n&#xD;\r\n```bash&#xD;\r\n# postCreateCommand에서 패키지 설치는 반드시 방화벽 설정 전에 실행&#xD;\r\n\"postCreateCommand\": \"pip install pandas numpy matplotlib &amp;&amp; sudo /usr/local/bin/init-firewall.sh\"&#xD;\r\n```&#xD;\r\n&#xD;\r\n#### **주요 변경사항**(공식 설정 대비)&#xD;\r\n&#xD;\r\n* 타임존을 `Asia/Seoul`로 변경&#xD;\r\n* Java 21 및 Gradle 지원&#xD;\r\n* Python 3.11 지원&#xD;\r\n* 자동 포트 포워딩 방지 설정&#xD;\r\n* pandas 패키지 자동 설치(필요한 패키지 예시)&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n### 3. 보안 고려 사항&#xD;\r\n#### **중요한 보안 경고** (Claude 공식 문서)&#xD;\r\n&#xD;\r\n&gt; devcontainer가 상당한 보호 기능을 제공하지만, 모든 공격에 완전히 면역인 시스템은 없습니다. `--dangerously-skip-permissions`로 실행될 때, devcontainer는 악성 프로젝트가 Claude Code 자격 증명을 포함하여 devcontainer에서 액세스 가능한 모든 것을 유출하는 것을 방지하지 않습니다. 신뢰할 수 있는 저장소로 개발할 때만 devcontainer를 사용하는 것을 권장합니다.&#xD;\r\n&#xD;\r\n#### **안전한 사용 지침**&#xD;\r\n&#xD;\r\n1. 신뢰할 수 있는 프로젝트에서만 사용&#xD;\r\n2. 민감한 자격 증명은 컨테이너 외부에 보관&#xD;\r\n3. 정기적인 컨테이너 재빌드로 환경 초기화&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n### 4. 네트워크 보안 구현&#xD;\r\n&#xD;\r\n#### **방화벽 스크립트**(init-firewall.sh)&#xD;\r\n&#xD;\r\n```bash&#xD;\r\n#!/bin/bash&#xD;\r\nset -euo pipefail&#xD;\r\n&#xD;\r\n# 기존 규칙 초기화&#xD;\r\niptables -F&#xD;\r\nipset destroy allowed-domains 2&gt;/dev/null || true&#xD;\r\n&#xD;\r\n# 기본 허용(DNS, localhost)&#xD;\r\niptables -A OUTPUT -p udp --dport 53 -j ACCEPT&#xD;\r\niptables -A INPUT -i lo -j ACCEPT&#xD;\r\niptables -A OUTPUT -o lo -j ACCEPT&#xD;\r\n&#xD;\r\n# 허용 도메인 설정&#xD;\r\nipset create allowed-domains hash:net&#xD;\r\n&#xD;\r\n# GitHub IP 범위 동적 추가&#xD;\r\ngh_ranges=$(curl -s https://api.github.com/meta)&#xD;\r\necho \"$gh_ranges\" | jq -r '(.web + .api + .git)[]' | \\&#xD;\r\nwhile read -r cidr; do&#xD;\r\n    ipset add allowed-domains \"$cidr\" -exist&#xD;\r\ndone&#xD;\r\n&#xD;\r\n# 필수 도메인 및 gemini CLI와 관련된 설정 &#xD;\r\nfor domain in \\&#xD;\r\n    \"registry.npmjs.org\" \\&#xD;\r\n    \"api.anthropic.com\" \\&#xD;\r\n    \"sentry.io\" \\&#xD;\r\n    \"statsig.anthropic.com\" \\&#xD;\r\n    \"statsig.com\" \\&#xD;\r\n    \"marketplace.visualstudio.com\" \\&#xD;\r\n    \"vscode.blob.core.windows.net\" \\&#xD;\r\n    \"update.code.visualstudio.com\" \\&#xD;\r\n    \"accounts.google.com\" \\&#xD;\r\n    \"oauth2.googleapis.com\" \\&#xD;\r\n    \"generativelanguage.googleapis.com\"; do&#xD;\r\n    &#xD;\r\n    ips=$(dig +short A \"$domain\")&#xD;\r\n    echo \"$ips\" | while read -r ip; do&#xD;\r\n        ipset add allowed-domains \"$ip\" -exist&#xD;\r\n    done&#xD;\r\ndone&#xD;\r\n&#xD;\r\n# ========== 사용자 정의 도메인/IP 추가 영역 ==========&#xD;\r\n# 추가로 허용하고 싶은 도메인이 있다면 아래에 추가하세요.&#xD;\r\nADDITIONAL_DOMAINS=(&#xD;\r\n    # \"your-company-api.com\"&#xD;\r\n    # \"custom-service.net\"&#xD;\r\n)&#xD;\r\n&#xD;\r\nfor domain in \"${ADDITIONAL_DOMAINS[@]}\"; do&#xD;\r\n    if [ -n \"$domain\" ]; then&#xD;\r\n        echo \"Adding custom domain: $domain\"&#xD;\r\n        ips=$(dig +short A \"$domain\")&#xD;\r\n        echo \"$ips\" | while read -r ip; do&#xD;\r\n            ipset add allowed-domains \"$ip\" -exist&#xD;\r\n        done&#xD;\r\n    fi&#xD;\r\ndone&#xD;\r\n&#xD;\r\n# 특정 IP 직접 추가&#xD;\r\nADDITIONAL_IPS=(&#xD;\r\n    # \"192.168.1.100\"&#xD;\r\n    # \"10.0.0.50\"&#xD;\r\n)&#xD;\r\n&#xD;\r\nfor ip in \"${ADDITIONAL_IPS[@]}\"; do&#xD;\r\n    if [ -n \"$ip\" ]; then&#xD;\r\n        echo \"Adding custom IP: $ip\"&#xD;\r\n        ipset add allowed-domains \"$ip\" -exist&#xD;\r\n    fi&#xD;\r\ndone&#xD;\r\n# ===============================================&#xD;\r\n&#xD;\r\n# 기본 라우트에서 호스트 IP 가져오기&#xD;\r\nHOST_IP=$(ip route | grep default | cut -d\" \" -f3)&#xD;\r\nif [ -z \"$HOST_IP\" ]; then&#xD;\r\n    echo \"ERROR: Failed to detect host IP\"&#xD;\r\n    exit 1&#xD;\r\nfi&#xD;\r\n&#xD;\r\nHOST_NETWORK=$(echo \"$HOST_IP\" | sed \"s/\\.[0-9]*$/.0\\/24/\")&#xD;\r\necho \"Host network detected as: $HOST_NETWORK\"&#xD;\r\n&#xD;\r\n# 나머지 iptables 규칙 설정&#xD;\r\niptables -A INPUT -s \"$HOST_NETWORK\" -j ACCEPT&#xD;\r\niptables -A OUTPUT -d \"$HOST_NETWORK\" -j ACCEPT&#xD;\r\n&#xD;\r\n# 기본 정책을 DROP으로 먼저 설정&#xD;\r\niptables -P INPUT DROP&#xD;\r\niptables -P FORWARD DROP&#xD;\r\niptables -P OUTPUT DROP&#xD;\r\n&#xD;\r\n# 이미 승인된 트래픽에 대한 기존 연결 먼저 허용&#xD;\r\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT&#xD;\r\niptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT&#xD;\r\n&#xD;\r\n# 그 다음 허용된 도메인에 대한 특정 아웃바운드 트래픽만 허용&#xD;\r\niptables -A OUTPUT -m set --match-set allowed-domains dst -j ACCEPT&#xD;\r\n&#xD;\r\necho \"Firewall configuration complete\"&#xD;\r\necho \"Verifying firewall rules...\"&#xD;\r\nif curl --connect-timeout 5 https://example.com &gt;/dev/null 2&gt;&amp;1; then&#xD;\r\n    echo \"ERROR: Firewall verification failed - was able to reach https://example.com\"&#xD;\r\n    exit 1&#xD;\r\nelse&#xD;\r\n    echo \"Firewall verification passed - unable to reach https://example.com as expected\"&#xD;\r\nfi&#xD;\r\n&#xD;\r\n# GitHub API 접근 확인&#xD;\r\nif ! curl --connect-timeout 5 https://api.github.com/zen &gt;/dev/null 2&gt;&amp;1; then&#xD;\r\n    echo \"ERROR: Firewall verification failed - unable to reach https://api.github.com\"&#xD;\r\n    exit 1&#xD;\r\nelse&#xD;\r\n    echo \"Firewall verification passed - able to reach https://api.github.com as expected\"&#xD;\r\nfi&#xD;\r\n```&#xD;\r\n&#xD;\r\n#### **커스터마이징 방법**&#xD;\r\n&#xD;\r\n* `ADDITIONAL_DOMAINS` 배열에 허용하고 싶은 도메인 추가&#xD;\r\n* `ADDITIONAL_IPS` 배열에 특정 IP 주소 직접 추가&#xD;\r\n* 주석 처리된 예시를 참고하여 필요한 항목만 활성화&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n### 5. VS Code에서 환경 실행&#xD;\r\n&#xD;\r\n![devContainer_4.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer4.png)&#xD;\r\n&#xD;\r\nDev Container 환경 설정은 VS Code 공식 문서의 [Development Containers](https://code.visualstudio.com/docs/devcontainers/containers) 가이드를 참고할 수 있습니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n#### **실행 단계**&#xD;\r\n&#xD;\r\n![devContainer_5.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer5.png)&#xD;\r\n① VS Code에서 프로젝트 폴더 열기&#xD;\r\n&#xD;\r\n② 좌하단 **Open a Remote Window** 버튼 클릭&#xD;\r\n&#xD;\r\n![devContainer_6.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer6.png)&#xD;\r\n③ **Reopen in Container** 선택&#xD;\r\n&#xD;\r\n![devContainer_7.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer7.png)&#xD;\r\n④ 컨테이너 빌드 완료 및 방화벽 정상작동 확인 후 터미널에서 `claude --dangerously-skip-permissions` 실행&#xD;\r\n&#xD;\r\n![devContainer_8.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer8.png)&#xD;\r\n&#xD;\r\n⑤ 필요시 Gemini CLI도 확인&#xD;\r\n![devContainer_9.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer9.png)&#xD;\r\n&#xD;\r\n⑥ 다시 로컬로 돌아가려면 **Reopen Folder Locally** 버튼 클릭&#xD;\r\n![devContainer_10.png](https://image.toast.com/aaaadh/real/2025/techblog/devContainer10.png)&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n### 6\\. 환경별 추가 설정&#xD;\r\n&#xD;\r\n#### **Lima (macOS)**&#xD;\r\n&#xD;\r\n```yaml&#xD;\r\n# ~/.lima/&lt;실제 사용 instance 이름&gt;/lima.yaml&#xD;\r\nmounts:&#xD;\r\n  - location: \"~/workspace/project\" # 사용할 프로젝트 폴더 위치&#xD;\r\n    writable: true  # writable만 true로 설정&#xD;\r\n```&#xD;\r\n&#xD;\r\n#### **Docker Desktop**&#xD;\r\n별도 설정 불필요 - Dev Container가 자동 처리&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 모니터링 및 유지보수&#xD;\r\n&#xD;\r\n### 보안 점검 사항&#xD;\r\n&#xD;\r\n#### **정기 검토(월 1회)**&#xD;\r\n&#xD;\r\n* 허용 도메인 목록 재검토&#xD;\r\n* Claude Code 버전 및 보안 업데이트 확인&#xD;\r\n* 네트워크 접속 로그 검토&#xD;\r\n&#xD;\r\n#### **이상 징후 모니터링**&#xD;\r\n&#xD;\r\n* 예상치 못한 네트워크 연결 시도&#xD;\r\n* 권한 에스컬레이션 시도&#xD;\r\n* 대용량 데이터 전송&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n### 복구 전략&#xD;\r\n&#xD;\r\n#### **문제 발생 시 대응**&#xD;\r\n&#xD;\r\n1. **컨테이너 재빌드**: VS Code Command Palette에서 **Dev Containers: Rebuild Container** 실행(가장 안전)&#xD;\r\n2. **Git 기반 복구**: 버전 관리된 파일들을 이전 상태로 되돌리기&#xD;\r\n&#xD;\r\n&gt; **중요**: Git 명령어 사용 시 커밋하지 않은 변경사항은 영구 손실될 수 있으므로, 중요한 작업이 있다면 사전에 백업하거나 커밋해 두어야 합니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 보안성 vs 편의성 분석&#xD;\r\n&#xD;\r\n| 설정 방식 | 보안성 | 편의성 | 복구 용이성 |&#xD;\r\n| ----- | --- | --- | ------ |&#xD;\r\n| 로컬 직접 실행 | 낮음&lt;br&gt;전체 시스템 노출 | 높음 | 어려움 |&#xD;\r\n| Dev Container + 방화벽 | 높음&lt;br&gt;프로세스 격리 | 보통 | 쉬움 |&#xD;\r\n| 완전 격리 VM | 매우 높음&lt;br&gt;하드웨어 격리 | 낮음 | 복잡 |&#xD;\r\n&#xD;\r\n&gt; **참고**: 성능 영향은 개발자의 하드웨어 환경, 프로젝트 규모, 사용 패턴에 따라 개인차가 클 수 있습니다.&#xD;\r\n&#xD;\r\n## 모범 사례&#xD;\r\n&#xD;\r\n### 일상적인 사용 지침&#xD;\r\n&#xD;\r\n#### **프로젝트 시작 전**&#xD;\r\n&#xD;\r\n1. 최신 커밋 상태 확인&#xD;\r\n2. 중요 파일 백업 확인&#xD;\r\n3. 컨테이너 환경 상태 점검&#xD;\r\n&#xD;\r\n#### **작업 중**&#xD;\r\n&#xD;\r\n1. 정기적인 Git 커밋&#xD;\r\n2. AI 제안 사항 검토 후 적용&#xD;\r\n3. 의심스러운 명령어 실행 전 확인&#xD;\r\n&#xD;\r\n#### **작업 완료 후**&#xD;\r\n&#xD;\r\n1. 변경 사항 최종 검토&#xD;\r\n2. 테스트 실행 및 검증&#xD;\r\n3. 원격 저장소에 Push&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 나가며&#xD;\r\n&#xD;\r\nAI 코딩 도구의 혁신적인 기능을 안전하게 활용하기 위해서는 적절한 격리 환경이 필수입니다. Dev Container 기반 접근법은 보안과 편의성 사이의 최적 균형점을 제공하며, 현대적인 개발 워크플로우에 자연스럽게 통합됩니다.&#xD;\r\n&#xD;\r\n조직에서 AI 도구 도입을 고려할 때 다음 원칙을 준수하기를 권장합니다.&#xD;\r\n&#xD;\r\n1. **격리된 환경에서의 작업**: 민감한 데이터와 AI 도구 분리&#xD;\r\n2. **지속적인 백업**: Git을 통한 정기적 상태 저장&#xD;\r\n3. **모니터링 체계**: 이상 행동 탐지 및 대응 방안 수립&#xD;\r\n4. **팀 교육**: AI 도구의 한계와 위험성에 대한 인식 공유&#xD;\r\n&#xD;\r\n이러한 접근을 통해 AI의 강력함을 누리면서도 조직의 보안과 안정성을 동시에 확보할 수 있습니다.&#xD;\r\n&#xD;\r\n&#xD;\r\n이 글은 NHN Cloud의 AI 보안 강화 노력의 일환으로 작성되었습니다. 긴 글을 읽어 주셔서 감사합니다. &#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n### 참고 문헌&#xD;\r\n&#xD;\r\n•\tClaud Docs, 개발 컨테이너, https://docs.claude.com/ko/docs/claude-code/devcontainer&#xD;\r\n•\tVisual Studio Code, Developing inside a Container, https://code.visualstudio.com/docs/devcontainers/containers&#xD;\r\n•\tClaude Code GitHub Repository, https://github.com/anthropics/claude-code&#xD;\r\n•\tDevelopment Containers, https://containers.dev/&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n[![NHN Cloud_meetup banner_footer_202509.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerfooter202509.png)](https://www.nhncloud.com/kr)",
    "date": "2025-09-30T00:13:38.000Z",
    "url": "https://meetup.nhncloud.com/posts/396"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "Kubernetes CPU Limit을 사용하면 벌어지는 일",
    "partialText": "[![NHN Cloud_meetup banner_K8s CPU limit_202509-01.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerK8s%20CPU%20limit20250901.png)](https://www.nhncloud.com/kr)&#xD;\r\n&#xD;\r\n## 들어가며&#xD;\r\n오늘날 대부분의 서비스가 컨테이너 환경을 이용하고 있고, 컨테이너를 실행하는 환경으로는 Kubernetes가 표준으로 자리 잡고 있습니다. Kubernetes에서 컨테이너를 실행할 때는 Pod를 사용하는데요. Pod를 사용할 때 컨테이너의 리소스를 얼마나 할당할 것인가는 클러스터의 안정성과 연결되어 있기 때문에 중요한 문제 중 하나입니다. Pod의 컴퓨팅 리소스는 보통 다음과 같이 **requests**와 **limit**으로 설정할 수 있습니다.&#xD;\r\n&#xD;\r\n```&#xD;\r\napiVersion: v1&#xD;\r\nkind: Pod&#xD;\r\nmetadata:&#xD;\r\n  name: frontend&#xD;\r\nspec:&#xD;\r\n  containers:&#xD;\r\n  - name: app&#xD;\r\n    image: images.my-company.example/app:v4&#xD;\r\n    resources:&#xD;\r\n      requests:&#xD;\r\n        memory: \"64Mi\"&#xD;\r\n        cpu: \"250m\"&#xD;\r\n      limits:&#xD;\r\n        memory: \"128Mi\"&#xD;\r\n        cpu: \"500m\"&#xD;\r\n  - name: log-aggregator&#xD;\r\n    image: images.my-company.example/log-aggregator:v6&#xD;\r\n    resources:&#xD;\r\n      requests:&#xD;\r\n        memory: \"64Mi\"&#xD;\r\n        cpu: \"250m\"&#xD;\r\n      limits:&#xD;\r\n        memory: \"128Mi\"&#xD;\r\n        cpu: \"500m\"&#xD;\r\n&#xD;\r\n```&#xD;\r\n&lt;br&gt;&#xD;\r\n리소스를 설정할 때 우리는 보통 메모리를 중심으로 정하는데요, 컨테이너의 메모리 사용량이 한계값에 도달하면 Pod는 재실행됩니다.&#xD;\r\n그렇다면, CPU 사용량의 경우에는 어떨까요? 자주 사용되진 않지만 한 번쯤 알아두면 좋은 CPU 사용량 제한에 대해 알아보았습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n## Kubernetes CPU Resource 설정&#xD;\r\n먼저 Pod의 Resource 항목에서 설정 가능한 CPU의 Request와 Limit, 그리고 단위에 대해 알아보도록 하겠습니다.&#xD;\r\n&#xD;\r\n### 1. CPU Requests&#xD;\r\nCPU requests는 컨테이너가 정상적으로 실행하기 위한 최소한의 CPU 양을 의미합니다. requests는 kube-scheduler가 Pod를 노드에 할당하는 스케줄링 작업에서 사용합니다. kube-scheduler는 Pod의 requests 값을 합산하여 할당 가능한 노드를 찾아서 Pod를 배치합니다. 노드에 Pod의 requests를 수용할 만한 여유가 있어야 할당이 되는 것이죠. 이 조건을 만족하는 노드가 없다면 Pod는 pending 상태로 스케줄링되지 않습니다.&#xD;\r\nPod가 특정 노드에 스케줄링되었다면 요청된 CPU의 양은 보장됩니다. 이 말은 requests의 양만큼 CPU를 항상 점유한다는 뜻은 아닙니다. CPU 사용에 경합이 발생했을 때도 요청한 만큼의 CPU 시간을 할당 받는 것을 보장합니다. requests의 값이 없다면 Pod가 비효율적으로 배치될 수 있고 필요 이상의 클러스터 자원을 사용하여 불필요한 비용 지출이 발생할 수 있습니다.&#xD;\r\n&#xD;\r\n### 2. CPU Limits&#xD;\r\nCPU limits는 컨테이너가 사용할 수 있는 CPU의 절대적인 최댓값을 의미하며 kubelet이 관리합니다. Pod의 컨테이너가 limits를 초과하여 CPU를 사용하려 할 때 해당 컨테이너의 CPU 사용을 인위적으로 낮추는 스로틀링(Throttling)을 통해 상한선을 강제합니다. limits는 여러 서비스가 동시에 실행되고 있는 Kubernetes 클러스터에서 하나의 컨테이너가 CPU를 과점하여 다른 컨테이너의 성능에 영향을 주거나 노드의 안정성을 해치는 CPU 기아 상태를 방지하는 데 의미가 있습니다.&#xD;\r\n&#xD;\r\n### 3. CPU Unit&#xD;\r\nKubernetes에서 CPU의 단위는 절대적인 양으로 사용되며 1 Kubernetes CPU는 1vCPU 또는 물리적인 1 CPU 코어의 컴퓨팅 파워와 동일한 것으로 간주합니다.&#xD;\r\nKubernetes에서는 코어를 밀리코어(millicore)로 더 작게 나누어 설정할 수 있습니다. 1000m은 1 CPU와 동일하며 0.5 CPU는 500m과 같습니다.&#xD;\r\n&#xD;\r\n### 4. QoS(quality of service, 서비스 품질) 클래스&#xD;\r\nKubernetes는 설정한 requests와 limits에 따라서 자동으로 QoS 클래스를 할당합니다.&#xD;\r\n• **Guaranteed (보장)**: Pod 내의 모든 컨테이너가 CPU와 메모리에 대해 requests와 limits를 모두 설정하고, 그 값이 서로 동일할 때(requests.cpu == limits.cpu) 할당됩니다. 이 Pod들은 가장 높은 우선순위를 가지며, 노드에 리소스 압박이 발생했을 때 가장 마지막에 축출(eviction)됩니다.&#xD;\r\n• **Burstable (버스트 가능)**: Pod 내에 최소 하나 이상의 컨테이너가 CPU 또는 메모리 requests를 설정했지만, Guaranteed 클래스의 조건을 충족하지 못할 때 할당됩니다(예: requests.cpu &lt; limits.cpu). 이 Pod들은 노드에 여유 리소스가 있을 경우, 요청한 양보다 더 많은 리소스를 \"버스트(burst)\"하여 사용할 수 있습니다.&#xD;\r\n• **BestEffort (최선 노력)**: Pod 내의 어떤 컨테이너도 CPU나 메모리에 대한 requests나 limits를 설정하지 않았을 때 할당됩니다. 이 Pod들은 가장 낮은 우선순위를 가지며, 노드 리소스가 부족해지면 가장 먼저 축출 대상이 됩니다. &#xD;\r\n&lt;br&gt;&#xD;\r\n## 리눅스 커널의 CPU 관리 메커니즘&#xD;\r\nKubernetes에서 설정한 requests와 limits를 리눅스 커널이 어떻게 실제로 CPU를 할당하고 제한하는지 알아보도록 하겠습니다. 여기에는 컨테이너 기술을 탄생시킨 cgroup(Control Group)과 CFS(Completely Fair Scheduler)가 사용됩니다.&#xD;\r\n&#xD;\r\n### 1. 리눅스 컨트롤 그룹(cgroup)&#xD;\r\ncgroup은 프로세스들의 집합에 대해 CPU, 메모리, I/O와 같은 시스템 리소스의 사용량을 제한하고, 추적하며, 격리합니다. cgroup은 /sys/fs/cgroup/이라는 가상 파일 시스템 내에 계층적 구조로 구성됩니다. Kubernetes는 이 구조 내에 kubepods.slice라는 전용 경로를 만들어 Pod들의 리소스를 관리합니다.&#xD;\r\nCPU 리소스 관리를 담당하는 cgroup의 특정 모듈을 ‘컨트롤러’ 또는 ‘서브시스템’이라 부르며, Kubernetes가 CPU requests와 limits를 구현하기 위해 사용하는 것이 바로 CPU 서브시스템입니다.&#xD;\r\n&#xD;\r\n### 2. Completely Fair Scheduler(CFS)&#xD;\r\nCFS는 리눅스 커널의 기본 프로세스 스케줄러로, 그 이름처럼 ‘완전한 공정성’을 목표로 합니다. CFS는 마치 ‘이상적인 멀티태스킹 CPU’가 존재하는 것처럼, 실행 가능한 모든 태스크(프로세스)가 정확히 동일한 비율의 CPU 시간을 할당 받도록 노력합니다.&#xD;\r\n실제 하드웨어는 한 번에 하나의 작업만 실행할 수 있기 때문에, CFS는 ‘가상 런타임(virtual runtime, vruntime)’이라는 개념을 사용합니다. CFS는 항상 가장 작은 vruntime 값을 가진 작업, 즉 지금까지 가장 적게 실행된 작업을 선택하여 실행함으로써 장기적인 관점에서 공정성을 보장합니다.&#xD;\r\n&#xD;\r\n### 3. Kubernetes와 커널의 매핑&#xD;\r\nkubelet은 Kubernetes의 yaml 명세를 실제 커널에 적용하기 위해서 변환 작업을 수행합니다. kubelet은 resources 설정을 읽어 해당 컨테이너의 cgroup 디렉터리 내 특정 파일에 값을 덮어쓰는 방식으로 커널에 지시를 내립니다.&#xD;\r\n&#xD;\r\n#### **3.1. Requests와 cpu.shares: 상대적 가중치 시스템**&#xD;\r\nPod의 resources.requests.cpu 값은 cgroup의 cpu.shares 파일 값으로 변환됩니다. 공식은 다음과 같습니다.&#xD;\r\n```&#xD;\r\ncpu.shares=requests.cpu (millicores)×1024/1000.&#xD;\r\n```&#xD;\r\n예를 들어, 1000m(1 코어) 요청은 1024 shares로, 500m 요청은 512 shares로 변환됩니다. 가장 중요한 점은 cpu.shares가 **노드에 CPU 경합이 있을 때만 의미를 가지는 상대적 가중치**라는 것입니다. 만약 CPU 자원을 두고 경쟁하는 두 컨테이너가 있고, 하나는 2048 shares, 다른 하나는 1024 shares를 가지고 있다면, 전자는 후자보다 두 배의 CPU 시간을 할당 받게 됩니다. 하지만 노드가 유휴 상태이고 CPU 경합이 없다면, 컨테이너는 자신의 shares 값과 무관하게 필요한 만큼의 CPU를 사용할 수 있습니다.&#xD;\r\n&#xD;\r\n#### **3.2. Limits와 cpu.cfs_period_us &amp; cpu.cfs_quota_us: 절대적 시간 할당량 시스템**&#xD;\r\nPod의 resources.limits.cpu 값은 CFS 대역폭 제어라는 메커니즘을 통해 강제됩니다. 이 메커니즘은 두 가지 파라미터에 의해서 결정됩니다.&#xD;\r\n• cpu.cfs_period_us: 할당량을 정산하는 주기로 단위는 마이크로초입니다. Kubernetes는 기본값인 100000(즉 100ms)을 사용합니다. 이 한 window 내에서 할당량이 정해집니다.&#xD;\r\n• cpu.cfs_quota_us: 위에서 정의된 period 동안 cgroup이 소비할 수 있는 총 CPU 시간을 정의합니다. 단위는 마이크로초입니다. 이 값은 resources.limitscpu로부터 계산됩니다. limits가 없을 경우 -1로 할당량 없음을 의미합니다.&#xD;\r\n&#xD;\r\n변환 공식은 다음과 같습니다.&#xD;\r\n```&#xD;\r\ncpu.cfs_quota_us=limits.cpu (cores)×cpu.cfs_period_us.&#xD;\r\n```&#xD;\r\n예를 들어, limits.cpu를 500m(0.5 코어)로 설정하면, cpu.cfs_quota_us=0.5×100000=50000이 됩니다. 이는 해당 컨테이너가 매 100ms 주기마다 최대 50,000 마이크로초(50ms)의 CPU 시간만 사용할 수 있음을 의미합니다.&#xD;\r\n&#xD;\r\n#### 요약&#xD;\r\n| Kubernetes 설정 | Kubernetes에서의 목적 | 리눅스 cgroup 파일 | 동작 |&#xD;\r\n| --- | --- | --- | --- |&#xD;\r\n| resources.requests.cpu | 스케줄링 및 경합 시 최소 CPU 보장 | cpu.shares | 상대적 가중치; CPU 경합 시에만 활성화 |&#xD;\r\n| resources.lmits.cpu | 런타임 시 최대 CPU사용량 제한 | cpu.cfs_quota_us | 절대적 시간 할당량; 항상 활성화, 스로틀링 발생 |&#xD;\r\n&lt;br&gt;&#xD;\r\n## Limits 적용으로 발생할 수 있는 현상&#xD;\r\nCPU limits를 설정했을 때 발생하는 가장 중요하고 종종 오해 받는 현상이 바로 CPU 스로틀링입니다. 스로틀링은 단순히 성능을 약간 늦추는 것이 아니라, 애플리케이션의 지연 시간에 심각하고 예측 불가능한 영향을 미칠 수 있는 ‘정지-대기(stop-wait)’ 프로세스입니다.&#xD;\r\n&#xD;\r\n### 1. CPU 스로틀링과 발생 원인&#xD;\r\nCPU 스로틀링은 컨테이너 내의 프로세스들이 현재의 cfs_period_us(보통 100ms) 동안 할당된 cfs_quota_us를 모두 소진했을 때 발생합니다. 할당량을 모두 사용한 컨테이너의 프로세스들은 커널 스케줄러에 의해 실행이 '정지'됩니다. 그리고 다음 100ms 주기가 시작되어 할당량이 다시 채워질 때까지 대기해야 합니다.&#xD;\r\n이 현상은 특히 멀티 스레드 애플리케이션에서 증폭되어 나타납니다. 예를 들어, 한 컨테이너가 1 코어(cfs_quota_us=100000)의 limit을 가지고 있지만, 4개의 바쁜 스레드를 동시에 실행한다고 가정해 봅시다.&#xD;\r\n이 컨테이너는 4개의 코어를 동시에 사용하여 단 25ms의 실제 시간만에 100ms의 CPU 시간 할당량을 모두 소진할 수 있습니다. 그 후, 해당 컨테이너는 남은 75ms 동안 노드에 유휴 코어가 있더라도 완전히 스로틀링되어 아무 작업도 수행할 수 없게 됩니다.&#xD;\r\n![K8s_CPU limit_1.png](https://image.toast.com/aaaadh/real/2025/techblog/K8sCPU%20limit1.png)&#xD;\r\n&#xD;\r\n### 2. CPU 스로틀링으로 인한 지연 시간 증가&#xD;\r\n![K8s_CPU limit_2.png](https://image.toast.com/aaaadh/real/2025/techblog/K8sCPU%20limit2.png)&#xD;\r\n스로틀링은 애플리케이션 요청 처리 시간에 직접적으로 지연을 추가합니다. 예를 들어, 어떤 작업을 완료하는 데 순수하게 300ms의 CPU 시간이 필요한 애플리케이션이 100ms 주기당 50ms의 limit에 의해 제한된다고 가정해 봅시다. 이 작업은 다른 시스템 부하가 전혀 없더라도 최소 6개의 주기, 즉 600ms의 실제 시간이 걸려야 완료될 수 있습니다. 이러한 지연은 타임아웃, 연쇄적인 장애, 그리고 궁극적으로는 나쁜 사용자 경험으로 이어질 수 있습니다.&#xD;\r\n스로틀링은 전통적인 CPU 사용률 지표로는 확인하기가 힘든 경우가 있습니다. 어떤 컨테이너가 CPU 사용률 50%(자신의 limit 값)를 보이고 있더라도, 실제로는 심각하게 스로틀링되어 매우 느린 상태일 수 있습니다. 이 경우 CPU는 전통적인 의미에서 '최대치로 사용'되는 것이 아니라, 인위적으로 억제되고 있는 상태입니다.&#xD;\r\n&#xD;\r\n&#xD;\r\n### 3. '시끄러운 이웃' 오해&#xD;\r\nlimits가 ‘시끄러운 이웃(noisy neighbor)’ 문제, 즉 하나의 애플리케이션이 리소스를 독점하여 다른 애플리케이션에 영향을 주는 것을 막아 줄 수 있을 것처럼 보입니다. 하지만 실제로는 requests에 의해 결정되는 cpu.shares가 경합 상황에서도 적절하게 리소스를 배분할 수 있는 시스템이라고 할 수 있습니다. 만약 모든 Pod에 적절한 requests가 설정되어 있다면, CFS 스케줄러는 shares 값에 비례하여 CPU 시간을 분배함으로써 특정 Pod가 다른 Pod들이 기아 상태에 빠지는 것을 방지합니다. 반면 limits는 다른 누구도 CPU를 필요로 하지 않는 상황에서조차 Pod의 사용량을 제한하는 무딘 도구에 가깝습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n## 스로틀링 테스트&#xD;\r\n테스트를 위해 한 웹 애플리케이션을 만들었습니다. 이 애플리케이션에 1 CPU를 할당하면 작업을 완료하는 데 대략 12초 정도 걸립니다.&#xD;\r\n이 애플리케이션에 각각 1 CPU, 0.1 CPU를 할당하여 CPU 사용량과 작업 시간을 확인하여 지금까지 확인한 현상이 발생하는지 테스트해 보았습니다.&#xD;\r\n&#xD;\r\n### 테스트용 Pod 준비&#xD;\r\n아래와 같이 CPU limit만 다르게 설정하여 Pod를 생성하였습니다.&#xD;\r\n```&#xD;\r\napiVersion: apps/v1&#xD;\r\nkind: Deployment&#xD;\r\nmetadata:&#xD;\r\n  name: cpu-test-app&#xD;\r\n  labels:&#xD;\r\n    app: cpu-test-app&#xD;\r\nspec:&#xD;\r\n  replicas: 1&#xD;\r\n  selector:&#xD;\r\n    matchLabels:&#xD;\r\n      app: cpu-test-app&#xD;\r\n  template:&#xD;\r\n    metadata:&#xD;\r\n      labels:&#xD;\r\n        app: cpu-test-app&#xD;\r\n    spec:&#xD;\r\n      containers:&#xD;\r\n      - name: cpu-test-app&#xD;\r\n        image: cpu-test-app&#xD;\r\n        ports:&#xD;\r\n        - containerPort: 8081&#xD;\r\n        resources:&#xD;\r\n          requests:&#xD;\r\n            memory: \"64Mi\"&#xD;\r\n            cpu: \"100m\"    # 0.1 코어&#xD;\r\n          limits:&#xD;\r\n            memory: \"128Mi\"&#xD;\r\n            cpu: \"100m\"    # 0.1 코어로 제한&#xD;\r\n        livenessProbe:&#xD;\r\n          httpGet:&#xD;\r\n            path: /health&#xD;\r\n            port: 8080&#xD;\r\n          initialDelaySeconds: 10&#xD;\r\n          periodSeconds: 30&#xD;\r\n        readinessProbe:&#xD;\r\n          httpGet:&#xD;\r\n            path: /health&#xD;\r\n            port: 8080&#xD;\r\n          initialDelaySeconds: 5&#xD;\r\n          periodSeconds: 10&#xD;\r\n---&#xD;\r\n# 1 코어 제한 버전&#xD;\r\napiVersion: apps/v1&#xD;\r\nkind: Deployment&#xD;\r\nmetadata:&#xD;\r\n  name: cpu-test-app-1core&#xD;\r\n  labels:&#xD;\r\n    app: cpu-test-app-1core&#xD;\r\nspec:&#xD;\r\n  replicas: 1&#xD;\r\n  selector:&#xD;\r\n    matchLabels:&#xD;\r\n      app: cpu-test-app-1core&#xD;\r\n  template:&#xD;\r\n    metadata:&#xD;\r\n      labels:&#xD;\r\n        app: cpu-test-app-1core&#xD;\r\n    spec:&#xD;\r\n      containers:&#xD;\r\n      - name: cpu-test-app&#xD;\r\n        image: cpu-test-app&#xD;\r\n        ports:&#xD;\r\n        - containerPort: 8080&#xD;\r\n        resources:&#xD;\r\n          requests:&#xD;\r\n            memory: \"64Mi\"&#xD;\r\n            cpu: \"1000m\"   # 1 코어&#xD;\r\n          limits:&#xD;\r\n            memory: \"128Mi\"&#xD;\r\n            cpu: \"1000m\"   # 1 코어로 제한&#xD;\r\n        livenessProbe:&#xD;\r\n          httpGet:&#xD;\r\n            path: /health&#xD;\r\n            port: 8080&#xD;\r\n          initialDelaySeconds: 10&#xD;\r\n          periodSeconds: 30&#xD;\r\n        readinessProbe:&#xD;\r\n          httpGet:&#xD;\r\n            path: /health&#xD;\r\n            port: 8080&#xD;\r\n          initialDelaySeconds: 5&#xD;\r\n          periodSeconds: 10&#xD;\r\n```&#xD;\r\n&#xD;\r\n### 응답 시간 비교&#xD;\r\n0.1 CPU를 할당한 애플리케이션에서는 122초가 소요된 반면 1 CPU가 할당된 애플리케이션에서는 11.51초만 소요된 것을 확인할 수 있었습니다.&#xD;\r\n![K8s_CPU limit_3.png](https://image.toast.com/aaaadh/real/2025/techblog/K8sCPU%20limit3.png)&#xD;\r\n&#xD;\r\n### 그라파나를 통한 스로틀링 현상 확인&#xD;\r\n* &lt;span style=\"background-color:#DCFFE4\"&gt;초록색: 1 CPU&lt;/span&gt;&#xD;\r\n* &lt;span style=\"background-color:#fff5b1\"&gt;노란색: 0.1 CPU&lt;/span&gt;&#xD;\r\n&#xD;\r\nCPU 사용률에서 노란색 그래프가 CPU limits가 0.1로 설정되어 그 이상 사용하지 못하는 모습을 보여줍니다. CPU 할당 횟수에서 노란색이 Limits에 걸려서 더 많은 cpu 할당이 발생한 것을 확인할 수 있습니다. 이것은 스로틀링으로 인한 지연 시간 증가 시뮬레이션과 일치하는 결과입니다. 당연하게도 스로틀링 비율도 노란색이 더 높은 것을 알 수 있습니다.&#xD;\r\n![K8s_CPU limit_4.png](https://image.toast.com/aaaadh/real/2025/techblog/K8sCPU%20limit4.png)&#xD;\r\n중요한 지표는 스로틀링 비율로서 비율이 5%를 지속적으로 넘는 현상이 발생한다면 스로틀링이 빈번하게 발생하여 성능에 제약을 받아 서비스가 느려져 있을 가능성이 있으므로 조치를 취해야 합니다.&#xD;\r\n&#xD;\r\n#### 스로틀링 비율 지표 예시&#xD;\r\n```&#xD;\r\nsum by (namespace, pod) (rate(container_cpu_cfs_throttled_periods_total{container!=\"\"}[5m]))&#xD;\r\n/&#xD;\r\nsum by (namespace, pod) (rate(container_cpu_cfs_periods_total{container!=\"\"}[5m]))&#xD;\r\n```&#xD;\r\n&lt;br&gt;&#xD;\r\n## 나가며&#xD;\r\n결론은 아래와 같습니다.&#xD;\r\n* 일반적인 경우,&#xD;\r\n\t* request만 설정하여 자원이 더 필요할 때는 노드의 가용 자원을 사용하고 자원이 모자랄 때는 비율로 할당 받도록 하는 것이 좋은 것 같습니다. (QoS는 Burstable로 설정됨)&#xD;\r\n\t* QoS가 Burstable로 설정되지만 CPU는 Eviction의 조건이 아니기 때문에 throttling이 발생할지언정 pod가 eviction 되지는 않습니다.&#xD;\r\n* limit만 설정하는 경우는 피해야 합니다. limit만 설정할 경우 request가 0이 되어 자원 가용량이 없는 노드에도 스케줄링 될 수 있으며 런타임 시 예측이 어려워집니다.&#xD;\r\n* CPU request는 Pod가 노드에 할당될 때는 절댓값으로 사용되고 할당된 뒤에는 상대적인 비율로 사용됩니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n긴 글을 읽어 주셔서 감사합니다. &#xD;\r\n&lt;br&gt;&#xD;\r\n### 참고 문헌&#xD;\r\n• Kubernetes, Resource Management for Pods and Containers, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/&#xD;\r\n• KubeBlog, Understanding CPU Requests and Limits, 2023. 10. 5., https://www.kubeblog.com/basics/understanding-cpu-requests-and-limits/&#xD;\r\n• Itiel Shwartz, Kubernetes CPU Limits: What’s the Right Way to Assign CPU Resources?, 2025. 1. 14., https://komodor.com/learn/kubernetes-cpu-limits-throttling/&#xD;\r\n• Eliran Cohen, For the love of god, learn when to use CPU limits on Kubernetes., 2023. 3. 5., https://medium.com/@eliran89c/for-the-love-of-god-learn-when-to-use-cpu-limits-on-kubernetes-2225341e9dbd&#xD;\r\n• Max Levin, Kubernetes CPU Throttling: What it is, and Best Practices, 2024. 6. 6., https://www.groundcover.com/blog/kubernetes-cpu-throttling&#xD;\r\n• CODE FARM, Linux CGroups and Containers, 2024. 2. 3., https://blog.codefarm.me/2021/11/23/linux-cgroups-containers/&#xD;\r\n• Andreas Karis Blog, Quick guide for cgroups, 2020. 9. 3., https://andreaskaris.github.io/blog/linux/cgroups/&#xD;\r\n• Martin, Cgroups - Deep Dive into Resource Management in Kubernetes, 2023. 2. 20., https://martinheinz.dev/blog/91&#xD;\r\n• Jianhao, Kubernetes CPU requests and limits, 2021. 11. 11., https://jaanhio.me/blog/kubernetes-cpu-requests-limits/&#xD;\r\n• Red Hat, Resource Management Guide &gt; CPU, https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/resource_management_guide/sec-cpu&#xD;\r\n• Real-time Ubuntu, Linux kernel schedulers, https://documentation.ubuntu.com/real-time/latest/explanation/schedulers/&#xD;\r\n• Rifewang, Kubernetes: CPU Configuration, Linux CFS, and Performance Issues with Programming Languages, 2024. 12. 11., https://medium.com/@rifewang/kubernetes-cpu-configuration-linux-cfs-and-performance-issues-with-programming-languages-ccef783ed22e&#xD;\r\n• JettyCloud, Making Sense of Kubernetes CPU Requests And Limits, 2023. 3. 20., https://medium.com/@jettycloud/making-sense-of-kubernetes-cpu-requests-and-limits-390bbb5b7c92&#xD;\r\n• Tania Duggal, PerfectScale, Kubernetes CPU Limit: Best Practices for Optimal Performance, 2024. 10. 24., https://www.perfectscale.io/blog/kubernetes-cpu-limit-best-practises&#xD;\r\n• Shane Corbett, AWS Blogs, Using Prometheus to Avoid Disasters with Kubernetes CPU Limits, 2022. 9. 21., https://aws.amazon.com/blogs/containers/using-prometheus-to-avoid-disasters-with-kubernetes-cpu-limits/&#xD;\r\n&#xD;\r\n&#xD;\r\n[![NHN Cloud_meetup banner_footer_blue_202509.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerfooterblue202509.png)](https://www.nhncloud.com/kr)",
    "date": "2025-09-14T23:39:12.000Z",
    "url": "https://meetup.nhncloud.com/posts/395"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "모바일 앱 난독화(Mobile App Obfuscation)란?",
    "partialText": "[![NHN Cloud_meetup banner_Obfuscation_202507-01.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerObfuscation20250701.png)](https://www.nhncloud.com/kr)&#xD;\r\n## 들어가며: 모바일 앱 난독화란?&#xD;\r\n&#xD;\r\n모바일 애플리케이션(이하 ‘앱’)은 사용자 데이터와 기업 지식 재산권을 보호하기 위한 강력한 보안 조치가 반드시 필요합니다. 특히, 인터넷을 통해 앱이 전 세계로 배포되면서 해커들의 공격 대상이 되기 쉬워졌습니다. 이러한 상황에서 **난독화(Obfuscation)**는 소스 코드나 바이너리 파일을 복잡하게 변환하여 역공학(逆工學, Reverse Engineering) 및 해킹 시도로부터 앱을 보호하는 핵심 기술로 자리 잡았습니다. 이 글에서는 모바일 환경에서 난독화의 중요성과 다양한 난독화 솔루션들이 제공하는 기능들을 살펴보겠습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n## 모바일 앱 난독화의 필요성&#xD;\r\n&#xD;\r\n**역공학**, 즉 **리버스 엔지니어링**은 모바일 앱 보안에 큰 위협이 됩니다. 해커들은 앱 코드를 분석해 작동 원리를 파악하고, 이를 통해 취약점을 찾아내거나 코드를 무단으로 변경할 수 있습니다. 악의적인 공격자들은 리버스 엔지니어링을 이용하여 앱의 핵심 로직을 탈취하거나, 유료 기능을 무료로 사용하도록 조작하며, 심지어 악성코드를 삽입해 사용자에게 피해를 줄 수도 있습니다.&#xD;\r\n&#xD;\r\n이러한 위협에 대응하기 위한 방법 중 하나가 바로 **난독화**입니다. 난독화는 앱의 코드를 읽기 어렵게 만들어 리버스 엔지니어링을 방해하는 기술로, 코드를 마치 암호처럼 복잡하게 변환하여 해커가 분석하기 어렵게 만듭니다. 이로 인해 공격자는 시간과 노력을 과도하게 소모하게 되어, 공격 시도를 크게 저지할 수 있습니다.&#xD;\r\n&#xD;\r\n난독화는 안티 디버깅, 안티 템퍼링, 무결성 검증과 같은 다른 보안 기술과 병행 사용될 때 그 효과가 더욱 극대화됩니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n## 난독화 기술의 종류&#xD;\r\n&#xD;\r\n「Parvez Faruki 외, (2026). Android Code Protection via Obfuscation Techniques: Past, Present and Future Directions」에 따르면 난독화 기술은 총 네 가지 카테고리로 분류됩니다.&#xD;\r\n&#xD;\r\n&gt; 1. Layout Obfuscation&#xD;\r\n&gt; 2. Control Obfuscation&#xD;\r\n&gt; 3. Preventive Obfuscation&#xD;\r\n&gt; 4. Data Obfuscation&#xD;\r\n&#xD;\r\n여기서는 눈으로 쉽게 확인할 수 있는 **Layout Obfuscation**과 **Control Obfuscation**에 대해 자세히 알아보겠습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n### **Layout Obfuscation**&#xD;\r\n&#xD;\r\nLayout Obfuscation의 대표적인 방식은 **식별자 난독화**입니다. 이는 소스 코드 내 변수, 함수, 클래스 등의 이름을 의미 없는 문자나 숫자로 변경하는 방식입니다. Android 앱에서는 주로 Java나 Kotlin 코드가, iOS 앱에서는 Objective-C 나 Swift 코드가 난독화 대상이 됩니다. 이 기술을 통해 해커가 코드에서 의미 있는 단어를 찾거나 앱의 기능을 파악하기 어렵게 만듭니다.&#xD;\r\n&#xD;\r\n#### **장점**&#xD;\r\n&#xD;\r\n* 코드 가독성이 크게 낮아져 역공학 도구가 코드의 구조나 역할을 파악하기 어렵습니다.&#xD;\r\n* 단순한 변환만으로도 상당한 보안 효과를 얻을 수 있어 초기 보안 강화 수단으로 효과적입니다.&#xD;\r\n&#xD;\r\n#### **단점**&#xD;\r\n&#xD;\r\n* 지나치게 난독화된 코드는 디버깅이나 유지보수가 어려워질 수 있습니다.&#xD;\r\n* 코드 최적화와 충돌할 가능성이 있어 성능에 미치는 영향을 고려해야 합니다.&#xD;\r\n&#xD;\r\n**원본 코드**&#xD;\r\n&#xD;\r\n```java&#xD;\r\npublic class UserData {&#xD;\r\n  private String userName;&#xD;\r\n  private String userPassword;&#xD;\r\n&#xD;\r\n  public String getUserName() {&#xD;\r\n    return userName;&#xD;\r\n  }&#xD;\r\n&#xD;\r\n  public void setUserPassword(String password) {&#xD;\r\n    this.userPassword = password;&#xD;\r\n  }&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&#xD;\r\n**난독화된 코드**&#xD;\r\n&#xD;\r\n```java&#xD;\r\npublic class a {&#xD;\r\n  private String b;&#xD;\r\n  private String c;&#xD;\r\n&#xD;\r\n  public String a() {&#xD;\r\n    return b;&#xD;\r\n  }&#xD;\r\n&#xD;\r\n  public void b(String d) {&#xD;\r\n    this.c = d;&#xD;\r\n  }&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&lt;br&gt;&#xD;\r\n### **Control Obfuscation**&#xD;\r\n&#xD;\r\nControl Obfuscation은 코드의 실행 경로와 제어 흐름을 복잡하게 변경하는 기술입니다. 조건문, 반복문, 분기문의 순서를 재구성하거나 불필요한 코드 조각을 삽입하여 실제 로직과 혼동을 유발합니다. 이러한 변환은 역공학 도구가 실제 실행 경로를 파악하는 데 많은 시간과 노력을 필요로 하게 만듭니다.&#xD;\r\n&#xD;\r\n#### **예시**&#xD;\r\n&#xD;\r\n* 실제 로직과 무관한 조건문과 반복문을 추가해 제어 흐름을 복잡하게 만듭니다.&#xD;\r\n* 함수 호출 순서를 임의로 변경하여 코드 흐름을 추적하기 어렵게 합니다.&#xD;\r\n&#xD;\r\n#### **효과**&#xD;\r\n&#xD;\r\n* 공격자가 앱 내부의 실제 동작을 분석하는 데 소요되는 시간이 크게 증가합니다.&#xD;\r\n* 역공학 도구를 이용한 자동 분석의 정확도를 낮춰 보안성을 극대화합니다.&#xD;\r\n&#xD;\r\n대표적으로 Flattening 기법을 통해 이를 확인할 수 있습니다.&#xD;\r\n&#xD;\r\n**원본 코드**&#xD;\r\n&#xD;\r\n```java&#xD;\r\npublic class Calculator {&#xD;\r\n    public int calculate(int a, int b) {&#xD;\r\n        int result = a + b;&#xD;\r\n        return result * 2;&#xD;\r\n    }&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&#xD;\r\n**난독화된 코드**&#xD;\r\n&#xD;\r\n```java&#xD;\r\npublic class Calculator {&#xD;\r\n    public int calculate(int a, int b) {&#xD;\r\n        int result = 0;&#xD;\r\n        int state = 0;&#xD;\r\n        int opaque = (a * b) % 2 + 1; // 항상 1 또는 2&#xD;\r\n&#xD;\r\n        while (opaque &gt; 0) {&#xD;\r\n            switch (state) {&#xD;\r\n                case 0:&#xD;\r\n                    result = a + b;&#xD;\r\n                    state = opaque;     // 조건에 따라 1 또는 2로 전환&#xD;\r\n                    break;&#xD;\r\n                case 1:&#xD;\r\n                    result = result * 2; // 곱셈 수행&#xD;\r\n                    state = 3;          // 종료를 위해 3 부여&#xD;\r\n                    break;&#xD;\r\n                case 2: // 의미 없는 연산(dead code)&#xD;\r\n                    result = b - a;&#xD;\r\n                    state = 1;&#xD;\r\n                    break;&#xD;\r\n                case 3: // 종료&#xD;\r\n                    opaque = -1;        // 루프 종료(실제로 불필요)&#xD;\r\n                    break;&#xD;\r\n            }&#xD;\r\n            if (opaque &lt; 0) break; // 더미 코드 및 탈출 조건&#xD;\r\n        }&#xD;\r\n        return result;&#xD;\r\n    }&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&lt;br&gt;&#xD;\r\n## 시장에 존재하는 모바일 앱 난독화 솔루션&#xD;\r\n&#xD;\r\n모바일 난독화 솔루션은 무료와 상용 제품으로 구분됩니다. 각 솔루션은 기능, 사용 편의성, 그리고 업데이트 지원 측면에서 차이가 있으며, 개발자의 필요에 따라 선택할 수 있습니다.&#xD;\r\n&#xD;\r\n### **무료 난독화 솔루션**&#xD;\r\n&#xD;\r\n#### **Proguard**&#xD;\r\n&#xD;\r\nProguard는 Android 개발 환경에서 가장 널리 사용되는 오픈 소스 난독화 도구입니다. Java 기반의 코드를 대상으로 식별자 난독화와 코드 최적화, 그리고 불필요한 코드 제거 기능을 제공합니다. 이 도구는 Android Studio와 통합되어 있어 사용이 매우 간편한 점이 큰 장점입니다.&#xD;\r\n&#xD;\r\n* 주요 기능&#xD;\r\n\t* 식별자 난독화 및 코드 압축&#xD;\r\n\t* 불필요한 코드 제거를 통한 앱 크기 감소&#xD;\r\n\t* 자동화된 설정과 빌드 프로세스와의 원활한 통합&#xD;\r\n&#xD;\r\nControl Obfuscation의 기능은 제공되지 않습니다.&#xD;\r\n&#xD;\r\n#### **Black Obfuscation**&#xD;\r\n&#xD;\r\nOpenSource로 제공되고 있는 난독화 솔루션 중 하나입니다.&#xD;\r\n&#xD;\r\n* 주요 기능&#xD;\r\n    * Control flow flattening&#xD;\r\n    * If 분기문 흐름 변경&#xD;\r\n    * 복잡한 명령어로 치환&#xD;\r\n&#xD;\r\n식별자 난독화와 같은 Layout Obfuscation을 제공하지 않습니다.&#xD;\r\n&#xD;\r\n#### **그 밖의 OpenSource**&#xD;\r\n&#xD;\r\n* ObfusApk&#xD;\r\n    * [https://github.com/ClaudiuGeorgiu/Obfuscapk](https://github.com/ClaudiuGeorgiu/Obfuscapk)&#xD;\r\n* dprotect&#xD;\r\n    * [https://obfuscator.re/dprotect/](https://obfuscator.re/dprotect/)&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n### **상용 난독화 솔루션**&#xD;\r\n&#xD;\r\n#### **D사 솔루션**&#xD;\r\n&#xD;\r\n난독화 기능에 더해, 문자열 암호화, 코드 삽입, 디버깅 방지 등 다양한 보안 기능을 제공합니다.&#xD;\r\n&#xD;\r\n#### **Q사 솔루션**&#xD;\r\n&#xD;\r\n코드 난독화, 변조 방지, 런타임 보호 등 다양한 보안 기능을 제공하는 솔루션입니다.&#xD;\r\n&#xD;\r\n#### **NHN AppGuard 난독화**&#xD;\r\n&#xD;\r\nNHN Cloud의 NHN AppGuard는 난독화(Layout 및 Control Obfuscation)뿐만 아니라, 변조 방지, 런타임 보호, 안티 디버깅, 안티 템퍼링 등 다층적인 보안 기능을 제공하는 통합 모바일 보안 솔루션입니다. NHN AppGuard의 난독화는 보안 모듈과의 상호작용을 통해 Control Flow를 변동시켜 더욱 강력한 난독화 기능을 제공합니다.&#xD;\r\n&#xD;\r\n&gt;  [NHN AppGuard 더 알아보기](https://www.nhncloud.com/kr/service/security/nhn-appguard)&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 난독화 솔루션 선택 기준&#xD;\r\n&#xD;\r\n* **난독화 강도**: 솔루션이 제공하는 난독화 기술의 종류와 강도를 확인합니다.&#xD;\r\n* **지원 기능**: 디버깅 방지, 변조 방지, 런타임 보호 등 추가적인 보안 기능을 지원하는지 확인합니다.&#xD;\r\n* **성능 영향**: 난독화로 인해 앱 성능에 미치는 영향을 고려합니다.&#xD;\r\n* **사용 편의성**: 솔루션의 사용 방법이 얼마나 쉽고 편리한지 확인합니다.&#xD;\r\n* **기술 지원**: 솔루션 제공 업체의 기술 지원 수준을 확인합니다.&#xD;\r\n* **가격**: 솔루션의 가격과 라이선스 정책을 확인합니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 나가며&#xD;\r\n&#xD;\r\n오늘날 강력한 모바일 앱 보안은 선택 사항이 아닌 필수 요건입니다. 특히 리버스 엔지니어링은 앱의 지식 재산권을 침해하고 사용자 데이터를 위협하는 심각한 공격 방식으로 부상했습니다. 이러한 위협에 효과적으로 대응하기 위해서는 전문적인 난독화 솔루션 도입이 중요하지만, 난독화만으로는 완벽한 보안을 보장할 수 없습니다.&#xD;\r\n&#xD;\r\n진정한 앱 보안은 난독화뿐만 아니라 다양한 보안 기술들이 유기적으로 결합될 때 실현됩니다. NHN AppGuard는 이러한 다층적인 보안 기능을 통합적으로 제공하여 난독화의 한계를 극복하고, 더욱 강력하고 견고한 앱 보호 체계를 구축합니다.&#xD;\r\n&#xD;\r\nNHN AppGuard와 함께 귀사의 소중한 앱을 안전하게 보호하고, 비즈니스 성공을 위한 든든한 토대를 마련하시기 바랍니다.&#xD;\r\n긴 글을 읽어 주셔서 감사합니다. &#xD;\r\n&#xD;\r\n&#xD;\r\n[![NHN Cloud_meetup banner_footer_202507-01.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerfooter20250701%281%29.png)](https://www.nhncloud.com/kr)",
    "date": "2025-07-20T23:13:22.000Z",
    "url": "https://meetup.nhncloud.com/posts/394"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "iOS 앱 개발자가 알아야 할 iOS 탈옥의 위험성",
    "partialText": "[![NHN Cloud_meetup banner_Jailbreak_202507-01-01.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerJailbreak2025070101.png)](https://www.nhncloud.com/kr)&#xD;\r\n&#xD;\r\n## 1. 들어가며: iOS 탈옥이란?&#xD;\r\nApple의 iOS는 보안과 안정성을 최우선으로 하는 폐쇄적인 운영체제입니다. 기본적으로 사용자는 앱 스토어에서 승인된 앱만 설치할 수 있으며, 시스템 파일에 접근하는 것도 제한됩니다. 이러한 제한을 해제하고 사용자가 더 자유롭게 장치를 활용할 수 있도록 하는 과정이 바로 **탈옥(Jailbreak)**입니다.&#xD;\r\n&#xD;\r\n탈옥을 하면 사용자는 서명되지 않은 앱을 장치에 설치할 수 있고, 시스템 파일을 수정할 수도 있습니다. 그러나 탈옥은 단순한 개인화 도구가 아니라 보안 측면에서 큰 위험을 동반하는 행위이기도 합니다. 이번 글에서는 iOS 탈옥의 개념과 역사, 최신 탈옥 방법, 보안 위협, 그리고 개발자가 탈옥을 탐지하고 방어하는 방법까지 살펴보겠습니다. &#xD;\r\n&lt;br&gt;&#xD;\r\n## 2. iOS 탈옥을 통한 앱 해킹 사례&#xD;\r\n과거에는 탈옥이 복잡한 과정이었지만, 최근에는 몇 번의 터치만으로도 쉽게 iOS를 탈옥할 수 있는 도구들이 등장했습니다. [palera1n](https://palera.in/), unc0ver 등이 대표적인 예입니다. 특히, 일부 웹사이트에서는 별도의 PC 없이도 iPhone에서 직접 탈옥할 수 있는 도구를 제공하며, 이를 이용해 많은 일반 사용자들도 손쉽게 탈옥을 시도할 수 있습니다. **탈옥한 iPhone에서는 트윅(Tweak)이나 모드 앱(Modified App)을 아무런 제약 없이 자유롭게 설치할 수 있습니다.**&#xD;\r\n&#xD;\r\n![Jailbreak_01.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak01.png)&#xD;\r\n&lt;center&gt;&lt;span style=\"font-size:80%\"&gt;(Source: https://palera.in/) &lt;/span&gt;&lt;/center&gt;&#xD;\r\n&#xD;\r\n### 게임 앱의 피해 사례&#xD;\r\n![Jailbreak_02.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak02.png)&#xD;\r\n&lt;center&gt;&lt;span style=\"font-size:80%\"&gt;NHN Cloud On 웨비나 16, '사례로 알아보는 NHN AppGuard 실전 A to Z: 모바일 앱 해킹 유형별 대응 방법 공개!' &lt;/span&gt;&lt;/center&gt;&#xD;\r\n&lt;br&gt;&#xD;\r\n이렇게 탈옥한 iOS 환경에서 최근 피해가 지속적으로 발생하는 분야는 바로 모바일 게임입니다. 과거에는 특정 사용자의 단독적인 해킹으로 피해가 크지 않았지만, 최근에는 조직적이고 상업적으로 특정 게임을 타깃으로 해커들이 게임 앱을 해킹하고 변조하여 이를 배포하는 사례가 많아지고 있습니다. 대표적으로 iOS 모드 앱 배포 사이트인 [iOSGods.com](iOSGods.com)과 같은 사이트들이 있습니다.&#xD;\r\n&#xD;\r\n![Jailbreak_03.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak03.png)&#xD;\r\n&lt;center&gt;&lt;span style=\"font-size:80%\"&gt;(Source: iOSGods.com) &lt;/span&gt;&lt;/center&gt;&#xD;\r\n&lt;br&gt;&#xD;\r\n하지만 공개된 사이트에서 배포되던 것과 달리 최근에는 텔레그램 등의 단체 대화방에서 은밀하게 거래가 이루어지기도 합니다. 때문에 개발사에서는 일일이 iOS 모드 앱 대응이 쉽지 않습니다.&#xD;\r\n&#xD;\r\n이렇게 손쉽게 모드 앱을 설치하여 일부 유저가 게임 내에서 어뷰징을 하면 그 수가 적을지라도 게임사에게는 치명적인 피해를 입히게 됩니다. 게이머들이 게임을 하는 목적은 경쟁에서 승리하는 것인 경우가 많습니다. 하지만 어뷰징을 통해 노력 없이 한 번에 성과를 획득하는 일이 생기고 일부 유료 콘텐츠를 정당한 지불 없이 이용하기도 합니다. 이렇게 되면 유저들은 정당하게 엄청난 시간과 노력, 그리고 돈을 들여 게임을 할 가치를 못 느끼게 되고, 결국 게임 내 결제를 중단하거나 게임에서 이탈하게 되며, 이는 게임사의 매출 하락으로 이어집니다. 게임의 매출은 1~3%의 소수 유저들이 만들어 내기 때문입니다. 실제로 저희 NHN AppGuard의 한 조사에 따르면 대형 게임 해킹 사건 이후 매출이 하락했다는 결과가 있습니다.&#xD;\r\n&#xD;\r\n![Jailbreak_04.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak04.png)&#xD;\r\n&lt;center&gt;&lt;span style=\"font-size:80%\"&gt;NHN Cloud On 웨비나 16, '사례로 알아보는 NHN AppGuard 실전 A to Z: 모바일 앱 해킹 유형별 대응 방법 공개!' &lt;/span&gt;&lt;/center&gt;&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n결과적으로 게임사의 매출과 앱 서비스에 대한 고객의 신뢰가 하락하게 되는 것입니다.&#xD;\r\n자세한 내용은 [NHN Cloud On 웨비나 16｜사례로 알아보는 NHN AppGuard 실전 A to Z | 모바일 앱 해킹 유형별 대응 방법 공개!](https://youtu.be/zGg1I7YePfE?si=eDcnKRoHErt0UzxC) 영상에서 확인하실 수 있습니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 3. iOS 탈옥의 역사와 동작 원리&#xD;\r\n### JailbreakMe (iOS 1.x ~ 4.x)&#xD;\r\n![Jailbreak_05.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak05.png)&#xD;\r\n&lt;center&gt;&lt;span style=\"font-size:80%\"&gt;(Source: https://en.wikipedia.org/wiki/JailbreakMe) &lt;/span&gt;&lt;/center&gt;&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n**JailbreakMe**는 Safari 웹 브라우저를 이용해 탈옥하는 방식으로, 사용자가 특정 웹사이트를 방문하는 것만으로도 탈옥이 가능했습니다. 이는 PDF 렌더링 엔진의 보안 취약점을 이용한 것으로, 사용자 입장에서 가장 간편한 탈옥 방법이었습니다. &#xD;\r\n그러나 Apple이 보안 패치를 적용하면서 더 이상 사용이 불가능해졌습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n### Redsn0w &amp; Greenpois0n (iOS 4.x ~ 5.x)&#xD;\r\n이 시기의 탈옥은 USB를 통해 기기를 컴퓨터에 연결한 뒤, 전용 탈옥 프로그램을 실행하는 방식으로 이루어졌습니다. **Redsn0w**와 **Greenpois0n**은 각각 다른 커널 취약점을 이용하여 탈옥을 수행하였으며, tethered(재부팅 시 탈옥이 해제됨) 및 untethered(영구 탈옥) 방식으로 나뉘었습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n### Evasi0n (iOS 6.x)&#xD;\r\n![Jailbreak_06.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak06.png)&#xD;\r\n&lt;center&gt;&lt;span style=\"font-size:80%\"&gt;(Source: https://evasi0n.com/) &lt;/span&gt;&lt;/center&gt;&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n**Evasi0n**은 iOS 6에서 사용된 탈옥 도구로, USB 연결을 통해 시스템의 여러 취약점을 연쇄적으로 이용하여 완전한 탈옥을 가능하게 했습니다. 당시 매우 높은 안정성과 호환성을 제공하여 널리 사용되었습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n### Pangu &amp; TaiG (iOS 7.x ~ 9.x)&#xD;\r\n**Pangu**와 **TaiG**는 중국 해커 그룹이 개발한 탈옥 도구로, iOS 7 이후 보안이 강화된 환경에서도 탈옥을 가능하게 했습니다. 특히, TaiG는 iOS 8에서 Apple이 취약점을 보완한 패치를 우회하는 새로운 기법을 도입하여 탈옥을 성공시켰습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n### Yalu (iOS 10.x)&#xD;\r\n**Yalu**는 iOS 10에서 사용된 탈옥 도구로, 개발자인 Luca Todesco가 만든 것으로 유명합니다. 그러나 이 탈옥은 semi-untethered 방식이어서 기기를 재부팅하면 탈옥이 해제되며, 다시 실행하려면 특정 앱을 실행해야 했습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n### unc0ver &amp; Electra (iOS 11.x ~ 14.x)&#xD;\r\n**unc0ver**와 **Electra**는 최근까지 사용되는 탈옥 도구로, 커널 취약점을 이용하여 탈옥을 수행합니다. 특히 unc0ver는 안정성이 높아 많은 사용자들이 선호하였으며, 탈옥 후에도 시스템 기능을 최대한 유지할 수 있도록 설계되었습니다.&#xD;\r\n&lt;br&gt;&#xD;\r\n### checkra1n (iOS 12.x ~ 14.x)&#xD;\r\n![Jailbreak_07.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak07.png)&#xD;\r\n &lt;center&gt;&lt;span style=\"font-size:80%\"&gt;(Source: https://checkra.in/) &lt;/span&gt;&lt;/center&gt;&#xD;\r\n&#xD;\r\n&#xD;\r\n &lt;br&gt;&#xD;\r\n**checkra1n**은 기존의 탈옥과 달리, checkm8이라는 하드웨어 부트롬(bootrom) 취약점을 이용한 영구 탈옥 방식입니다. &#xD;\r\n이로 인해 iOS 버전에 상관없이 특정 기기에서는 항상 탈옥이 가능하지만, 반대로 Apple이 소프트웨어 패치를 통해 막을 수 없는 특성을 가집니다. 다만, checkra1n은 semi-tethered 방식으로, 재부팅 후에는 다시 탈옥 프로세스를 수행해야 합니다.&#xD;\r\n&#xD;\r\n최근에는 Apple이 보안 강화를 지속하면서 탈옥이 점점 어려워지고 있으며, 대부분의 탈옥이 semi-tethered(재부팅 시 탈옥이 풀림) 형태로 제공되고 있습니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 4. 탈옥한 iOS 장치의 보안 취약점&#xD;\r\n탈옥한 iOS 장치는 Apple이 제공하는 기본 보안 메커니즘을 우회하기 때문에 여러 가지 보안 취약점에 노출됩니다. 다음은 탈옥한 iOS가 갖는 주요 취약점입니다.&#xD;\r\n&#xD;\r\n* **시스템 보안 우회**: 탈옥한 기기는 Apple의 기본 보안 메커니즘을 우회하여 시스템 파일을 수정할 수 있습니다. 이는 악성 코드나 바이러스가 시스템에 침투하기 쉽게 만듭니다.&#xD;\r\n* **앱 간 데이터 접근**: 탈옥한 기기에서는 앱 간의 데이터 접근이 가능해져, 민감한 정보가 유출될 위험이 높아집니다.&#xD;\r\n* **루트 권한 노출**: 탈옥한 기기는 루트 권한을 얻을 수 있어, 시스템 파일을 자유롭게 변경할 수 있습니다. 이는 해커가 기기를 완전히 제어할 수 있는 가능성을 열어줍니다.&#xD;\r\n* **악성 코드 및 해킹 위험**: 탈옥한 기기에서는 악성 소프트웨어나 해킹 툴이 쉽게 설치될 수 있습니다. 이는 사용자의 개인 정보와 금융 정보를 위험에 빠뜨릴 수 있습니다.&#xD;\r\n* **보안 업데이트 차단**: 탈옥한 기기는 Apple로부터 자동 업데이트를 받지 못하게 되어 중요한 보안 패치와 기능 업데이트를 놓칠 수 있습니다.&#xD;\r\n&#xD;\r\n특히, 탈옥한 장치에는 앱의 실행을 제한하는 보안 프로세스가 없기 때문에, 악성 소프트웨어가 시스템에 침투할 가능성이 높아집니다. 이러한 위험은 사용자의 개인 정보와 금융 정보를 보호하는 데 큰 위협이 될 수 있습니다. 예를 들어, 온라인 뱅킹 앱이나 결제 서비스 앱에 저장된 정보가 해커의 손에 넘어갈 수 있습니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 5. iOS 탈옥이 배포하는 앱에 미치는 영향&#xD;\r\n### 5.1. 보안 취약점 증가&#xD;\r\n* **악성 코드 및 해킹에 노출**&#xD;\r\n탈옥한 장치는 운영체제의 보안 계층이 무너져 악성 코드나 해킹에 취약합니다. 이는 앱 내에서 수집되는 데이터나 사용자 정보가 유출될 위험을 증가시키며, 개발자의 신뢰도에도 부정적인 영향을 미칠 수 있습니다.&#xD;\r\n&#xD;\r\n* **앱 무결성 손상**&#xD;\r\n탈옥한 환경에서는 앱의 코드가 변조될 수 있어 앱의 무결성이 손상될 수 있습니다. 이는 앱의 정상적인 동작을 방해하고, 예기치 않은 오류나 버그를 유발할 수 있습니다.&#xD;\r\n&#xD;\r\n### 5.2. 불법 복제 및 수익 손실&#xD;\r\n* **앱 불법 복제 증가**&#xD;\r\n탈옥한 장치는 앱의 불법 복제나 유료 앱을 무료로 설치할 수 있는 환경을 제공합니다. 이러한 행위를 도와주는 모드 앱 또한 증가합니다. 이는 개발자의 직접적인 수익 손실로 이어지며, 앱 비즈니스 모델에 큰 타격을 줄 수 있습니다.&#xD;\r\n&#xD;\r\n* **인앱 결제 우회**&#xD;\r\n탈옥을 통한 인앱 결제 우회는 트윅을 설치하거나 앱 변조를 통해 유료 기능을 무료로 사용하는 사례도 많습니다. 이는 개발자의 추가 수익 창출 기회를 감소시키고, 공정한 수익 구조를 해칠 수 있습니다.&#xD;\r\n&#xD;\r\n### 5.3. 사용자 경험 저하&#xD;\r\n* **앱의 안정성 문제**&#xD;\r\n탈옥한 장치에서는 시스템 안정성이 떨어져 앱의 크래시(crash)나 프리즈(freeze) 현상이 빈번하게 발생할 수 있습니다. 이는 사용자에게 부정적인 경험을 주며, 앱에 대한 만족도를 크게 저하시킬 수 있습니다.&#xD;\r\n&#xD;\r\n* **지원 불가능한 환경**&#xD;\r\n탈옥 환경은 표준 iOS 환경이 아니기 때문에 개발자가 예상하지 못한 문제가 발생할 수 있습니다. 이러한 문제를 해결하기 위해 추가적인 자원을 투입하기 어려워, 사용자 지원에 한계를 겪을 수 있습니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 6. iOS 탈옥 탐지 방법&#xD;\r\n앱 개발자는 탈옥한 장치에서 앱을 보호하기 위해 기기의 상태를 탐지해야 합니다. 탈옥한 장치를 탐지하는 데 사용되는 다양한 기법들이 있으며, 각 기법은 고유한 특징과 장단점을 가지고 있습니다. 주요 탐지 방법은 다음과 같습니다.&#xD;\r\n&#xD;\r\n### 6.1. 시스템 파일 검사&#xD;\r\n탈옥한 장치는 시스템 파일에 변화를 일으키는 경우가 많습니다. 대표적인 예로 `/private/var/lib/cydia`나 `/bin/bash` 같은 파일들이 존재하는지 확인하여 탈옥 여부를 탐지할 수 있습니다. 이러한 파일들은 일반적으로 탈옥 도구를 설치할 때 생성됩니다.&#xD;\r\n&#xD;\r\n```&#xD;\r\nfunc isJailbroken() -&gt; Bool {&#xD;\r\n    // 확인할 시스템 파일 경로들&#xD;\r\n    let jailbreakPaths = [&#xD;\r\n        \"/private/var/lib/cydia\",  // Cydia 파일&#xD;\r\n        \"/bin/bash\",               // bash 파일&#xD;\r\n        \"/usr/sbin/sshd\",          // SSH 서버 파일&#xD;\r\n        \"/etc/apt\"                 // APT 디렉터리&#xD;\r\n    ]&#xD;\r\n    &#xD;\r\n    // 각 파일/디렉터리 존재 여부 체크&#xD;\r\n    for path in jailbreakPaths {&#xD;\r\n        if FileManager.default.fileExists(atPath: path) {&#xD;\r\n            return true  // 파일이 존재하면 탈옥된 기기&#xD;\r\n        }&#xD;\r\n    }&#xD;\r\n    &#xD;\r\n    return false  // 파일이 없으면 탈옥되지 않은 기기&#xD;\r\n}&#xD;\r\n&#xD;\r\n```&#xD;\r\n&#xD;\r\n### 6.2. API 호출 감지&#xD;\r\n탈옥한 장치에서 주로 사용되는 특정 API 호출을 감지하여 탈옥 여부를 판단할 수 있습니다. 예를 들어, `fork()`, `sysctl()` 등의 함수 호출은 탈옥과 관련된 행동을 나타낼 수 있습니다. 이러한 함수 호출을 모니터링하여 탈옥 여부를 탐지합니다.&#xD;\r\n&#xD;\r\n```&#xD;\r\nfunc checkFork() -&gt; Bool {&#xD;\r\n    let pid = fork()&#xD;\r\n    if pid == 0 {&#xD;\r\n        // 자식 프로세스 종료 (fork가 성공하면 탈옥 가능성이 높음)&#xD;\r\n        exit(0)&#xD;\r\n    } else if pid &gt; 0 {&#xD;\r\n        print(\"fork() 호출 가능 - 탈옥된 기기일 수 있음\")&#xD;\r\n        return true&#xD;\r\n    }&#xD;\r\n    return false&#xD;\r\n}&#xD;\r\n&#xD;\r\n```&#xD;\r\n&#xD;\r\n### 6.3. 탈옥 도구 탐지&#xD;\r\n탈옥한 장치에는 MobileSubstrate, Frida, Cydia 등과 같은 탈옥 도구들이 설치됩니다. 이러한 도구들이 설치되어 있는지 확인하여 탈옥 여부를 탐지할 수 있습니다. 예를 들어, Cydia 앱이 설치되어 있는지 확인하는 방법이 있습니다.&#xD;\r\n&#xD;\r\n```&#xD;\r\n// 확인할 파일 및 디렉터리 목록&#xD;\r\nlet jailbreakFilePaths: [String] = [&#xD;\r\n    \"/Applications/Cydia.app\",&#xD;\r\n    \"/private/var/lib/cydia/\",&#xD;\r\n    \"/private/var/tmp/cydia.log\"&#xD;\r\n]&#xD;\r\n&#xD;\r\n// 파일 존재 여부 확인 함수&#xD;\r\nfunc checkJailbreakFiles() -&gt; Bool {&#xD;\r\n    for path in jailbreakFilePaths {&#xD;\r\n        if FileManager.default.fileExists(atPath: path) {&#xD;\r\n            print(\"탈옥 관련 파일 발견: \\(path)\")&#xD;\r\n            return true&#xD;\r\n        }&#xD;\r\n    }&#xD;\r\n    return false&#xD;\r\n}&#xD;\r\n&#xD;\r\n```&#xD;\r\n&#xD;\r\n### 6.4. 비공식 앱 설치 탐지&#xD;\r\n탈옥한 장치에는 Apple의 공식 앱 스토어 외에도 비공식 앱 스토어를 통해 앱을 설치할 수 있습니다. 따라서 비공식적으로 설치된 앱들을 탐지하여 탈옥 여부를 확인할 수 있습니다.&#xD;\r\n&#xD;\r\n### 6.5. 루트 접근 권한 검사&#xD;\r\n탈옥한 장치는 루트 권한을 얻을 수 있기 때문에, 루트 권한으로 실행된 프로세스나 파일들을 확인하는 방법이 있습니다. 시스템 내에서 루트 권한을 사용하는 프로세스나 파일 접근 시 이를 탐지할 수 있습니다.&#xD;\r\n탈옥한 장치에서 발생할 수 있는 보안 위험을 완전히 없애는 것은 불가능할 수 있지만, 여러 방어 기법을 결합하여 다층적인 보안을 구축하는 것이 중요합니다.&#xD;\r\n&#xD;\r\n&lt;br&gt;&#xD;\r\n## 7. 나가며&#xD;\r\niOS 앱 개발자는 사용자 데이터를 보호하고, 앱의 안전한 환경을 제공하는 중요한 책임을 지고 있습니다. 탈옥한 장치에서 발생할 수 있는 보안 위협을 사전에 탐지하고 방어하는 것은 필수적인 작업입니다. 탈옥 탐지 및 방어 기능을 통해 앱의 보안을 강화하고, 사용자가 안전하게 앱을 사용할 수 있도록 보장해야 합니다.&#xD;\r\n&#xD;\r\n글로벌 IT기업 NHN이 직접 만든 **NHN AppGuard**는 탈옥 기기에서 발생하는 다양한 보안 위협에 대응할 수 있는 필수적인 보안 솔루션입니다. NHN AppGuard를 적용하여 배포하면 아래와 같이 탈옥 환경을 탐지하고 차단할 수 있도록 정책을 설정할 수 있습니다.&#xD;\r\n&#xD;\r\n![Jailbreak_08.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak08.png)&#xD;\r\n &lt;center&gt;&lt;span style=\"font-size:80%\"&gt;탈옥 환경을 탐지하고 차단하기 위한 NHN AppGuard 정책 설정 화면&lt;/span&gt;&lt;/center&gt;&#xD;\r\n &lt;br&gt;&#xD;\r\n 배포된 앱이 실행되는 중 탈옥이 탐지되면 곧바로 탐지에 대한 로그를 남기며 이를 추적할 수 있습니다.&#xD;\r\n &#xD;\r\n![Jailbreak_09.png](https://image.toast.com/aaaadh/real/2025/techblog/Jailbreak09.png)&#xD;\r\n&lt;center&gt;&lt;span style=\"font-size:80%\"&gt;탈옥 탐지 로그 조회 화면&lt;/span&gt;&lt;/center&gt;&#xD;\r\n&lt;br&gt;&#xD;\r\n이렇게 NHN AppGuard는 앱 운영자가 기기 보안에 대한 걱정 없이 안정적인 서비스 제공에 집중할 수 있도록 도와줍니다. 강력한 탈옥 탐지와 차단 기능을 통해 앱의 무결성과 사용자 데이터를 완벽하게 보호할 수 있습니다.&#xD;\r\n&#xD;\r\n&gt;  [NHN AppGuard 더 알아보기](https://www.nhncloud.com/kr/service/security/nhn-appguard)&#xD;\r\n&#xD;\r\n지금까지 iOS 탈옥의 개념과 역사, 탈옥한 장치에서의 피해 사례, 최신 탈옥 방법, 보안 위협, 그리고 개발자가 탈옥을 탐지하고 방어하는 방법에 대해 알아보았습니다. iOS 앱 개발자 분들뿐만 아니라 iOS를 사용하거나 보안에 관심이 있는 모든 분들께 도움이 되었길 바랍니다. 긴 글을 읽어 주셔서 감사합니다. &#xD;\r\n&#xD;\r\n&#xD;\r\n[![NHN Cloud_meetup banner_footer_202507-01.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerfooter20250701.png)](https://www.nhncloud.com/kr)",
    "date": "2025-07-07T00:50:53.000Z",
    "url": "https://meetup.nhncloud.com/posts/393"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "NHN Cloud 빠른 시작 가이드를 소개합니다",
    "partialText": "![자산 2.png](https://image.toast.com/aaaadh/alpha/2025/techblog/uC790uC0B0%202.png)&#xD;\r\n&#xD;\r\n# 들어가며&#xD;\r\n&#xD;\r\nNHN Cloud 빠른 시작 가이드가 출시되었습니다. NHN Cloud는 현재까지 110개가 넘는 서비스를 제공 중인데요. 이렇게 다양하고 많은 서비스를 처음 사용하고자 할 때 어디서부터 시작해야 할지에 대한 과정은 설레면서도 막막함을 동반하는데요. NHN Cloud를 처음 접해보는 분들을 위해 최대한 빠르고 쉽게 NHN Cloud를 익힐 수 있도록 돕기 위한 빠른 시작 가이드를 소개합니다.&#xD;\r\n&#xD;\r\n# 빠른 시작 가이드란?&#xD;\r\n&#xD;\r\n빠른 시작 가이드는 사용자가 서비스를 신속하게 이해하고 바로 사용할 수 있도록 도와주는 간결한 문서입니다. 여기서 중요한 점은 **간결성**이데요. 빠른 시작 가이드는 간결하고 핵심적인 내용을 담고 있어 사용자가 서비스를 시작하는데 필요한 정보만 포함하고 불필요한 세부사항은 생략합니다.&#xD;\r\n&#xD;\r\n또한 **작업 중심적**으로 특정 작업을 빠르게 완료하기 위한 정보만 포함합니다. 따라서 NHN Cloud 빠른 시작 가이드도 총 12개의 학습 모듈에서 완수해야 할 작업을 중심으로 구성되어 있습니다. 각 학습 모듈에서 이전에 생성한 리소스를 재활용하여 복잡한 초기 설정 작업을 간소화해 주요 작업을 빠르게 진행할 수 있도록 설계하였습니다.&#xD;\r\n&#xD;\r\n빠른 시작 가이드와 튜토리얼이 같은 목적을 가진 문서로 보일 수 있지만 사실 두 문서는 서로 다른 목적을 가집니다. 두 문서 모두 어떤 기능을 사용하거나 작업을 완료하는 방법을 다루는 문서이지만 튜토리얼은 앞서 설명한 빠른 시작 가이드의 특징과 다르게 사용자가 더 넓고 복잡한 작업을 수행할 수 있도록 돕습니다. 따라서 타깃 대상도 처음 서비스를 사용하는 사용자가 아닌 심화 학습을 원하는 사용자이며 빠른 시작 가이드 대비 내용이 더 길고 복잡한 작업을 다룹니다.&#xD;\r\n&#xD;\r\n## NHN Cloud 빠른 시작 가이드&#xD;\r\n&#xD;\r\n**NHN Cloud 빠른 시작 가이드**는 NHN Cloud를 처음 이용하는 사용자를 위한 단계별 온보딩 가이드입니다. 본 가이드를 통해 빠른 시간 내에 다양한 클라우드 리소스를 효율적으로 관리하고 설정할 수 있는 통합 관리 도구인 NHN Cloud 콘솔의 사용법을 익히고 클라우드 서비스를 제공할 수 있습니다.&#xD;\r\n&#xD;\r\n가이드는 아래와 같이 12개의 학습 모듈로 구성되어 있습니다. 각 학습 모듈은 쉽게 따라 할 수 있도록 실습 예제를 제공합니다. NHN Cloud 회원 가입 이후부터 기본 콘솔 사용법을 익히고 최종적으로 간단한 클라우드 아키텍처를 구성해 서비스를 제공할 수 있습니다.&#xD;\r\n&#xD;\r\n [NHN Cloud 빠른 시작 가이드 바로가기](https://docs.nhncloud.com/ko/quickstarts/ko/overview/)&#xD;\r\n&lt;br&gt;&#xD;\r\n&#xD;\r\n![NHN Portal 개선 빠른 시작 가이드@2x (1).png](https://image.toast.com/aaaadh/alpha/2025/techblog/NHN%20Portal%20uAC1CuC120%20uBE60uB978%20uC2DCuC791%20uAC00uC774uB4DC2x%201.png)&#xD;\r\n&#xD;\r\n## 빠른 시작 가이드 구성&#xD;\r\n&#xD;\r\nNHN Cloud 빠른 시작 가이드의 학습 모듈은 크게 3가지 영역으로 구성됩니다.&#xD;\r\n&#xD;\r\n1. 학습 목표: 학습 모듈을 통해 배울 내용을 간략하게 보여줍니다.&#xD;\r\n2. 시작하기 전에: 학습 모듈을 매끄럽게 수행하기 위해 필요한 준비 사항을 보여줍니다.&#xD;\r\n3. 실습 과제: 학습 모듈에서 수행할 과제 내용을 다루며 여러 단계로 나누어 설명합니다.&#xD;\r\n4. 참고 자료: 해당 학습 모듈과 관련된 더 깊이 있는 정보를 확인할 수 있습니다.&#xD;\r\n&#xD;\r\n&#xD;\r\n빠른 시작 가이드는 NHN Cloud 입문자가 쉽게 익힐 수 있게 작성된 문서입니다. 따라서 각 학습 모듈에서 동일한 조직, 프로젝트, 리전, 가용성 영역을 사용하여 복잡한 설정 작업을 최대한 간소화하였습니다.&#xD;\r\n&#xD;\r\n* 조직: MyORG&#xD;\r\n* 프로젝트: MyPRJ&#xD;\r\n* 리전: 평촌 Region&#xD;\r\n* VPC: MyVPC&#xD;\r\n* 서브넷: MySubnet&#xD;\r\n&#xD;\r\n![0. 개요.png](https://image.toast.com/aaaadh/alpha/2025/techblog/0.%20uAC1CuC694.png)&#xD;\r\n&#xD;\r\n총 12개의 학습 모듈은 서로 연계되어 있습니다. 따라서 하나의 학습 모듈에서 생성한 리소스를 재사용하므로 마지막 학습 모듈을 마치기 전까지 리소스를 삭제하지 않는 것을 권장합니다. 학습 모듈의 실습 과제들을 차근차근 따라 해 보면서 생성한 리소스를 활용하여 `학습 모듈 10. 확장성과 성능 최적화`을 완수하면 아래와 같은 클라우드 아키텍처를 완성할 수 있습니다.&#xD;\r\n&#xD;\r\n![모듈 10. 확장성과 성능 최적화.png](https://image.toast.com/aaaadh/alpha/2025/techblog/uBAA8uB4C8%2010.%20uD655uC7A5uC131uACFC%20uC131uB2A5%20uCD5CuC801uD654.png)&#xD;\r\n&#xD;\r\n&#xD;\r\n&gt; 오토 스케일링, 로드 밸런싱 서비스를 사용해 안정적인 데이터 관리를 위한 효율적이고 유연하며 확장 가능한 시스템을 완성할 수 있습니다.&#xD;\r\n&#xD;\r\n## 더 알아보기&#xD;\r\n&#xD;\r\nNHN Cloud 빠른 시작 가이드를 통해 NHN Cloud와 친숙해 지셨다면 한 걸음 더 나아가 NHN Cloud 교육센터를 통해 더 깊이있고 심화된 내용을 학습하실 수 있습니다. NHN Cloud는 NHN Cloud 콘솔을 직접 사용하며 배울 수 있는 교육 과정을 제공하고 있는데요. 빠른 시작 가이드에서 다루는 내용 뿐 아니라 클라우드 및 컨테이너에 대한 기본 개념과 NHN Cloud의 컨테이너 서비스인 `NHN Kubernetes Service(NKS)`와 `NHN Container Registry(NCR)`에 대해 심도있게 학습할 수 있습니다. NHN Cloud 교육센터에서 제공하는 클라우드 기초 지식부터 심화 내용을 다루는 교육 과정을 통해 클라우드 역량을 향상하고 더 나아가 NHN Cloud 자격증을 이수할 수 있습니다.&#xD;\r\n&#xD;\r\n [NHN Cloud 교육센터 바로가기](https://www.nhncloud.com/kr/edu)&#xD;\r\n&#xD;\r\n![footer.png](https://image.toast.com/aaaadh/alpha/2025/techblog/footer.png)",
    "date": "2025-05-28T06:40:47.000Z",
    "url": "https://meetup.nhncloud.com/posts/392"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "Trino로 타임아웃 개선하기",
    "partialText": "![NHN Cloud_meetup banner_trino_202502-01_900.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannertrino20250201900.png)&#xD;\r\n&#xD;\r\n# 들어가며&#xD;\r\n안녕하세요. NHN Cloud의 클라우드AI팀 이태형입니다.&#xD;\r\n로그 데이터가 쌓일수록 조회 속도가 느려지는 문제, 한 번쯤 겪어 보셨을 텐데요. 이 글에서는 이러한 문제를 해결하기 위해 저희 팀에서 Trino를 도입하여 성능을 개선한 과정을 공유해 보려 합니다. 재미있게 읽어 주세요! &#xD;\r\n&#xD;\r\n# 개요: NHN AppGuard&#xD;\r\n[NHN AppGuard](https://www.nhncloud.com/kr/service/security/nhn-appguard) 서비스에 Trino를 적용한 이야기를 드릴 예정이라서 먼저 해당 서비스를 소개하겠습니다.&#xD;\r\n&#xD;\r\nNHN AppGuard는 모바일 애플리케이션을 보호하기 위해 사용자의 이상 행위를 탐지하거나 차단하는 모바일 앱 보안 솔루션입니다. NHN AppGuard의 서버는 탐지/차단 로그를 안전하게 저장하고, 각종 조건 검색과 대시보드를 제공합니다.&#xD;\r\n&#xD;\r\n![Trino_1.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino1.png)&#xD;\r\n&#xD;\r\n## NHN AppGuard 로그&#xD;\r\n&#xD;\r\nNHN AppGuard는 평균 600만개/일 가량의 로그를 수집하고 있습니다. 이러한 로그는 NHN AppGuard 로그 워크플로에 따라 DB에 적재됩니다.&#xD;\r\n&#xD;\r\n![Trino_2_900.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino2900.png)&#xD;\r\n&#xD;\r\n## 이슈 발생&#xD;\r\n&#xD;\r\n대부분의 쿼리가 월 단위 집계 성격을 띠는 이유로 질의 대상 row 가 1억 건이 넘는 경우가 많아 이슈가 발생했습니다.&#xD;\r\n발생한 이슈는 아래와 같습니다.&#xD;\r\n&#xD;\r\n1. 검색 조건 변경 시 대시보드 화면에서 타임아웃 발생&#xD;\r\n![Trino_3.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino3.png)&#xD;\r\n2. 집계 쿼리가 수행되는 새벽 시간대에 slow query 발생&#xD;\r\n![Trino_4.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino4.png)&#xD;\r\n&#xD;\r\n## 일반적인 해결 방안&#xD;\r\n&#xD;\r\n위 이슈들은 결국 쿼리의 성능이 원인이기 때문에 먼저 쿼리 최적화를 수행했습니다.&#xD;\r\n&#xD;\r\n1. index 문제&#xD;\r\n    1. 쿼리 검수를 통해 index의 순서를 변경하고&#xD;\r\n    2. 의도한 index가 적용되도록 쿼리에 index hint를 추가했습니다.&#xD;\r\n2. 쿼리의 문제&#xD;\r\n    1. 한 달 기간 전체 데이터를 스캔하는 쿼리를 당일 증가분만 조회하도록 수정하고&#xD;\r\n    2. 대시보드를 매번 조회하지 않고 일 배치 작업으로 미리 계산해 둔 데이터를 조회하고&#xD;\r\n    3. 조회 가능한 기간을 제한했습니다.&#xD;\r\n&#xD;\r\n이러한 최적화를 통해 일시적으로 이슈가 해소되었습니다.&#xD;\r\n하지만 NHN AppGuard의 로그는 점차 늘어나고, 집계할 데이터의 종류도 증가했으며, 조회 기간 감소에 대한 불만이 발생하여 다른 접근이 필요했습니다.&#xD;\r\n&#xD;\r\n## 로그 저장소 검토&#xD;\r\n&#xD;\r\nMySQL을 대신해 로그를 저장하기에 적절한 로그 저장소를 검토했습니다.&#xD;\r\n&#xD;\r\n1. Elasticsearch (LNCS)&#xD;\r\n    1. 검색에 좋은 성능&#xD;\r\n    2. 상품 스펙상 최대 120일 저장 제한&#xD;\r\n2. Trino (DataQuery)&#xD;\r\n    1. 복잡한 집계 쿼리에 좋은 성능&#xD;\r\n    2. 여러 데이터 소스 간 federation 지원&#xD;\r\n    3. 저장 기간 제한 없음&#xD;\r\n&#xD;\r\nNHN AppGuard는 로그의 저장 기간을 기존 90일에서 늘리는 것을 계획하고 있었고, 무엇보다 대부분의 쿼리가 집계 성격을 많이 띠어 Trino가 적절하다고 판단했습니다.&#xD;\r\n&#xD;\r\n# Trino와 DataQuery&#xD;\r\n&#xD;\r\n## Trino란&#xD;\r\n&#xD;\r\n[Trino 공식 홈페이지](https://trino.io)를 보면 아래와 같은 문구를 찾을 수 있습니다.&#xD;\r\n&#xD;\r\n&gt; Trino, a query engine that runs at ludicrous speed&#xD;\r\n&gt; Fast distributed SQL query engine for big data analytics that helps you explore your data universe.&#xD;\r\n&#xD;\r\n키워드를 뽑아 보면 아래와 같습니다.&#xD;\r\n&#xD;\r\n1. Fast - 빠르다&#xD;\r\n2. Distributed - 분산 처리한다&#xD;\r\n3. analytics - 분석에 적절하다&#xD;\r\n&#xD;\r\n## Trino 특징&#xD;\r\n&#xD;\r\n마찬가지로 [Trino 공식 홈페이지](https://trino.io)에서는 아래와 같은 특징을 소개합니다.&#xD;\r\n![Trino_5.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino5.png)&#xD;\r\n&#xD;\r\n여기서도 키워드를 뽑아보면 아래와 같습니다.&#xD;\r\n&#xD;\r\n1. distributed: 분산 처리로 빠르고&#xD;\r\n2. ANSI SQL: 표준 SQL 을 호환하여 현재 쿼리문을 수정할 필요가 없고&#xD;\r\n3. S3: OBS에 저장하여 스토리지 비용을 줄일 수 있고&#xD;\r\n4. Query Federation: OBS의 데이터와 MySQL 데이터를 하나의 쿼리로 join할 수 있다.&#xD;\r\n&#xD;\r\n## Trino 동작 원리&#xD;\r\n&#xD;\r\nTrino의 동작 원리는 [Presto: SQL on Everything](https://trino.io/Presto_SQL_on_Everything.pdf)라는 논문에 자세히 소개하고 있습니다.&#xD;\r\n해당 논문의 일부를 가볍게 살펴보겠습니다.&#xD;\r\n&#xD;\r\n### 구조도&#xD;\r\n![Trino_6.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino6.png)&#xD;\r\n&#xD;\r\nTrino는 하나의 Coordinator 노드와 여러 개의 Worker 노드로 구성됩니다. Coordinator 노드는 쿼리의 인입 지점으로 admit, parsing, planning, optimizing, orchestration 등을 수행하고, worker node는 query processing을 담당합니다.&#xD;\r\n&#xD;\r\n### 요청 처리 순서&#xD;\r\n&#xD;\r\nCoordinator 노드가 분산 처리를 계획하면 worker node가 병렬로 처리해서 복잡한 쿼리가 더 빠르게 실행되는 원리입니다.&#xD;\r\n&#xD;\r\n1. client → coordinator: http request (SQL stmt)&#xD;\r\n2. coordinator: evaluate request(parsing, analyzing, **optimizing distributed execution plan**)&#xD;\r\n3. coordinator: plan to worker&#xD;\r\n    1. task 생성&#xD;\r\n    2. **splits** 생성(addressable chunk in external storage)&#xD;\r\n    3. splits을 task에 할당&#xD;\r\n4. worker: run task&#xD;\r\n    1. fetching splits&#xD;\r\n    2. 다른 worker에서 생성한 intermediate data 처리&#xD;\r\n        1. worker 간에는 intermediate data를 memory에 저장하여 공유&#xD;\r\n        2. **shuffle**이 발생할 수 있음&#xD;\r\n             \\*shuffle = node 간 데이터 재분배&#xD;\r\n    3. query의 shape에 따라 모든 데이터를 처리하지 않고 반환&#xD;\r\n&#xD;\r\n## Trino 쿼리 실행 예시&#xD;\r\n&#xD;\r\n### 그림으로 살펴보기&#xD;\r\n* 쿼리문&#xD;\r\n![Trino_7.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino7.png)&#xD;\r\n&#xD;\r\n* logical plan&#xD;\r\n![Trino_8.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino8.png)&#xD;\r\n&#xD;\r\n* distributed plan (stage)&#xD;\r\n![Trino_9.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino9.png)&#xD;\r\n&#xD;\r\n* optimized plan (pipeline, parallelism)&#xD;\r\n![Trino_10.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino10.png)&#xD;\r\n&#xD;\r\n&#xD;\r\n### 실행 순서&#xD;\r\n&#xD;\r\n1. Planner: SQL → SQL syntax tree → Logical Planning (IR 생성)&#xD;\r\n    * IR = Intermediate Representation&#xD;\r\n2. Optimizer: Logical Plan → evaluate transformation rules → **optimize** → Physical Structure&#xD;\r\n    * transformation rules = sub-tree query plan + transformation&#xD;\r\n    * 사용되는 optimizing 기법 = predicate and limit pushdown, column pruning, decorrelation, table and column statistics 기반 cost-based 최적화&#xD;\r\n        * Data Layouts = Connector Data Layout API로 얻어내는 위치, 파티션, 정렬, 그룹화, 인덱스&#xD;\r\n        * Predicate Pushdown = connector에 따른 filtering 최적화&#xD;\r\n            * \\*pushdown : 읽어야 하는 데이터를 줄이는 것&#xD;\r\n            * \\***Predicate Pushdown** : 조회 조건에 맞는 데이터만 읽는 것&#xD;\r\n        * **Inter**-node Parallelism = stage 단위의 병렬 실행&#xD;\r\n        * **Intra**-node Parallelism = stage 내에서 single node의 thread에 걸친 병렬 실행&#xD;\r\n3. Scheduler: Stage Scheduling → Task Scheduling → Split Scheduling&#xD;\r\n    * Task Scheduling = Leaf Stage / Intermediate Stage 분리하여 배치&#xD;\r\n4. Query Execution = Local Data Flow → Shuffles → Writes&#xD;\r\n&#xD;\r\n## DataQuery&#xD;\r\n&#xD;\r\n[NHN Cloud의 DataQuery](https://www.nhncloud.com/kr/service/data-analytics/dataquery?lang=ko) 서비스는 위에서 소개한 Trino를 기반으로 대규모 데이터에 대해 쿼리를 실행할 수 있는 서비스입니다.&#xD;\r\n이를 통해 원하는 클러스터 스펙을 지정하고 연결할 데이터 소스만 작성하면 Trino의 복잡한 설치와 설정 과정 없이 사용이 가능합니다.&#xD;\r\n&#xD;\r\n# Trino 적용 - 개념&#xD;\r\nTrino를 적용하기 위해 알아야 할 개념을 소개합니다.&#xD;\r\n&#xD;\r\n## 데이터 소스 선정&#xD;\r\nTrino는 여러 종류의 데이터 소스를 지원합니다.&#xD;\r\n&#xD;\r\nNHN AppGuard는 로그 저장 기간 증가를 계획하고 있어 저장 비용을 절약하기 위해 OBS를 데이터 소스로 선정하였습니다.&#xD;\r\nOBS 데이터 소스를 사용하는 경우 데이터의 타입도 Parquet, JSON, ORC, CSV, Text 중에 선택해 주어야 해서, 위와 동일한 이유로 Parquet 파일 포맷을 선택하였습니다.&#xD;\r\n&#xD;\r\n### Apache Parquet&#xD;\r\n&#xD;\r\n[Apache Parquet 홈페이지](https://parquet.apache.org)에는 Parquet를 아래와 같이 설명합니다.&#xD;\r\n&#xD;\r\n&gt; Apache Parquet is an open source, column-oriented data file format designed for efficient data storage and retrieval. It provides efficient data compression and encoding schemes with enhanced performance to handle complex data in bulk. Parquet is available in multiple languages including Java, C++, Python, etc...&#xD;\r\n&#xD;\r\n여기서도 키워드를 뽑아보면 아래와 같습니다.&#xD;\r\n&#xD;\r\n* column-oriented data&#xD;\r\n* efficient data storage and retrieval&#xD;\r\n* efficient data compression&#xD;\r\n* encoding schema&#xD;\r\n* handle complex data in bulk&#xD;\r\n&#xD;\r\ncolumn-oriented data의 설명은 아래의 그림을 보시면 이해가 쉽습니다.&#xD;\r\n![Trino_11.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino11.png)&#xD;\r\n&lt;center&gt;(Source: [https://devidea.tistory.com/92](https://devidea.tistory.com/92))&lt;/center&gt;&#xD;\r\n&lt;br&gt;&#xD;\r\n동일한 타입의 데이터가 나열되기 때문에 압축 효율이 높아지는 효과가 있습니다.&#xD;\r\n또한 footer에 데이터에 대한 메타데이터를 저장해 두어 reader에게 데이터에 대한 힌트를 주어 조회 성능을 높입니다.&#xD;\r\n&#xD;\r\n![Trino_12.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino12.png)&#xD;\r\n&lt;center&gt;(source: [https://parquet.apache.org/docs/file-format/](https://parquet.apache.org/docs/file-format/))&lt;/center&gt;&#xD;\r\n&lt;br&gt;&#xD;\r\n## 구상안&#xD;\r\n&#xD;\r\nparquet는 columnar한 형식이기 때문에 row 단위로 데이터를 append하는 것은 비효율적입니다. 그러므로 데이터를 모아서 parquet 형식으로 파일을 생성하는 것이 효율적입니다. 이를 위해 NHN AppGuard에서는 3가지 구성 방법을 고려했고 3번째 안을 선택했습니다.&#xD;\r\n&#xD;\r\n1. micro batch&#xD;\r\n    1. kafka → log-batch → create parquet / 1 minute → save obs → obs&#xD;\r\n    2. trino는 OBS를 사용하는 경우 파일 기반으로 동작하기 때문에 파일의 개수가 많아지면 비효율적입니다.&#xD;\r\n    3. 1분 단위로 파일을 쓸 경우 작은 파일이 많아져 조회 성능이 현저히 떨어지기 때문에 선택하지 않았습니다.&#xD;\r\n2. hourly batch&#xD;\r\n    1. kafka → log-batch → create parquet / 1 hour (save data in memory or redis) → save obs → obs&#xD;\r\n    2. 메모리에 저장하는 경우 데이터 유실의 리스크가 걱정되었고&#xD;\r\n    3. NHN AppGuard는 redis를 사용하고 있지 않아 trino와 redis 두 컴포넌트의 추가로 인한 운영 복잡도 증가가 부담되어 선택하지 않았습니다.&#xD;\r\n3. **중간 DB 사용 - MySQL**&#xD;\r\n    1. kafka → log-batch → save to mysql → mysql → tier down in daily-batch → save obs → obs&#xD;\r\n    2. 기존에 사용하던 MySQL 구성을 변경하지 않아 수정 소요가 적었고&#xD;\r\n    3. MySQL을 통해 실시간 데이터 또한 조회할 수 있어 실시간 데이터 조회가 쉬워 선택하였습니다.&#xD;\r\n&#xD;\r\n### 구성도&#xD;\r\n&#xD;\r\n* AS-IS&#xD;\r\n![Trino_13_900.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino13900.png)&#xD;\r\n&#xD;\r\n* TO-BE&#xD;\r\n![Trino_14_900.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino14900.png)&#xD;\r\n&#xD;\r\n&#xD;\r\n### tier down 개념&#xD;\r\n&#xD;\r\nElasticSearch는 데이터의 역할 또는 접근 빈도에 따라 노드를 분배하는 기법으로 Data Tiering 을 사용합니다.&#xD;\r\n&#xD;\r\n![Trino_15.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino15.png)&#xD;\r\n&lt;center&gt;(source: [https://www.linkedin.com/pulse/navigating-data-tiers-optimizing-costs-reducing-risk-boosting-lim-yfeyc](https://www.linkedin.com/pulse/navigating-data-tiers-optimizing-costs-reducing-risk-boosting-lim-yfeyc))&lt;/center&gt;&#xD;\r\n&lt;br&gt;&#xD;\r\n이렇게 tier를 적용한 데이터를 높은 티어에서 낮은 티어로 낮추는 것을 tier down이라고 부릅니다. hot tier는 일반적으로 성능이 좋고 반응이 빠르지만 비용이 비싸고, cold tier는 반응은 조금 느리지만 비용이 저렴한 저장소를 사용합니다.&#xD;\r\n&#xD;\r\nNHN AppGuard에서는 MySQL을 hot tier, Trino를 cold tier로 정의하고 daily-batch에서 MySQL 데이터를 Parquet로 변환해 Trino에 삽입시키는 작업을 tier down으로 정의했습니다.&#xD;\r\n&#xD;\r\n### Parquet 파일 생성 방법&#xD;\r\n&#xD;\r\nParquet는 원래 HDFS에 쓰는 용도로 고안되어서 Parquet 파일을 직접 쓰려면 `org.apache.hadoop:hadoop-common:3.3.6`과 같은 hdfs writer에 세그먼트 관리, 열 압축 등의 기능을 구현해야 합니다. 이러한 작업을 피하기 위해 일반적으로 Spark 등의 외부 컴포넌트를 쓰거나 avro 포맷의 파일을 거쳤다가 parquet로 변환하는 방법을 사용합니다.&#xD;\r\n&#xD;\r\n[Apache Avro](https://avro.apache.org)는 data를 serialize하기에 좋은 포맷으로 스키마를 갖습니다.&#xD;\r\nParquetFileWriter를 지원하기 때문에 손쉽게 변환이 가능합니다.&#xD;\r\n&#xD;\r\n&gt; Apache Avro™ is the leading serialization format for record data, and first choice for streaming data pipelines. It offers excellent schema evolution, and has implementations for the JVM (Java, Kotlin, Scala, …), Python, C/C++/C#, PHP, Ruby, Rust, JavaScript, and even Perl.&#xD;\r\n&#xD;\r\n# Trino 적용 - 구현&#xD;\r\n&#xD;\r\n## tier down 구현&#xD;\r\n&#xD;\r\n### 논리 구조&#xD;\r\n![Trino_16_900.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino16900.png)&#xD;\r\n&#xD;\r\n&#xD;\r\n### Trino 테이블 생성&#xD;\r\n&#xD;\r\nTrino 데이터 소스로 OBS를 사용하는 경우 Hive를 사용하기 때문에 HQL을 사용해야 합니다. HQL 또한 SQL 표준을 따르기 때문에 거의 유사하지만 묵시적 형 변환과 같은 편의 기능을 지원하지 않고, with 문의 external location, partitioned_by 등의 옵션이 추가됩니다.&#xD;\r\n&#xD;\r\n```sql&#xD;\r\nCREATE TABLE log&#xD;\r\n (&#xD;\r\n    seq              bigint, &#xD;\r\n    log_time         timestamp,&#xD;\r\n    // 생략 &#xD;\r\n    log_date         date,&#xD;\r\n    appkey           varchar(64),&#xD;\r\n ) &#xD;\r\n WITH ( &#xD;\r\n    format = 'Parquet',&#xD;\r\n    external_location = 's3a://data-query/log',&#xD;\r\n    partitioned_by = ARRAY['appkey','date']&#xD;\r\n);&#xD;\r\n```&#xD;\r\n&#xD;\r\n### avro schema 작성&#xD;\r\n&#xD;\r\n```javascript&#xD;\r\n{&#xD;\r\n  \"type\" : \"record\",&#xD;\r\n  \"name\" : \"log\",&#xD;\r\n  \"namespace\" : \"avro\",&#xD;\r\n  \"fields\" : [&#xD;\r\n    { \"name\" : \"seq\", \"type\" : \"long\" },&#xD;\r\n    { \"name\" : \"log_time\", \"type\" : [ \"null\", \"string\" ], \"default\" : null },&#xD;\r\n    // 생략&#xD;\r\n  ]&#xD;\r\n}&#xD;\r\n```&#xD;\r\n&#xD;\r\n### tier down process&#xD;\r\n![Trino_17.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino17.png)&#xD;\r\n데이터를 메모리에 올려서 변환하기 때문에 장비와 데이터에 따라 적절한 페이징을 적용해야 합니다.&#xD;\r\n&#xD;\r\n### convert to parquet&#xD;\r\n![Trino_18.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino18.png)&#xD;\r\navro 변환은 apache avro 모듈의 schema.from 함수로 쉽게 변환이 가능합니다. parquet는 apache parquet 모듈의 PositionOutputStream 객체의 writer를 구현하여 변환할 수 있습니다.&#xD;\r\n&#xD;\r\n### 다른 방법은 없을까?&#xD;\r\nCTAS(Create Table As Select)가 가장 쉬운 방법입니다. 수행 시간은 위 방법과 비슷하게 소요되지만 용량이 30% 정도 더 효율적인 것으로 확인하였습니다. 하지만 DataQuery에서 사내 DB를 아직 데이터 소스로 지원하지 않아 현재는 사용이 어렵습니다.&#xD;\r\n여기에서는 방법만 소개하겠습니다.&#xD;\r\n&#xD;\r\n```sql&#xD;\r\nCREATE TABLE obs.test.log_ctas&#xD;\r\n    WITH (&#xD;\r\n        format = 'Parquet',&#xD;\r\n        external_location = 's3a://ctas-test/log-ctas',&#xD;\r\n        partitioned_by = ARRAY['log_date', 'appkey']&#xD;\r\n        )&#xD;\r\nAS&#xD;\r\nselect seq,&#xD;\r\n// 생략&#xD;\r\n       cast(log_time as date) as log_date,&#xD;\r\n       appkey&#xD;\r\nfrom \"mysql\".log&#xD;\r\nwhere log_time &gt;= date '2024-11-01'&#xD;\r\n  and log_time &lt; date '2024-11-02';&#xD;\r\n```&#xD;\r\n&#xD;\r\n## 실시간 데이터 union 구현&#xD;\r\n&#xD;\r\n### 논리 구성도&#xD;\r\n![Trino_19_900.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino19900.png)&#xD;\r\n1. cold data에 마지막으로 저장된 시간을 조회하고&#xD;\r\n2. cold data와 hot data를 조회해&#xD;\r\n3. join / union 하여 응답합니다.&#xD;\r\n&#xD;\r\n### Data 조회&#xD;\r\n&#xD;\r\nCold - max cold data 기준 왼쪽을 조회합니다.&#xD;\r\n![Trino_20.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino20.png)&#xD;\r\n&#xD;\r\nHot - max cold data 기준 오른쪽을 조회합니다.&#xD;\r\n![Trino_21.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino21.png)&#xD;\r\n&#xD;\r\n### Data Join / Union&#xD;\r\n&#xD;\r\n집계의 경우 toMap과 id 값을 이용해 Join 합니다.&#xD;\r\n![Trino_22.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino22.png)&#xD;\r\n&#xD;\r\n단순 조회의 경우 stream.concat으로 Union 합니다.&#xD;\r\n![Trino_23.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino23.png)&#xD;\r\n&#xD;\r\n# 성능 테스트&#xD;\r\n&#xD;\r\n## 환경&#xD;\r\n&#xD;\r\n* DataQuery 스펙: c2m8 * 3&#xD;\r\n* DataQuery 데이터는(log_date, appKey) 파티셔닝 되어 있고&#xD;\r\n    * 참고 \\*partition = RDBMS의 index 와 유사. parquet 가 저장된 경로를 의미&#xD;\r\n        ![Trino_24.png](https://image.toast.com/aaaadh/real/2025/techblog/Trino24.png)&#xD;\r\n* MySQL 데이터는 일 단위로 파티셔닝되어 있습니다.&#xD;\r\n* MySQL 데이터는 log\\_time, appkey 각각의 인덱스와 (log\\_time, appkey) 복합 index 가 적용되어 있습니다.&#xD;\r\n&#xD;\r\n## 데이터 조회&#xD;\r\n&#xD;\r\n이슈 대응 등의 이유로 개발자가 쿼리 엔진에 자주 질의하는 **일반 쿼리**와 서비스에서 사용하는 **서비스 쿼리**로 구분하여 테스트했습니다.&#xD;\r\n&#xD;\r\n### 일반 쿼리&#xD;\r\n&#xD;\r\n단순한 select \\* 조회는 mysql이 7배가량 빠르고, count 등의 집계 함수가 포함된 쿼리는 DataQuery가 적게는 4배에서 6배가량 빠른 양상을 보였습니다.&#xD;\r\nTrino + Parquet 조합은 열 기반 데이터 포맷으로 인한 행 조회의 비효율성, Trino의 쿼리 플래닝과 file fetch에서의 오버헤드로 인해 단순한 행 조회가 느리기 때문입니다.&#xD;\r\n&#xD;\r\n| 쿼리 | dataquery | mysql |&#xD;\r\n| --- | --------- | ----- |&#xD;\r\n| **단순** 조회 (select \\* limit 500) | &lt;span style=\"color:#e11d21;\"&gt;1 s 151 ms&lt;/span&gt; | &lt;span style=\"color:#0052cc;\"&gt;148 ms&lt;/span&gt; |&#xD;\r\n| **count** 조회 (select count(\\*) 한 달 | &lt;span style=\"color:#0052cc;\"&gt;8 s 957 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;30.987 s&lt;/span&gt; |&#xD;\r\n| filter - appkey \\&amp; log\\_time **행 조회** | &lt;span style=\"color:#e11d21;\"&gt;1 s 323 ms&lt;/span&gt; | &lt;span style=\"color:#0052cc;\"&gt;393 ms&lt;/span&gt; |&#xD;\r\n| filter - appkey \\&amp; log\\_time **count** | &lt;span style=\"color:#0052cc;\"&gt;349 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;14.662 s&lt;/span&gt; |&#xD;\r\n| group by - appkey 하루 | &lt;span style=\"color:#0052cc;\"&gt;814 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;2.385 s&lt;/span&gt; |&#xD;\r\n| group by - appkey 한 달 | &lt;span style=\"color:#0052cc;\"&gt;18 s 530 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;2m 15s 538ms&lt;/span&gt; |&#xD;\r\n&#xD;\r\n### NHN AppGuard 서비스 쿼리&#xD;\r\n&#xD;\r\nDataQuery가 전반적으로 10배 정도 빨랐습니다.&#xD;\r\n이상 행위 탐지 현황의 한 달치 데이터는 MySQL에서 30분 이상 소요되어 조회할 수 없었지만 DataQuery는 36초만에 조회하였습니다.&#xD;\r\n&#xD;\r\n| 쿼리 | dataquery | mysql |&#xD;\r\n| --- | --------- | ----- |&#xD;\r\n| 이상행위 탐지현황 - limit 50 하루 | &lt;span style=\"color:#0052cc;\"&gt;1 s 696 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;9.676s&lt;/span&gt; |&#xD;\r\n| 이상행위 탐지현황 - limit 50 한 달 | &lt;span style=\"color:#0052cc;\"&gt;6 s 468 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;6m 19s 459ms&lt;/span&gt; |&#xD;\r\n| 이상행위 탐지현황 report - 하루 | &lt;span style=\"color:#0052cc;\"&gt;7.06s&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;21s 890ms&lt;/span&gt; |&#xD;\r\n| 이상행위 탐지현황 report - 한 달 | &lt;span style=\"color:#0052cc;\"&gt;36.81s&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;**조회 불가(30분 이상)**&lt;/span&gt; |&#xD;\r\n| 로그 조회 - 하루 | &lt;span style=\"color:#0052cc;\"&gt;1 s 531 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;7s 264ms&lt;/span&gt; |&#xD;\r\n| 로그 조회 - 한 달 | &lt;span style=\"color:#0052cc;\"&gt;5 s 728 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;5m 58s 381ms&lt;/span&gt; |&#xD;\r\n&#xD;\r\n### Parquet 크기별 비교&#xD;\r\n&#xD;\r\nappkey로 파티션 되기 때문에 appkey별 로그 양이 달라 로그 개수에 따른 성능 차이를 비교해 보았습니다. 로그 수 기준 중위의 appkey까지도 MySQL이 더 빠른 양상을 보였습니다. 2-300ms가량의 차이를 보이는 만큼 로그가 적은 사용자 입장에서는 데이터가 없는데 굼뜨다는 느낌을 받을 수 있습니다. 이에 반해 로그 수가 평균을 넘어가면 MySQL은 30초가 넘어가는 응답을 보여 콘솔에서 서비스하기에 어려운 반응 속도를 보입니다.&#xD;\r\n&#xD;\r\n| 대시보드 조회 쿼리 | DataQuery | MySQL |&#xD;\r\n| ---------- | --------- | ----- |&#xD;\r\n| 데이터 없음 | &lt;span style=\"color:#e11d21;\"&gt;267 ms&lt;/span&gt; | &lt;span style=\"color:#0052cc;\"&gt;102 ms&lt;/span&gt; |&#xD;\r\n| 최소 | &lt;span style=\"color:#e11d21;\"&gt;365 ms&lt;/span&gt; | &lt;span style=\"color:#0052cc;\"&gt;100 ms&lt;/span&gt; |&#xD;\r\n| 중위 | &lt;span style=\"color:#e11d21;\"&gt;610 ms&lt;/span&gt; | &lt;span style=\"color:#0052cc;\"&gt;168 ms&lt;/span&gt; |&#xD;\r\n| 평균 | &lt;span style=\"color:#0052cc;\"&gt;505 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;34 s 24 ms&lt;/span&gt; |&#xD;\r\n| 최대 | &lt;span style=\"color:#0052cc;\"&gt;15s 85 ms&lt;/span&gt; | &lt;span style=\"color:#e11d21;\"&gt;10 m 23 s 982 ms&lt;/span&gt; |&#xD;\r\n&#xD;\r\n## 성능 테스트 결론&#xD;\r\n&#xD;\r\n1. 행 전체 조회, 데이터가 적은 경우는 MySQL이 빠르다.&#xD;\r\n    1. 100ms VS 500ms의 차이 → **참을만하다.**&#xD;\r\n2. 집계 조회, 데이터가 많은 경우에는 DataQuery가 빠르다.&#xD;\r\n    1. 수십 초 VS 수 분 차이 → **참을 수 없다.**&#xD;\r\n&#xD;\r\n# 결과&#xD;\r\n&#xD;\r\n## 좋아졌나요?&#xD;\r\n&#xD;\r\n1. 이상 행위 탐지 현황의 30일치 데이터를 조회하지 못하던 고객이 이제 조회할 수 있게 되었습니다.&#xD;\r\n2. 2024년 초 공개한 NHN AppGuard public api는 MySQL로는 30분 이상 소요되어 개발이 어려웠는데, DataQuery를 통해 7초 이내로 조회하여 개발할 수 있었습니다.&#xD;\r\n3. 내부 집계 시간이 38m36s → 22m16s로 약 43% 개선했습니다.&#xD;\r\n4. mysql에서의 집계로 인한 slow query가 제거되어 일 배치로 인한 서비스의 영향성이 없어졌습니다.&#xD;\r\n5. 집계 연산이 빨라져서 집계 데이터의 종류를 늘리는 것에 부담이 없어졌습니다.&#xD;\r\n6. 스토리지 비용 감소로 데이터 저장 기간을 60일에서 1년으로 늘렸습니다.&#xD;\r\n&#xD;\r\n## 나쁜 점은 없나요?&#xD;\r\n&#xD;\r\n1. 대시보드의 기본 응답 속도가 300ms 정도 느려졌습니다.&#xD;\r\n2. tier down 실패 시 집계, 미터링 등에 영향을 주기 때문에 모니터링 요소가 늘어났습니다.&#xD;\r\n3. DataQuery와 OBS 비용이 추가되었습니다. (대략 100만 원/월)&#xD;\r\n&#xD;\r\n## 앞으로 해야 할 것이 있을까요?&#xD;\r\n&#xD;\r\n1. 일 단위 tier down을 시간 단위로 변경하는 것을 고민하고 있습니다.&#xD;\r\n2. 고객 로그 수에 따라 적절한 쿼리 엔진을 사용하도록 최적화하는 부분에 대해 고민하고 있습니다.&#xD;\r\n&#xD;\r\n&#xD;\r\n&#xD;\r\n이상 NHN AppGuard에 Trino를 적용해 본 과정과 결과에 대해 정리하였습니다. 도움이 되셨길 바라며, 긴 글을 읽어 주셔서 감사합니다. &#xD;\r\n&#xD;\r\n[![NHN Cloud_meetup banner_footer_gray_202408_900.png](https://image.toast.com/aaaadh/real/2025/techblog/NHN%20Cloudmeetup%20bannerfootergray202408900.png)](https://www.nhncloud.com/kr)",
    "date": "2025-03-04T02:22:40.000Z",
    "url": "https://meetup.nhncloud.com/posts/391"
  },
  {
    "publisherId": "nhn",
    "publisherName": "NHN Toast 기술블로그",
    "specTitle": "클라우드·웹 개발",
    "categories": [
      "backend",
      "devops"
    ],
    "specUrl": "https://meetup.toast.com/rss",
    "title": "2024 프론트엔드 뉴스 한 방에 몰아 보기",
    "partialText": "![NHN Cloud_meetup banner_frontendnews2024_202412_900.png](https://image.toast.com/aaaadh/real/2024/techblog/NHN%20Cloudmeetup%20bannerfrontendnews2024202412900.png)&#xD;\r\n&#xD;\r\n안녕하세요. NHN Cloud NCUI개발팀 이진우입니다.&#xD;\r\n&#xD;\r\n저는 올해 2월부터 매주 프론트엔드 관련 다양한 뉴스레터를 읽고, FE 개발 직무 동료들에게 흥미로운 뉴스, 읽을거리, 유용한 도구 등을 공유해 왔습니다.&#xD;\r\n어느덧 연말이 가까워지며 쌓여 온 링크들은 상당한 양이 되었는데요. 이를 정리하며 개인적으로 인상 깊었던 주제와 도구를 공유드리고자 합니다.&#xD;\r\n&#xD;\r\n물론, 개인적인 관심사가 반영되어 있기도 하고, 조직 내에서 영향이 큰 프레임워크나 기술 스택 위주로 정리된 만큼 부족한 부분이 있을 수 있습니다.&#xD;\r\n훑어보시면서 혹시 낯설거나 관심이 가는 주제가 있다면 함께 제공한 읽을거리 링크가 도움이 되기를 바랍니다.&#xD;\r\n(정리된 내용 중 일부는 시간이 지나며 업데이트되거나 새로운 정보로 대체되었을 수 있습니다. )&#xD;\r\n&#xD;\r\n## 프론트엔드 기술 스택&#xD;\r\n&#xD;\r\n프론트엔드 개발은 마치 9G 중력 가속도처럼 빠르게 변하며 개발자들을 압박해 왔지만 최근엔 변화의 속도가 다소 안정된 듯한 느낌입니다. ☕️ 새로운 개념을 바탕으로 한 프레임워크와 도구가 끊임없이 쏟아졌던 과거와 달리, 이제는 더 나은 생산성과 사용자 경험을 위한 실용적인 도구들이 점차 정착되고 있습니다. 2024년에 출시되진 않았지만, 개인적으로 올해 활약상이 인상 깊었던 몇 가지 라이브러리를 소개하고자 합니다. ‍&#xD;\r\n&#xD;\r\n### shadcn/ui&#xD;\r\n&#xD;\r\n[shadcn/ui](https://ui.shadcn.com/)는 TailwindCSS와 Headless UI의 철학을 결합한 라이브러리로, 복사-붙여넣기(copy-paste) 방식으로 빠르게 UI를 구현할 수 있는 점이 특징입니다. 개발자는 필요한 컴포넌트를 복사한 뒤, 프로젝트 요구에 맞게 간단히 수정하여 사용할 수 있어 효율성이 뛰어납니다.&#xD;\r\n&#xD;\r\n* [(번역) shadcn/ui의 해부](https://siosio3103.medium.com/shadcn-ui-%EC%9D%98-%ED%95%B4%EB%B6%80-ebd469c34614)&#xD;\r\n* [How headless components became the future for building UI libraries](https://www.subframe.com/blog/how-headless-components-became-the-future-for-building-ui-libraries)&#xD;\r\n* [Headless, boneless, skinless &amp; lifeless UI](https://nerdy.dev/headless-boneless-and-skinless-ui)&#xD;\r\n&#xD;\r\n### Zod&#xD;\r\n&#xD;\r\n[Zod](https://zod.dev/)는 TypeScript와 완벽히 통합된 스키마 선언 및 데이터 검증 라이브러리로, 간결한 문법과 타입 추론을 통해 개발 생산성을 크게 높여 서버-클라이언트 간 데이터 구조를 명확하게 정의하고 유지할 수 있습니다. REST API, GraphQL, Form Data Validation 등 다양한 환경에서 활용 가능하며, 코드의 가독성을 유지하면서도 강력한 검증 로직을 구현할 수 있는 도구입니다.&#xD;\r\n&#xD;\r\n* [The process.env frontend time bomb](https://massimilianomirra.com/notes/the-frontend-process-env-time-bomb-plus-a-sustainable-definition-of-fixed)&#xD;\r\n* [Making a REST API typesafe with Ready Query and Zod](https://noahflk.com/blog/typesafe-rest-api)&#xD;\r\n&#xD;\r\n### Vitest&#xD;\r\n&#xD;\r\n[Vitest](https://vitest.dev/)는 Vite 기반의 테스트 러너로, 빠른 테스트 실행 속도와 간편한 설정으로 주목 받고 있습니다. 테스트 생태계의 하나의 표준과도 같았던 Jest와 유사한 API를 제공해 쉽게 전환이 가능하며, ESM과 TypeScript를 기본적으로 지원합니다. 특히 Vite와의 긴밀한 통합을 통해 개발 환경과 테스트 환경 간의 일관성을 유지할 수 있어 Vite 사용 시 더욱 효율적인 테스트 경험을 제공합니다.&#xD;\r\n&#xD;\r\n* [Vitest vs. Jest](https://www.speakeasy.com/post/vitest-vs-jest)&#xD;\r\n* [Storybook 8.3 - First class Vitest integration](https://storybook.js.org/blog/storybook-8-3/)&#xD;\r\n* [JavaScript unit testing frameworks in 2024: A comparison](https://raygun.com/blog/javascript-unit-testing-frameworks/#vitest)&#xD;\r\n&#xD;\r\n### 기타&#xD;\r\n&#xD;\r\n* [Biome](https://biomejs.dev/)은 ESLint, Prettier의 대체 도구로 빠른 속도를 자랑합니다. 하지만 파일 간의 의존성이나 프로젝트 전반의 정보를 필요로 하는 정적 분석엔 아직 개선이 필요한데, 최근 Biome의 개발자는 [다중 파일 분석의 접근 방법](https://arendjr.nl/blog/2024/11/biome_approach_to_multi_file_analysis/)을 공유했습니다.&#xD;\r\n&#xD;\r\n* 요즘 웹사이트만 들어가면 쿠키 동의 때문에 정신없으시죠? GDPR(general data protection regulation)을 준수하기 위함인데 이와 관련된 라이브러리들([cookieconsent](https://github.com/brainsum/cookieconsent), [cookie checker](https://complydog.com/free-cookie-checker-tool))이 눈에 띄었습니다.&#xD;\r\n&#xD;\r\n* Zod의 대안으로 Yup, AJV, Joi, Superstruct 등이 있지만 TypeScript와의 통합이 부족하거나, 기능이 부족하거나, 러닝 커브가 높기도 합니다. 하지만 최근 [Vailbot](https://valibot.dev/)이 v1 베타 기간을 갖고 있는데, 더 작은 번들 사이즈로도 Zod와 유사한 기능을 제공해 주목을 받고 있습니다.&#xD;\r\n&#xD;\r\n* [TanStack](https://tanstack.com/)은 Tanner Linsley가 운영하는 라이브러리 생태계로, 현재 9개 라이브러리를 운영하며 프론트엔드 개발에서 빠르게 주목 받고 있습니다. 특히 알파 단계인 TanStack Start 프레임워크는 Next.js의 잠재적 경쟁자로 화제가 되고 있으며, TanStack Router는 SSR을 강력히 지원하며 클라이언트 사이드의 인터랙션도 최적화합니다. 또한, 엔터프라이즈급 라우팅을 타입 안전하게 구현하며, 번들링 및 배포는 [Vinxi](https://github.com/nksaraf/vinxi)를 통해 처리해 높은 성능과 유연성을 제공합니다.&#xD;\r\n&#xD;\r\n## React&#xD;\r\n&#xD;\r\n### React Deep Dive&#xD;\r\n&#xD;\r\nNHN Cloud의 FE 개발 조직은 React를 사용하고 있는데요. 사실 React로 기술 스택을 전환한 지는 React의 역사에 비해 그리 오래되지 않았습니다. 시간이 지남에 따라 React 사용에 익숙해지면서 내부 동작 원리에 대한 호기심이 생겼고, 조직 내 몇 명이 모여 React 내부 구조를 알아보는 스터디를 시작했습니다. ‍ 아래는 스터디 과정에서 참고했던 링크들입니다.&#xD;\r\n&#xD;\r\n* [React 톺아보기](https://goidle.github.io/react/in-depth-react-preview/)&#xD;\r\n* [(번역) A deep dive into React Fiber internals](https://bumkeyy.gitbook.io/bumkeyy-code/frontend/a-deep-dive-into-react-fiber-internals)&#xD;\r\n* ▶️ [React 파이버 아키텍처 분석](https://d2.naver.com/helloworld/2690975)&#xD;\r\n* ▶️ [Inside React (동시성을 구현하는 기술)](https://deview.kr/2021/sessions/518)&#xD;\r\n&#xD;\r\n### React 19&#xD;\r\n&#xD;\r\nReact팀은 v19 업데이트를 위해 많은 노력을 기울였습니다. 하지만 최초 v19 RC가 공개된 후 Suspense의 동작 변경으로 인해 여러 컴포넌트가 순차적으로 데이터를 가져오게 되는 워터폴 현상이 발생했습니다.  React 팀은 이 동작이 의도된 동작이 아님을 확인하고 수정하겠다고 밝혔습니다. 이 사건은 오픈 소스 커뮤니티에서 투명한 소통과 협력의 중요성을 다시 한번 환기시켰습니다. 현재 React v19는 `prewarming`이라는 기능을 통해 이슈를 해소하며, 다시 RC v1 단계를 거쳐 현재 [v19](https://github.com/facebook/react/releases/tag/v19.0.0)를 릴리스했습니다. &#xD;\r\n&#xD;\r\n* [React 19 and suspense](https://tkdodo.eu/blog/react-19-and-suspense-a-drama-in-3-acts)&#xD;\r\n* [React core PR - sibiling pre-rendering feature](https://github.com/facebook/react/issues/29898#issuecomment-2477449973)&#xD;\r\n* [What's new in react 19](https://vercel.com/blog/whats-new-in-react-19)&#xD;\r\n* [Server Actions have been renamed to Server Functions](https://19.react.dev/reference/rsc/server-functions)&#xD;\r\n&#xD;\r\n### React Compiler&#xD;\r\n&#xD;\r\nReact v19만큼이나 커뮤니티를 들썩이게 만든 또 다른 주제는 바로 React Compiler(코드명: Forget ‍️)입니다. React는 상태 변경과 리렌더링을 중심으로 동작하지만, 때로는 memoization을 통해 이러한 동작을 최적화해야 할 때가 있습니다. 그러나 이 과정에서 가독성이 떨어지고 오류가 발생하는 경우가 많았습니다. 이러한 문제를 해결하기 위해 React Compiler가 등장했죠. &#xD;\r\n&#xD;\r\nReact Compiler는 memoization 최적화를 자동으로 처리할 뿐만 아니라, 앞으로는 JSX Inlining과 JSX Outlining 같은 기능도 지원할 예정입니다.&#xD;\r\n&#xD;\r\n\\- JSX Inlining: 불필요한 JSX Runtime 호출을 제거하고 미리 빌드된 JSX 객체를 삽입\\.&#xD;\r\n\\- JSX Outlining: 컴파일러가 하위 컴포넌트를 자동으로 추출하여 최적화\\.&#xD;\r\n&#xD;\r\n현재 [베타 릴리스](https://react.dev/blog/2024/10/21/react-compiler-beta-release) 단계이며, React v17 이상에서 사용할 수 있습니다. ✨&#xD;\r\n&#xD;\r\n* [(번역) 리액트 컴파일러 사용법](https://junghan92.medium.com/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%82%AC%EC%9A%A9%EB%B2%95-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-a6a0e96edc97)&#xD;\r\n* [Understanding React Compiler](https://tonyalicea.dev/blog/understanding-react-compiler/)&#xD;\r\n* [Alias analysis in the React Compiler](https://www.recompiled.dev/blog/alias-analysis/)&#xD;\r\n* [Compiler Theory and Reactivity](https://www.recompiled.dev/blog/ssa/)&#xD;\r\n* [Type system of the React Compiler](https://www.recompiled.dev/blog/type-system/)&#xD;\r\n* ▶️ [What's next for the react compiler?](https://www.youtube.com/watch?v=qd5yk2gxbtg)&#xD;\r\n&#xD;\r\n### Next.js&#xD;\r\n&#xD;\r\n[Next.js](https://nextjs.org/)는 React 기반의 풀스택 프레임워크로, 서버와 클라이언트 렌더링을 유연하게 결합해 강력한 개발 경험을 제공합니다. 특히 App Router와 React Server Components(RSC)의 도입으로 동적 라우팅과 성능 최적화가 크게 강화되었습니다.&#xD;\r\n올해 Next.js는 [v14.2](https://nextjs.org/blog/next-14-2), v15 RC [v1](https://nextjs.org/blog/next-15-rc), [v2](https://nextjs.org/blog/next-15-rc2)를 거쳐 정식으로 [v15](https://nextjs.org/blog/next-15)를 릴리스했습니다. 여기에 모노레포(monorepo) 관리를 위한 Turborepo와 차세대 번들러인 Turbopack 또한 긴밀히 통합해 Next.js 생태계를 구축하고 있습니다.&#xD;\r\n&#xD;\r\n* [How vercel adopted microfrontends](https://vercel.com/blog/how-vercel-adopted-microfrontends)&#xD;\r\n* [Turbopack Dev is now stable](https://nextjs.org/blog/turbopack-for-development-stable)&#xD;\r\n* [How to set up next.js 15 for production in 2024](https://www.reactsquad.io/blog/how-to-set-up-next-js-15-for-production)&#xD;\r\n* [Vercel functions - serverless servers and the challenge of new React architecture](https://bobaekang.com/blog/serverless-servers-and-the-challenge-of-new-react-architecture)&#xD;\r\n* [Turborepo installation](https://turbo.build/repo/docs/getting-started/installation#start-with-an-example)&#xD;\r\n* ▶️ [Self-hosting Next.js](https://www.youtube.com/watch?v=sIVL4JMqRfc)&#xD;\r\n&#xD;\r\n### Remix&#xD;\r\n&#xD;\r\n[Remix](https://remix.run/)는 React를 기반으로 한 풀스택 웹 프레임워크로, 서버 사이드 렌더링(SSR)과 클라이언트 사이드 라우팅을 지원하여 빠르고 유연한 웹 애플리케이션 개발을 가능하게 합니다. 2022년 10월, Remix는 [Shopify에 인수](https://remix.run/blog/remixing-shopify)되었으며, 이후 Shopify는 [Hydrogen](https://hydrogen.shopify.dev/)에 Remix를 기반으로 한 기능을 도입해 보다 강력한 전자상거래 플랫폼을 구축했습니다.&#xD;\r\n&#xD;\r\n사실 Remix와 React Router는 아주 긴밀하게 연결되어 있었습니다. 이런 관계로 인해 점점 두 프로젝트의 경계가 모호해지며, Remix는 사실상 React Router의 확장판이 되었습니다. 이에 따라 Remix팀은 React Router 사용자들이 코드 분할, 데이터 로딩, 서버 렌더링 등 Remix의 강력한 기능을 손쉽게 활용할 수 있도록 두 프로젝트의 통합을 결정했습니다.&#xD;\r\n&#xD;\r\n* [Incremental path to React 19](https://remix.run/blog/incremental-path-to-react-19)&#xD;\r\n* ▶️ [Remix Roadmap](https://www.youtube.com/watch?v=fjTX8hQTlEc&amp;t=400s)&#xD;\r\n&#xD;\r\n### 기타&#xD;\r\n&#xD;\r\n리액트 관련해 흥미로웠던 글들을 소개합니다.&#xD;\r\n&#xD;\r\n* [Conceptual Model of React and RSC](https://ondrejvelisek.github.io/conceptual-model-of-react-and-rsc/)&#xD;\r\n* [The two reacts](https://overreacted.io/the-two-reacts/)&#xD;\r\n* [The anatomy of a React Island](https://swizec.com/blog/the-anatomy-of-a-react-island/)&#xD;\r\n* [Locality of Behavior in React Components](https://alexkondov.com/locality-of-behavior-react/)&#xD;\r\n* [React's evolution from Hooks to Concurrent React: From React 16 to 18, a long overview](https://tigerabrodi.blog/reacts-evolution-from-hooks-to-concurrent-react)&#xD;\r\n* [Two ways to the two Reacts](https://bobaekang.com/blog/two-ways-to-the-two-reacts/)&#xD;\r\n&#xD;\r\n## 개발 환경&#xD;\r\n&#xD;\r\n### JavaScript Runtimes&#xD;\r\n&#xD;\r\n한때 크로스 브라우저 호환성이 웹 개발의 주요 화두였다면, 이제는 자바스크립트 런타임 전쟁이 서서히 다가오고 있습니다. 오랜 시간 표준처럼 여겨졌던 [Node.js](https://nodejs.org/en) 외에도 [Deno](https://deno.com/)와 [Bun](https://bun.sh/)이 놀라운 속도로 발전하며 도전장을 내밀고 있습니다. 여기에 [LLRT](https://github.com/awslabs/llrt)와 같은 새로운 도구들까지 등장하면서, 자바스크립트 런타임 생태계는 이제 다양한 선택지와 경쟁으로 가득 찬 새로운 시대를 맞이하고 있습니다. 한편, Node.js 또한 선두 주자로서 입지를 지키기 위해 새로운 기술을 적극 수용하며 생태계를 확장하고 우위를 유지하려는 노력을 이어가고 있습니다.&#xD;\r\n&#xD;\r\n* [JS Toolbox 2024: Runtime environments &amp; package management](https://raygun.com/blog/js-toolbox-part-1/)&#xD;\r\n* [Runtime Compatibility](https://runtime-compat.unjs.io/)&#xD;\r\n* [Node Core PR module: add --experimental-transform-types](https://github.com/nodejs/node/pull/54283)&#xD;\r\n* [Native Support for CJS/ESM Interoperability Begins in Node.js 22](https://webdeveloper.beehiiv.com/p/native-support-cjsesm-interoperability-begins-nodejs-22)&#xD;\r\n* [Node.js takes steps towards removing corepack](https://socket.dev/blog/node-js-takes-steps-towards-removing-corepack)&#xD;\r\n&#xD;\r\n### Package Managers&#xD;\r\n&#xD;\r\n다양한 JavaScript Runtime들만큼이나 프로젝트 의존성 관리와 패키지 설치를 돕는 Package Manager도 전통적인 npm과 Yarn을 넘어 더 빠르고 효율적인 대안들이 떠오르며 경쟁이 치열해지고 있습니다. &#xD;\r\n&#xD;\r\n[pnpm](https://pnpm.io/ko/)은 디스크 공간 효율성과 모노레포(monorepo) 지원을 강점으로, [Bun](https://bun.sh/)은 올인원 도구로 놀라운 설치 속도를 자랑합니다. 또한 [JSR](https://jsr.io/docs/with/deno)은 다양한 JavaScript Runtime과 호환되며 TypeScript와 ESM을 네이티브로 지원해 현대적인 모듈 관리를 선도하고 있습니다. npm의 개발자는 새롭게 팀을 만들어 [vlt](https://www.vlt.sh/client)라는 패키지 매니저와 레지스트리인 [vsr](https://www.vlt.sh/serverless-registry)까지 출시했습니다.&#xD;\r\n&#xD;\r\n각 Package Manager는 고유의 특징과 강점을 바탕으로 개발자들에게 더 나은 선택지를 제공하며, 자바스크립트 생태계를 넓히고 있습니다.&#xD;\r\n&#xD;\r\n* [Introducing Deno 2](https://deno.com/blog/v2.0)&#xD;\r\n* [Bun 1.1](https://bun.sh/blog/bun-v1.1)&#xD;\r\n* [vlt - Introducing our team, investors &amp; more](https://blog.vlt.sh/blog/the-team)&#xD;\r\n&#xD;\r\n### Build Tools&#xD;\r\n&#xD;\r\n현대적인 프론트엔드 개발을 위한 빌드 도구는 결국 [Vite](https://vite.dev/) 아래 모이게 되었습니다.  [Remix가 Vite로 마이그레이션](https://remix.run/blog/remix-vite-stable)되었고, [Angular의 툴 체인](https://v17.angular.io/guide/esbuild)에도 도입되었으며, 그 외 수많은 라이브러리와 프레임워크가 Vite 위에 구축되어 오고 있습니다. 이로 인해 Vite의 주간 npm 다운로드 수는 1,700만건 가까이 기록하고 있으며 Next.js를 제외한 주요 생태계를 점령했습니다.&#xD;\r\n&#xD;\r\nEvan You에 의하면 Vite팀은 소스 파일에서 AST를 만들고, Linting, Formatting, Testing 등 모든 과정을 네이티브 수준의 속도로 처리는 툴체인을 구축하려는 목표를 세웠고 실제로 [VoidZero](https://voidzero.dev/posts/announcing-voidzero-inc)라는 회사를 설립해 투자 유치에 성공했습니다.&#xD;\r\n&#xD;\r\n최근 릴리스된 Vite 6.0에선 [Environment API](https://main.vite.dev/guide/api-environment)를 추가해 단일 Vite 서버에서 필요한 만큼 환경을 생성해 앱이 동작하는 방식을 매핑할 수 있게 됩니다. Vite는 이제 Deno, Bun과 같은 JavaScript Runtime으로 실행과 번들링이 가능해지고, React Native나 Electron과 같은 특수한 Runtime도 지원합니다.&#xD;\r\n&#xD;\r\n* [Vite Dev Server 이해하기](https://1ilsang.dev/posts/js/dev-server)&#xD;\r\n* [Increasing Vite's potential with the Environment API](https://green.sapphi.red/blog/increasing-vites-potential-with-the-environment-api)&#xD;\r\n* ▶️ [Visual Guide to the Modern Frontend Toolchain - Vite](https://youtu.be/M_edImKoEt8?si=RL1VrRyD1BYhqEnA)&#xD;\r\n&#xD;\r\n### Bundler&#xD;\r\n&#xD;\r\n현재 개발에 박차를 가하고 있는 차세대 번들러들은 Rust 기반으로 설계되어 기존의 Parcel, Rollup, Webpack에 비해 더욱 빠르고 강력한 성능을 자랑합니다. ⚡️ 물론, 일부 개발자들은 이런 장점을 위해 모든 것을 새로 만드는 것이 과연 필요한가에 대한 의문을 제기하기도 합니다.&#xD;\r\n&#xD;\r\n하지만, Go로 작성된 [esbuild](https://esbuild.github.io/)로 Dev Server를 제공하는 Vite를 경험하고 나니, 다시 Webpack으로 돌아가는 일이 무척 멀게만 느껴지는 것도 사실입니다.&#xD;\r\n&#xD;\r\n차세대 번들러를 간단히 살펴보자면, [Rspack](https://rspack.dev/)은 Webpack의 [Drop-in Replacement](https://rspack.dev/guide/migration/webpack#migrate-from-webpack)로 호환성과 성능을 강조하고 있으며, [Turbopack](https://nextjs.org/docs/architecture/turbopack)은 안정화 단계를 거쳐 [Next.js v15의 권장 도구](https://nextjs.org/blog/next-15#turbopack-dev)로 자리 잡으며 Webpack의 후계자를 자처하고 있습니다. 또한 Vite 진영에서도 [Rolldown](https://rolldown.rs/)이라는 차세대 도구를 개발 중입니다. 마지막으로 또 내가 제일 빠르다고 하는 [Mako](https://makojs.dev/)도 있네요.&#xD;\r\n&#xD;\r\n각 도구들이 경쟁하며 프론트엔드 생태계에 바람을 일으키고 있습니다. 앞으로 누가 이 씬을 주도하게 될지 기대가 됩니다. &#xD;\r\n&#xD;\r\n* [Rspack announcing 1.0](https://rspack.dev/blog/announcing-1-0)&#xD;\r\n* [Rslib](https://github.com/web-infra-dev/rslib)&#xD;\r\n* [Lessons learned switching to Rspack](https://birtles.blog/2024/08/14/lessons-learned-switching-to-rspack)&#xD;\r\n* [Why does Vercel bother with Turbopack when Vite already exists?](https://github.com/vercel/next.js/issues/48748#issuecomment-2199941311)&#xD;\r\n* [Why we are building Rolldown](https://rolldown.rs/about#why-we-are-building-rolldown)&#xD;\r\n&#xD;\r\n## 프레임워크&#xD;\r\n&#xD;\r\n### Vue&#xD;\r\n&#xD;\r\nVue는 올해 [v3.5](https://blog.vuejs.org/posts/vue-3-5)의 첫 번째 마이너 릴리스를 발표하며 성능과 메모리 최적화, SSR 지원에 주력했습니다. 특히, 반응형 시스템을 리팩터링하여 메모리 사용량을 56% 감소시키고, 대규모 및 깊은 배열의 처리 성능을 눈에 띄게 향상시켰습니다. Vue 역시 SSR(Server-Side Rendering) 지원 강화를 목표로 새로운 기능들을 추가하며, 현대적인 웹 애플리케이션 개발을 위한 진화를 계속하고 있습니다.&#xD;\r\n&#xD;\r\n* [10 Years of Vue: the Past and the Future](https://www.youtube.com/watch?v=OmrwRrZitv4)&#xD;\r\n&#xD;\r\n### Angular&#xD;\r\n&#xD;\r\n올해 Angular는 3월, 구글의 내부 프레임워크 [Wiz와의 통합](https://blog.angular.dev/angular-and-wiz-are-better-together-91e633d8cd5a)을 발표했습니다. Wiz는 Gmail, Search와 같은 성능이 중요한 서비스에서 사용되는 프레임워크로 이번 통합은 SSR 지원 강화를 목적으로 이루어졌습니다. 이어 5월에는 [v18](https://blog.angular.dev/angular-v18-is-now-available-e79d5ac0affe)을 발표하며 변경 감지 라이브러리 추출, 홈페이지 개편, 그리고 SSR 기능 강화를 진행했습니다. 11월에는 [v19](https://blog.angular.dev/meet-angular-v19-7b29dfd05b84)가 [릴리스](https://github.com/angular/angular/releases/tag/19.0.0)되며, 부족했던 렌더링 모드의 다양화, Hydration 제어 개선, 그리고 Signal 도입이라는 큰 변화를 선보였습니다.&#xD;\r\n&#xD;\r\n* [Google Angular Lead sees convergence in JavaScript Framework](https://thenewstack.io/google-angular-lead-sees-convergence-in-javascript-frameworks/)&#xD;\r\n* [Managing Angular](https://blog.mgechev.com/2024/08/25/managing-angular/)&#xD;\r\n&#xD;\r\n### Svelte&#xD;\r\n&#xD;\r\nSvelte는 [v5](https://svelte.dev/blog/svelte-5-is-alive) 릴리스를 통해 패러다임의 전환을 알렸습니다. 과거에는 `let count = 0`만 작성해도 Svelte의 컴파일러가 이를 상태로 처리했지만, 이제는 더 명시적으로 상태를 선언하는 방식으로 변화했습니다. 새로운 메커니즘인 [runes](https://svelte.dev/blog/runes)가 도입되었으며, `$state()`를 통해 반응형 상태를 명확히 관리할 수 있게 되었습니다.&#xD;\r\n&#xD;\r\n### Astro&#xD;\r\n&#xD;\r\nAstro는 최근 [v5](https://astro.build/blog/astro-5/) 업데이트에서 타입 안전 환경 변수 설정을 지원하며 환경 변수의 가시성과 안전성을 강화했습니다. 또한 Content Layer API를 통해 다양한 데이터 소스에서 가져온 콘텐츠를 타입 안전하게 관리할 수 있게 되었으며, 렌더링 기능을 강화해 페이지와 컴포넌트별로 SSR과 정적 생성을 유연하게 선택할 수 있게 했습니다.&#xD;\r\n&#xD;\r\n### Hono&#xD;\r\n&#xD;\r\n[Hono](https://hono.dev/)는 모든 JavaScript Runtime에서 실행 가능한 경량 웹 서버 프레임워크로, 빠른 라우팅을 지원하는 RegExpRouter 개념과 여러 헬퍼, 미들웨어로 주목 받고 있습니다.&#xD;\r\n&#xD;\r\n### Waku&#xD;\r\n&#xD;\r\n[Waku](https://waku.gg/)는 Zustand와 Jotai 진영에서 개발한 리액트 기반 풀스택 프레임워크로, React의 Server Action API를 지원하는 [v0.21](https://waku.gg/blog/server-actions-are-here)을 출시했습니다. 중규모 애플리케이션 개발을 목표로 하며, Next.js의 대안으로 기대를 받고 있습니다.&#xD;\r\n&#xD;\r\n## 다양한 렌더링 모드&#xD;\r\n&#xD;\r\n최근 프론트엔드 프레임워크들은 다양한 렌더링 방식을 제공하여 각자의 장점을 활용한 최적화 전략을 선보이고 있습니다.&#xD;\r\nCSR(Client-Side Rendering)은 동적이고 빠른 사용자 경험(UX)을 제공하지만, 초기 HTML이 서버에서 제공되지 않기 때문에 SEO에는 다소 불리합니다.&#xD;\r\n이에 반해, SSR(Server-Side Rendering)과 SSG(Static-Site Generation)은 초기 페이지 로드 시 완전한 HTML을 제공해 SEO와 성능 최적화에 유리합니다. Astro는 [Islands Architecture](https://jasonformat.com/islands-architecture)를 활용해 정적 콘텐츠와 인터랙티브 요소를 분리하고, Server Islands를 통해 필요한 동적 콘텐츠만 효율적으로 로드합니다. 또한, Next.js는 [PPR(Partial Pre-Rendering)](https://vercel.com/blog/partial-prerendering-with-next-js-creating-a-new-default-rendering-model)을 통해 동적 콘텐츠를 스트리밍 하며 점진적 렌더링 방식을 선도하고 있습니다.&#xD;\r\n이런 다양한 렌더링 방식들은 앱의 목적과 성능 요구 사항에 따라 적절히 선택할 필요가 있습니다.&#xD;\r\n&#xD;\r\n* [Client-Side Rendering](https://github.com/theninthsky/client-side-rendering)&#xD;\r\n* [What's a Single-Page App?](https://jakelazaroff.com/words/whats-a-single-page-app/)&#xD;\r\n* [How to choose the best rendering strategy for your app](https://vercel.com/blog/how-to-choose-the-best-rendering-strategy-for-your-app)&#xD;\r\n&#xD;\r\n## JavaScript&#xD;\r\n&#xD;\r\n### Signals&#xD;\r\n&#xD;\r\nECMAScript 위원회인 TC39에 [Signal 도입 제안](https://github.com/tc39/proposal-signals)이 올라왔습니다. [Preact](https://preactjs.com/), [Solid](https://solidjs.com/)와 같은 프레임워크는 이미 Signal을 활용하여 Reactivity를 구현하고 있습니다.&#xD;\r\nSignal은 애플리케이션 상태를 관리하는 방식으로, 상태 변경 시 UI를 업데이트합니다. React의 상태 변경이 전체 리렌더링을 유발하는 반면, Signal은 세분화된 상태 변경을 처리하여 렌더링 없이 최소한의 작업으로 UI를 갱신합니다. 이 제안을 통해 여러 프레임워크에서 중복된 Reactivity 모델을 제거하고, 개발 도구에서도 Signal의 활용이 기대됩니다.&#xD;\r\n&#xD;\r\n* [How to Build Signals from Scratch](https://www.freecodecamp.org/news/learn-javascript-reactivity-build-signals-from-scratch/)&#xD;\r\n&#xD;\r\n### Temporal&#xD;\r\n&#xD;\r\n새로운 날짜 및 시간 처리 기능인 Temporal이 [Stage 3](https://github.com/tc39/proposal-temporal)에 도달했습니다. 기존 JavaScript의 `Date` 객체가 가진 문제들을 해결하기 위해 설계되었으며, 개발자들이 보다 직관적이고 강력한 시간 처리를 할 수 있도록 도울 것입니다.&#xD;\r\n&#xD;\r\n* [JS Dates are about to be fixed](https://docs.timetime.in/blog/js-dates-finally-fixed)&#xD;\r\n&#xD;\r\n### ECMAScript 2024&#xD;\r\n&#xD;\r\n2024년 ECMAScript 언어 사양이 승인되면서 새로운 기능들이 추가되었습니다. 주요 기능으로는 `Promise.withResolvers()`, `Object.groupBy`, `Map.groupBy` 등이 있습니다. 과거처럼 대규모 신규 개념이 추가되기보다는 기존 기능의 개선과 최적화가 주를 이루는 모습입니다.&#xD;\r\n&#xD;\r\n* [ECMAScript 2024](https://2ality.com/2024/06/ecmascript-2024.html)&#xD;\r\n* [What's new in ECMAScript 2024](https://pawelgrzybek.com/whats-new-in-ecmascript-2024/)&#xD;\r\n* [The state of ES5 on the web](https://philipwalton.com/articles/the-state-of-es5-on-the-web/)&#xD;\r\n&#xD;\r\n### 기타&#xD;\r\n&#xD;\r\nTC39는 기존에 JavaScript 표준 프로세스에서 Stage를 [0~4 단계](https://tc39.es/process-document/)로 유지했으나, 최근 [Stage 2.7](https://thenewstack.io/inside-ecmascript-javascript-standard-gets-an-extra-stage/)을 추가했습니다. 이는 Stage 3에서 Stage 2로 롤백될 경우 발생하는 리소스를 줄이고, 작업 효율성을 향상시키기 위한 조치로 보입니다.&#xD;\r\n&#xD;\r\n## CSS&#xD;\r\n&#xD;\r\n### CSS-in-JS&#xD;\r\n&#xD;\r\nCSS-in-JS는 SSR의 활성화에 따라 한동안 인기를 잃어 왔지만 React v19의 새로운 기능으로 다시 주목을 받고 있습니다. 특히 스타일 호이스팅(precedence 속성을 사용해 `&lt;style&gt;` 태그를 문서 헤드로 이동)을 지원하며, 온디맨드 스타일 렌더링이 개선되었습니다. 이에 따라 [Restyle](https://www.restyle.dev/), [StyleX](https://stylexjs.com/blog/introducing-stylex), [PandaCSS](https://panda-css.com/)와 같은 라이브러리가 주목 받고 있으며, MUI는 [PigmentCSS의 도입](https://mui.com/blog/introducing-pigment-css)을 시도하고 있습니다. 또한 CSS-in-JS의 리소스 문제를 극복한 Compiled CSS-in-JS 방식도 주목을 받고 있습니다.&#xD;\r\n&#xD;\r\n* [CSS in React Server Components](https://www.joshwcomeau.com/react/css-in-rsc/)&#xD;\r\n* [Why is CSS-in-JS slow?](https://playfulprogramming.com/posts/why-is-css-in-js-slow)&#xD;\r\n* [A preview of Pigment CSS: the next generation of CSS-in-JS](https://mui.com/blog/introducing-pigment-css/)&#xD;\r\n&#xD;\r\n### CSS 신규 기능&#xD;\r\n&#xD;\r\n2024년에는 CSS의 새로운 스펙들이 도입되며, 작년에 이어 [Baseline](https://web.dev/baseline)과 [Interop](https://web.dev/blog/interop-2024)과 같이 플랫폼 간 상호운용성에 대한 노력이 CSS 생태계가 더욱 강력하게 만들고 있습니다. `@property` 문법으로 CSS 변수를 선언하고 속성을 정의하거나, Popover API로 번거롭던 Modal 문제를 해결하는 등 개발자의 생산성을 크게 향상시키고 있습니다. 이번에는 2024년 도입된 주요 기능과 개인적으로 관심을 가졌던 최신 CSS 관련 링크를 공유 드립니다.&#xD;\r\n&#xD;\r\n* [CSS Container Queries](https://css-tricks.com/css-container-queries/)&#xD;\r\n* [If CSS gets inline conditionals](https://css-tricks.com/if-css-gets-inline-conditionals/)&#xD;\r\n* [CSS anchor API](https://developer.chrome.com/blog/anchor-positioning-api)&#xD;\r\n* [Popover API lands in Baseline](https://web.dev/blog/popover-api)&#xD;\r\n* [The undeniable utility of CSS `:has`](https://www.joshwcomeau.com/css/has/)&#xD;\r\n* [CSS `@property` and the new style](https://ryanmulligan.dev/blog/css-property-new-style/)&#xD;\r\n* [New CSS that can actually be used in 2024](https://thomasorus.com/new-css-that-can-actually-be-used-in-2024.html)&#xD;\r\n* [Old Dogs, new CSS Tricks](https://mxb.dev/blog/old-dogs-new-css-tricks/)&#xD;\r\n* [A Framework for evaluating browser support](https://www.joshwcomeau.com/css/browser-support/)&#xD;\r\n* [CSS Wrapped 2024](https://chrome.dev/css-wrapped-2024/)&#xD;\r\n* ▶️ [Amazing CSS in 2024](https://www.youtube.com/watch?v=D79TND9w_AY)&#xD;\r\n&#xD;\r\n### Masonry 레이아웃&#xD;\r\n&#xD;\r\n오랫동안 웹 개발자들은 Pinterest 스타일의 Masonry 레이아웃을 구현하기 위해 JavaScript에 의존해왔습니다.  그러나 이제 CSS가 이 기능을 네이티브로 지원할 준비를 하고 있으며 이를 구현하는 방식에 대해 [Chrome팀](https://rachelandrew.co.uk/archives/2024/09/21/masonry-and-good-defaults)과 [Webkit팀](https://webkit.org/blog/15269/help-us-invent-masonry-layouts-for-css-grid-level-3/) 간에 새로운 `display`를 추가할지, `grid` 내에 통합할지 [논의](https://webkit.org/blog/16026/css-masonry-syntax/)가 이어지고 있습니다.&#xD;\r\n&#xD;\r\n## Performance&#xD;\r\n&#xD;\r\n### e18e&#xD;\r\n&#xD;\r\nJavaScript 생태계의 성능 향상을 목표로 한 커뮤니티 기반 이니셔티브 [e18e(Ecosystem Performance)](https://e18e.dev/)가 실질적인 진전을 이루며 주목 받고 있습니다. e18e는 다음 세 가지 목표를 중심으로 자바스크립트 생태계의 개선을 추진하고 있습니다.&#xD;\r\n&#xD;\r\n1. Clean up: 인기 있는 패키지의 중복된 의존성 제거 또는 대체를 통해 속도를 최적화.&#xD;\r\n2. Speed up: 널리 사용되는 패키지와 프레임워크의 성능 개선.&#xD;\r\n3. Level up: 오래된 패키지에 대해 더 가볍고 모던한 대안을 마련.&#xD;\r\n&#xD;\r\n이니셔티브의 노력은 커뮤니티의 참여로 이루어지며, 최신 패치 목록과 대안을 제안하는 [module-replacements](https://github.com/es-tooling/module-replacements)와 같은 결과물로 나타나고 있습니다.&#xD;\r\n최근 공개된 [October Contribution Showcase](https://e18e.dev/blog/october-contributions-showcase.html)에서는 Storybook과 ESLint 같이 널리 사용되는 도구에 대한 기여가 눈에 띕니다. 이를 통해 e18e는 자바스크립트 생태계의 전반적인 성능을 끌어올리는 데 실질적인 역할을 하고 있으며, 커뮤니티와 오픈 소스 생태계의 협력을 이끌어내고 있습니다.&#xD;\r\ne18e는 단순히 성능 개선을 넘어, 개발자들이 사용하는 핵심 도구를 더 가볍고 빠르게 만들어 생태계 전반에 긍정적인 영향을 미칠 것으로 기대됩니다.&#xD;\r\n&#xD;\r\n### Web Vitals - INP&#xD;\r\n&#xD;\r\n[Web Vitals](https://web.dev/articles/vitals)는 Google이 정의한 웹 성능 지표로, 사용자 경험(UX)을 개선하기 위한 기준을 제공합니다. 2024년 정식으로 선정된 [INP(Interaction to Next Paint)](https://web.dev/articles/inp)는 사용자 상호작용 후 다음 화면이 렌더링될 때까지의 지연 시간과 응답성을 측정하며, 기존 FID(First Input Delay)보다 더 포괄적이고 실질적인 경험을 반영합니다. INP는 사용자 입력 이벤트를 우선 처리하고, 비동기 렌더링을 최적화하는 등 동시성 기술을 통해 개선할 수 있습니다.&#xD;\r\n&#xD;\r\n* [What is INP and why you should care](https://blog.sentry.io/what-is-inp/)&#xD;\r\n* [Understanding Interaction to Next Paint(INP)](https://frontendmasters.com/blog/understanding-inp/)&#xD;\r\n* [Investigating INP issues](https://www.stefanjudis.com/blog/investigating-inp-issues/)&#xD;\r\n* [How to improve INP in React](https://kurtextrem.de/posts/improve-inp-react)&#xD;\r\n* [How to Improve INP: Yield Patterns](https://kurtextrem.de/posts/improve-inp)&#xD;\r\n* [Demystifying INP: New tools and actionable insights](https://vercel.com/blog/demystifying-inp-new-tools-and-actionable-insights)&#xD;\r\n&#xD;\r\n## 기타&#xD;\r\n&#xD;\r\n### Mobile&#xD;\r\n&#xD;\r\n모바일 개발 생태계에서도 큰 변화가 이어지고 있습니다. React Native는 [새로운 아키텍처](https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here)로 재작성되어 [v0.76](https://reactnative.dev/blog/2024/10/23/release-0.76-new-architecture)에서 동기식 네이티브 통신, 동시성 시스템, 새로운 이벤트 루프를 도입하며 성능과 안정성을 크게 개선했습니다. 한편, Google의 Flutter는 최근 조직 축소와 커뮤니티 대응 지연으로 비판을 받아 왔으며, 이에 대응해 커뮤니티가 Flutter를 포크한 [Flock](https://flutterfoundation.dev/blog/posts/we-are-forking-flutter-this-is-why)를 발표했습니다. Flock은 문제 해결에 집중하고 있지만 인원 부족으로 인상적인 성과를 내기 어려울 것이라는 전망도 있습니다. 이러한 변화들은 크로스 플랫폼 개발의 미래를 더욱 흥미롭게 만들고 있습니다.&#xD;\r\n&#xD;\r\n### Architecture&#xD;\r\n&#xD;\r\n개인적으로 소프트웨어 설계 관련해 기억나는 포스트는 C4 모델을 응용한 Visualizing Frontend Architecture와 FSD(Feature-Sliced Design)입니다. C4 모델은 소프트웨어 시스템을 Context, Container, Component, Code의 4가지 레벨로 나누어 시각화하는 방식으로, 이를 프론트엔드에 적용해 아키텍처를 명확히 표현한 접근이 인상 깊었습니다.&#xD;\r\n한편, FSD는 기능(feature) 단위로 관심사를 분리하여 모듈화된 폴더 구조를 설계하는 방식으로, 대규모 프로젝트의 유지 보수성과 확장성을 크게 향상시킵니다. 이러한 접근법들은 구조적 명확성을 제공하며, 올해 프론트엔드 설계에서 중요한 흐름으로 자리 잡았습니다.&#xD;\r\n&#xD;\r\n* ▶️ [Visualising software architecture with the C4 model](https://www.youtube.com/watch?v=x2-rSnhpw0g)&#xD;\r\n* [Visualizing Frontend Architecture](https://frontendatscale.com/issues/17)&#xD;\r\n* [Feature-Slided Design Pattern](https://feature-sliced.design/)&#xD;\r\n* [FSD 관점으로 바라보는 코드 경계 찾기](https://velog.io/@teo/fsd)&#xD;\r\n* [프론트엔드 개발자 관점으로 바라보는 관심사의 분리와 좋은 폴더 구조 (feat. FSD)](https://velog.io/@teo/separation-of-concerns-of-frontend)&#xD;\r\n&#xD;\r\n### IT 뉴스&#xD;\r\n&#xD;\r\n* 미국 법무부는 2024년, ADA(미국 장애인 법)에 따라 웹 콘텐츠와 모바일 애플리케이션의 [접근성 규정을 발표](https://www.tpgi.com/the-ada-now-has-regulations-for-accessibility-of-web-content-and-mobile-apps/)했습니다. 이는 공공 기관이 운영하는 디지털 콘텐츠가 WCAG 2.1 레벨 AA 기준을 충족하도록 요구하며, 장애인을 위한 더 나은 디지털 접근성을 보장합니다. 민간 기업에도 간접적인 영향을 미칠 것으로 보입니다.&#xD;\r\n* 영국 정부가 인도양 차고스 제도(British Indian Ocean Territory)의 주권을 포기하며 [.io 도메인이 사라질 예정](https://every.to/p/the-disappearance-of-an-internet-domain)입니다. 새로운 등록이 중단되며, 기존 도메인 역시 점진적으로 폐기 프로세스가 시작됩니다. .io 도메인을 사용하는 많은 기업에 영향을 미칠 것으로 보입니다. 하지만 .su 도메인이 특수 사례로 살아남은 적이 있어 어떤 식으로 흘러갈지는 지켜봐야 할 것 같습니다.&#xD;\r\n* 올해 Sentry는 [페어 소스(Fair Source)](https://fair.io/)라는 새로운 소프트웨어 라이선스를 도입한다고 했습니다. 이는 오픈 소스와 유사하게 코드를 공개적으로 공유하지만, 제작자의 비즈니스 모델을 보호하기 위해 사용, 수정, 재배포에 제한을 두는 것이 특징입니다. 또한 지연된 오픈소스 퍼블리싱(DOSP) 방식으로 초기에는 독점 라이선스를 유지하다가 일정 계획에 따라 오픈소스화합니다.&#xD;\r\n&#xD;\r\n***&#xD;\r\n&#xD;\r\n막상 정리를 해보겠다고 마음먹고 주요 기술 스택과 뉴스를 간추리는 데 생각보다 시간이 오래 걸렸습니다. 내년에도 같은 작업을 이어간다면 반기로 나누어 진행해야 할 것 같습니다. 처음에는 2~3개의 뉴스레터로 시작했지만, 욕심이 생겨 점점 범위를 넓히다 보니 지금은 UI/UX와 디자인까지 포함해 매주 약 19개의 뉴스레터를 훑고 있는 상황입니다. &#xD;\r\n&#xD;\r\n뉴스레터로 알게 된 내용을 실제로 제품에 적용해 볼 기회는 많지 않았지만, 프론트엔드 트렌드를 파악하고, 우리 팀과 조직에서 적용해 볼 만한 부분을 점검할 수 있었다는 점에서 개인적으로 만족스러웠습니다. 본 글에서 다루지 못했지만 JavaScript의 AI, Privacy 강화, WASM과 같은 주제에도 변화가 있었습니다. 관심 있는 분들은 관련 내용을 찾아보시는 것도 추천드립니다.&#xD;\r\n&#xD;\r\n앞으로도 새롭게 등장할 기술들 속에서 각자의 서비스에 적합한 것을 선택하고 도입하며, 변화에 유연하게 대응해 나가길 바랍니다. &#xD;\r\n(혹시라도 깨진 링크나 잘못된 내용이 있다면 제보 부탁드립니다. )&#xD;\r\n&lt;br&gt;&#xD;\r\n[![NHN Cloud_meetup banner_footer_blue_202412_900.png](https://image.toast.com/aaaadh/real/2024/techblog/NHN%20Cloudmeetup%20bannerfooterblue202412900.png)](https://www.nhncloud.com/kr)",
    "date": "2024-12-16T04:57:57.000Z",
    "url": "https://meetup.nhncloud.com/posts/390"
  }
]