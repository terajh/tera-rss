[
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "2026년 2월 출간 IT 원서들 기대평",
    "partialText": "2월에 나온/나올 영어 IT 전문서 몇 권 소개합니다.\n\n## Designing Data-Intensive Applications, 2nd ...",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://occamsrazr.net/tt/439"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "무한의 덧셈",
    "partialText": "딸이 덧셈 뺄셈을 배우며 힘들어 하는 걸 보며 도와줄 수 있는 방법이 없을까 생각들었습니다. 간단한 게임을 만들어 보면 어떨까?",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://jeho.page/essay/2026/02/14/infinite-addition.html"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "기술 뉴스 #288 : 26-02-16",
    "partialText": "<h1>웹개발 관련</h1>\n\n<ul>\n<li><strong><a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-6-0-beta/\">Announcing TypeScript 6.0 Beta</a></strong> : 직접 다운로드받아서 사용해 볼 수 있는 TypeScript 6.0 Beta 버전이 나왔다. 6.0은 JavaScript 코드 베이스를 기반으로 한 마지막 릴리스로 TypeScript 컴파일러와 관련 생태계를 Go로 바꾸고 있어서 Go 기반의 7.0으로 넘어가기 위한 다리 역할을 하는 버전이다.(영어)</li>\n<li><strong><a href=\"https://2025.stateofjs.com/\">The State of JS 2025</a></strong> : 매년 발표되는 JavaScript 생태계의 설문조사로 올해는 1만여 명이 응답자로 참여했다. JavaScript 언어의 새 기능이나 브라우저 API의 인지도 등을 볼 수 있다. 다양한 분류로 시각화해 두어서 주류인 기술과 새롭게 관심받는 기술을 알 수 있다.(영어)</li>\n<li><strong><a href=\"https://developer.chrome.com/blog/webmcp-epp?hl=ko\">WebMCP를 사전 체험판으로 이용할 수 있습니다.</a></strong> : Chrome에서 에이전트가 브라우저를 사용할 수 있도록 WebMCP를 제안하고 사전 체험 프로그램을 통해서 사용해 볼 수 있게 한다. WebMCP는 HTML을 이용한 선언적 API와 JavaScript를 이용할 수 있는 명령형 API를 제공한다.(한국어)</li>\n<li><strong><a href=\"https://vercel.com/blog/introducing-the-new-v0\">Introducing the new v0</a></strong> : 프롬프트를 입력하면 UI와 코드를 생성할 수 있도록 2004년 Vercel이 출시한 v0를 바이브 코딩을 넘어 실제 제품에 쓸 수 있도록 개선되었다. GitHub을 연동해서 기존 코드에서 작업할 수 있고 v0 내에서 엔지니어가 아니어도 PR을 제출할 수 있고 데이터를 연동해서 사용할 수 있게 되었다.(영어)</li>\n<li><strong><a href=\"https://hacks.mozilla.org/2026/02/launching-interop-2026/\">Launching Interop 2026</a></strong> : 브라우저 벤더와 플랫폼 업체가 협력해서 웹 표준의 상호운용성을 개선하는 Interop이 작년에는 25점으로 시작해서 95점까지 개선하고 Interop 2026을 시작했다. Interop 2026에서는 Cross-document View Transitions, Scroll-driven animations, WebTransport, CSS container style queries 등 새로운 기능과 기존 기능의 신뢰성 등 20개의 집중 영역과 접근성, 모바일 테스트, JPEG XL, WebVTT 등 4개의 조사 영역이 포함되었다.(영어)</li>\n<li><strong><a href=\"https://webpack.js.org/blog/2026-04-02-roadmap-2026/\">webpack Roadmap 2026</a></strong> : webpack의 2026년 로드맵이 나왔다. 올해 계획하는 주요 계획에는 플러그인 없이 CSS 모듈을 지원하고 universal이라는 타겟을 통해 여러 런타임 간 호환성을 유지하도록 지원하고 로더 없이도 TypeScript를 빌드하고 플러그인 없이 HTML 파일을 가져오고 엔트리포인트로 활용할 수 있게 할 계획이다.(영어)</li>\n<li><strong><a href=\"https://vercel.com/blog/introducing-geist-pixel\">Introducing Geist Pixel</a></strong> : Vercel에서 기존에 공개했던 Geist Sans와 Geist Mono에 기반해서 비트맵에 영감받은 Geist Pixel 폰트를 공개했다.<br />\n<br></li>\n</ul>\n\n<h1>그 밖의 개발 관련</h1>\n\n<ul>\n<li><strong><a href=\"https://resources.anthropic.com/hubfs/2026%20Agentic%20Coding%20Trends%20Report.pdf\">2026 Agentic Coding Trends Report</a></strong> : Anthropic에서 에이전틱 코딩 트렌드 보고서를 발표했다. 2005년 코딩 에이전트는 실험적 도구에서 프로덕션 시스템으로 이동했는데 이러한 성과가 더 확장될 것이라고 예측한다.(영어)<br />\n<br />\n<ul>\n<li>트랜드 1: 소프트웨어 개발 생명 주기가 극적으로 변화한다. 코딩이나 디버깅 등은 AI로 이동하고 엔지니어는 에이전트를 오케스트레이션하고 산출물을 평가하고 올바르게 해결하도록 보장하는 쪽으로 역할이 이동된다. 엔지니어는 점점 풀스택이 되고 있고 온보딩도 수주에서 수 시간으로 붕괴하기 시작해서 인력 배치와 프로젝트 자원 할당에 큰 변화가 올 것이다.</li>\n<li>트랜드 2: 단일 에이전트는 조정된 팀으로 진화한다. 멀티 에이전트 시스템이 단일 에이전트 워크플로우를 대체할 것이다.</li>\n<li>트랜드 3: 장기 실행 에이전트가 완전한 시스템을 구축한다. 에이전트의 작업 범위가 수준에서 며칠 또는 수주로 확장되어 복잡한 문제를 해결하면서 이전에는 실행 불가능했던 문제를 해결하고 시장 진입 경로도 가속화된다.</li>\n<li>트랜드 4: 인간의 감독은 지능적 협업을 통해 확장된다. 에이전트를 통한 품질 관리가 표준이 되고 에이전트가 언제 인간의 판단이 필요한지를 배우게 되어 인간의 감독이 모든 것을 검토하는 대신 중요한 것을 검토하는 쪽으로 이동할 것이다.</li>\n<li>트랜드 5: 에이전틱 코딩이 새로운 표면과 사용자로 확장된다. 언어 장벽이 사라져서 레거시 언어에 대한 유지 보수도 사라지고 특수한 사용 사례에 대한 도입 장벽도 제거될 것이며 코딩이 엔지니어를 넘어 비전통적인 개발자도 에이전틱 코딩을 사용하게 된다.</li>\n<li>트랜드 6: 생산성 향상이 소프트웨어 개발의 경제성을 재편한다. 에이전트 역량, 오케스트레이션 개선, 인간의 경험이 합쳐져서 계단식 개선을 만들어내고 프로젝트 일정이 짧아져서 시장에 더 빠르게 대응할 수 있게 된다.</li>\n<li>트랜드 7:  비기술적 사용 사례가 조직 전반에 확장된다. 모든 분야가 코딩 역량을 얻게 되어 도메인 전문가가 직접 솔루션을 구현하게 된다.</li>\n<li>트랜드 8: 에이전틱 코딩은 보안 방어를 강화하지만, 공격적인 사용도 증가시킨다. 보안 지식이 민주화되어 누구나 보안 엔지니어가 될 수 있지만 공격자도 공격 방법을 확장할 수 있게 된다. 자동화된 에이전틱 시스템이 보안 대응을 하게 된다.</li>\n</ul></li>\n<li><strong><a href=\"https://openai.com/ko-KR/index/introducing-gpt-5-3-codex/\">GPT-5.3-Codex 소개</a></strong> : OpenAI에서 Codex의 새로운 모델 GPT-5.3-Codex를 공개했다. GPT-5.3-Codex는 최첨단 코딩 성능과 GPT-5.2의 추론 능력과 전문 지식 역량을 하나의 모델로 결합하고 처리 속도도 25% 빨라졌다. 주요 벤치마크에서 최고 수준의 성과를 기록했다.(한국어)</li>\n<li><strong><a href=\"https://openai.com/ko-KR/index/introducing-gpt-5-3-codex-spark/\">GPT‑5.3‑Codex‑Spark를 소개합니다</a></strong> : OpenAI가 Cerebras와의 파트너쉽을 통해 GPT‑5.3‑Codex의 경량 버전이면서 실시간 코딩을 위해 초고속으로 설계된 GPT‑5.3‑Codex-Spark의 리서치 프리뷰를 공개했다. 최신 프런티어 모델은 장시간 작업에 강점을 보였지만 Codex-Spark는 거의 즉각적으로 응답하도록 만들어졌고 128k 컨텍스트 윈도우를 지원하는 텍스트 전용 모델로 출시되었다.(한국어)</li>\n<li><strong><a href=\"https://code.claude.com/docs/en/agent-teams\">Orchestrate teams of Claude Code sessions</a></strong> : 여러 Claude Code 인스턴스를 팀으로 협력할 수 있게 하는 Agent temas 기능이 나왔다. 한 세션은 팀 리더 역할로 업무를 조정하고 업무를 할당하여 결과를 종합하고 팀원들을 독립적으로 작업하고 각자의 컨텍스트 창에서 서로 소통하게 된다. 서브 에이전트와 다른 점을 서브 에이전트는 메인 에이전트에게만 보고할 수 있지만 Agent team에서는 상호작용할 수 있다. 더 자세한 내용을 알고 싶으면 Addy Osmani가 쓴 <a href=\"https://addyosmani.com/blog/claude-code-agent-teams/\">Claude Code Swarms</a>를 읽어보면 좋다.(영어)</li>\n<li><strong><a href=\"https://qwen.ai/blog?id=qwen3-coder-next\">Qwen3-Coder-Next: Pushing Small Hybrid Models on Agentic Coding</a></strong> : Alibaba에서 코딩 에이전트와 로컬 개발을 위해 특별히 설계된 Qwen3-Coder-Next 모델을 공개했다. Qwen3-Next-80B-A3B-Base 위에 구축된 Qwen3-Coder-Next는 강력한 코딩 역량을 보여주면서도 낮은 추론 비용을 달성했다.(영어)</li>\n<li><strong><a href=\"https://blog.gitbutler.com/but-cli\">Introducing the GitButler CLI</a></strong> : GitButler에서 Git을 더 풍부하게 사용할 수 있는 <code>but</code> CLI를 발표했다. 훨씬 많은 정보를 보여주는 <code>status</code>나 병렬 브랜치 작업을 쉽게 할 수 있는 기능, Stacked 브랜치를 쉽게 관리할 수 있는 기능, undo 기능 등 다양한 기능을 제공한다.(영어)</li>\n<li><strong><a href=\"https://www.apple.com/newsroom/2026/02/xcode-26-point-3-unlocks-the-power-of-agentic-coding/\">Xcode 26.3 unlocks the power of agentic coding</a></strong> : Xcode 26.3부터 에이전트 코딩 지원을 도입해서 <a href=\"https://www.anthropic.com/news/apple-xcode-claude-agent-sdk\">Claude Agent</a>와 Codex 같은 에이전트를 사용해서 Xcode에서 개발할 수 있게 되었다.(영어)</li>\n<li><strong><a href=\"https://cline.bot/blog/introducing-cline-cli-2-0\">Introducing Cline CLI 2.0: from sidebar to the terminal</a></strong> : Cline에서 이젠 IDE보다 오케스트레이션을 위한 인터페이스가 필요하다고 얘기하며 Cline CLI 2.0을 발표했다. VS Code의 인터페이스를 벗어나서 터미널에 맞는 인터페이스를 제공하고 <code>-y</code> 플래그를 통해 인터렉티브 TUI 없이 자율성을 부여할 수 있어서 자동화해서 사용할 수 있다.(영어)</li>\n<li><strong><a href=\"https://code.claude.com/docs/en/fast-mode\">Speed up responses with fast mode</a></strong> : Claude Code에 Fast mode가 <a href=\"https://claude.com/fast-mode\">리서치 프리뷰로 공개</a>되었다. Fast Mode는 Claude Opus 4.6을 2.5배 더 빠르게 제공하는 대신 토큰당 비용을 더 비싸게 받는다.(영어)</li>\n<li><strong><a href=\"https://entire.io/blog/hello-entire-world\">Hello Entire World</a></strong> : 전 GitHub CEO였던 Thomas Dohmake가 퇴사하고 6천만 달러의 시드 라운드 투자를 받아 Entire라는 회사를 만들었다.(기업 가치는 3억 달러) 그동안 개발자 도구와 시스템은 사람을 위해서 만들어졌기에 에이전트와 인간이 협력할 수 있는 개발자 플랫폼을 만드는 것을 목표로 코드, 의도, 제약 조건, 추론을 하나의 버전 제어 시스템으로 통합하는 Git 호환 데이터베이스, 다중 에이전트 간 조정을 가능하게 하는 의미 추론 계층, 에이전트와 인간의 협업을 위한 소프트웨어 개발 생명주기를 재창조하는 AI 네이티브 소프트웨어 개발 생명주기를 핵심 요소로 삼고 있다. 첫 번째 제품으로 에이전트가 코드를 생성해서 커밋하면 커밋과 함께 전체 세션을 캡쳐해서 추적할 수 있게 하는 Checkpoint를 공개했다.(영어)</li>\n<li><strong><a href=\"https://replay.software/updates/introducing-echo\">Introducing Echo</a></strong> : Replay에서 iOS와 iPadOS용 SSH 클라이언트를 만들었다. Echo는 Ghostty를 터미널 엔진으로 사용하고 있고 코딩 에이전트를 더 잘 사용하기 위해서 SSH 클라이언트가 새로 필요하다고 느껴서 만들었다고 한다. 유료 앱으로 가격은 2.99 달러이다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>인프라 관련</h1>\n\n<ul>\n<li><strong><a href=\"https://grafana.com/blog/how-prometheus-remote-write-v2-can-help-cut-network-egress-costs-by-as-much-as-50-/\">How Prometheus Remote Write v2 can help cut network egress costs by as much as 50%</a></strong> : 2024년에 제안된 Prometheus Remote Write v2가 아직 실험 단계임에도 상당한 비용 절감을 보여주고 있다. Grafana Labs 내부에서 v1을 v2로 변경했을 때 CPU와 메모리가 5%에서 10%로 약간 증가했지만, 텔레메트리 네트워크 이그레스 비용은 50% 이상 줄었다.(영어)</li>\n<li><strong><a href=\"https://www.wiz.io/blog/exposed-moltbook-database-reveals-millions-of-api-keys\">Hacking Moltbook: The AI Social Network Any Human Can Control</a></strong> : 클라우드 보안 업체인 Wiz에서 OpenClaw의 소셜 네트워크인 Moltbook이 인기를 끌자 보안 검사를 시도했다. 비침해적인 단순 탐색을 한 결과 Supabase의 데이터베이스의 읽기/쓰기 권한이 모두 허용되어 있었다. Wiz에 따르면 150만 명의 에이전트가 등록되었다고 알려졌지만, 데이터베이스에는 17,000명의 사람이 확인되었고, 비율은 88:1이었는데 POST 요청으로 누구나 게시할 수 있었기에 실제로는 인간이 많은 에이전트를 사용해서 콘텐츠를 게시한 것이었다. 바이브 코딩에서 흔하게 발견되는 JavaScript 번들에 자격 증명이 포함되는 패턴을 분석한 결과 Supabase API 키를 발견할 수 있었고 백엔드에서 이에 대한 보안 조치가 없었기에 이 키를 사용해서 데이터베이스에 접근해서 150만 개의 API 인증 토큰, 35,000개의 이메일 주소, 에이전트 간의 메시지에 접근할 수 있었다.(영어)</li>\n<li><strong><a href=\"https://blog.cloudflare.com/markdown-for-agents/\">Introducing Markdown for Agents</a></strong> : 에이전트에서 Markdown이 공용어로 자리 잡았고, HTML에 비해 Markdown은 토큰도 훨씬 절약할 수 있기 때문에 HTML 문서를 Markdown으로 변환하는 게 일반적인 작업이다. Cloudflare는 <code>Accept</code> 헤더로 <code>text/markdown</code>으로 요청할 경우 HTML을 Markdown으로 변환해서 제공하는 기능을 지원한다.(영어)</li>\n<li><strong><a href=\"https://www.uber.com/en-KR/blog/ubers-rate-limiting-system/\">Uber’s Rate Limiting System</a></strong> : 분산 시스템에서 서비스의 신뢰성과 공정성을 유지하기 위해 Rate Limit은 중요하다. Uber의 마이크로 서비스 초창기에는 트래픽 과부하로부터 서비스를 보호할 단일 방법이 없었기에 각 팀이 자체적으로 미들웨어나 Redis를 사용해서 구현했지만 동작도 일관적이지 않고 운영도 쉽지 않았다. 이를 해결하기 위해 중앙에서 제어할 방법이 필요했지만, Redis를 이용한 중앙 카운터를 구현하기에는 규모가 너무 컸기에 각 로컬 프록시를 사용한 완전 분산 아키텍처를 사용하는 것이 유일한 방법이라는 결론을 내리고 Uber의 Service Mesh에 Rate Limit을 통합했다. 서비스 메시의 Rate Limit 클라이언트는 토큰 버킷 알고리즘을 사용해서 요청을 차단하며 호스트별 요청 수를 Zone의 집계기에 보고하고 집계기는 사용량을 계산한 후 컨트롤러에 전송하면 글로벌과 리전별로 있는 컨트롤러가 데이터를 집계해서 업체와 고객에게 전달한다. 여러 번의 개선을 통해 현재는 지연속도와 오버헤드가 크게 개선되었고 운영 부담도 적어졌다.(영어)</li>\n<li><strong><a href=\"https://www.uber.com/en-KR/blog/introducing-ufowarder/\">Introducing uFowarder: The Consumer Proxy for Kafka Async Queuing</a></strong> : 하루에 수조 개의 메시지를 처리하는 Kafka를 운영하는 Uber에서 파티션 확장성이나 다중 프로그래밍 언어 지원 등의 문제를 해결하기 위해 수년 전 Consumer Proxy을 만들어서 익숙한 gRPC 인터페이스를 사용할 수 있게 했다. 하지만 규모가 점점 커지면서 Head-of-line 문제는 계속 있었고 Producer와 Consumer 간의 격리도 필요하게 되었다. 그래서 <a href=\"https://github.com/uber/uForwarder\">uForwarder</a>를 만들어서 오픈소스로 공개했는데 컨텍스트를 인식해서 라우팅함으로써 존 격리 등을 할 수 있게 되었고 poison-pill 메시지로 인해 Consumer가 문제를 해결하기 위해 Head-of-line 차단을 자동으로 감지해서 완화 조치를 수행하고 Consumer는 stateless로 만들어서 자유롭게 확장할 수 있게 했다.(영어)</li>\n<li><strong><a href=\"https://deno.com/blog/introducing-deno-sandbox\">Introducing Deno Sandbox</a></strong> : Deno에서 Deno Deply Cloud에서 실행되는 경량 리눅스 마이크로 VM을 실행해서 신뢰할 수 없는 코드를 실행할 수 있는 Deno Sendbox를 출시했다.(영어)</li>\n<li><strong><a href=\"https://github.com/minio/minio/commit/7aac2a2c5b7c882e68c1ce017d8256be2feea27f\">Minio is no longer maintained</a></strong> : Minio가 저장소가 더 이상 유지 보수되지 않는다고 명시하고 상용버전인 AIStor를 사용하라고 안내로 바뀌었다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>AI 관련</h1>\n\n<ul>\n<li><strong><a href=\"https://www.anthropic.com/news/claude-opus-4-6\">Introducing Claude Opus 4.6</a></strong> : Claude Sonnet 5가 출시될 예정이라는 소문이 무성한 가운데 Anthropic이 가장 좋은 평가를 받는 Claude Opus의 4.6을 내놓았다. 이전보다 코딩 능력이 향상되었고, Opus에서는 처음으로 베타에서 100만 토큰 콘텍스트 윈도우를 제공한다.(영어)</li>\n<li><strong><a href=\"https://openai.com/ko-KR/index/introducing-the-codex-app/\">Codex 앱을 소개합니다</a></strong> : OpenAI에서 여러 에이전트를 동시에 관리하고 작업을 병렬로 실행할 수 있는 macOS용 Codex 앱을 발표했다.(한국어)</li>\n<li><strong><a href=\"https://openai.com/ko-KR/index/introducing-openai-frontier/\">OpenAI Frontier를 소개합니다</a></strong> : OpenAI에서 업무용 AI 에이전트 구축과 배포, 관리를 지원하는 플랫폼인 Frontier를 출시했다. Frontier는 기업이 이미 사용 중인 시스템과 함께 동작해서 회사의 비즈니스 콘텍스트 상에서 에이전트가 업무를 지원할 수 있다.(한국어)</li>\n<li><strong><a href=\"https://www.minimax.io/news/minimax-m25\">MiniMax M2.5: Built for Real-World Productivity</a></strong> : MiniMax에서 새로운 모델인 M2.5를 발표했다. M2.5는 코딩, 에이전트 도구 사용, 검색, 업무 등에서 SOTA 수준이며 다양한 벤치마크에서 높은 점수를 기록했고 1시간 동안 초당 100 토큰을 계속해서 사용한다고 했을 때 1달러만 들 정도로 저렴한 가격으로 제공한다.(영어)</li>\n<li><strong><a href=\"https://z.ai/blog/glm-5\">GLM-5: From Vibe Coding to Agentic Engineering</a></strong> : Z.ai에서 새로운 모델 GLM-5를 발표했다. 이전 GLM-4.5보다 큰 744B 매개변수까지 확장했고 사전 학습 데이터의 토큰 수도 28.5T로 증가했다. 이번 모델에서는 세밀한 학습 후 반복할 수 있는 비동기 강화 학습 인프라인 Slime을 개발해서 모델의 벤치마크 점수도 우수하게 나타났다.(영어)</li>\n<li><strong><a href=\"https://seed.bytedance.com/en/seedance2_0\">Seedance 2.0</a></strong> : ByteDance에서 멀티모달 오디오-비디오를 생성할 수 있는 Seedance 2.0을 발표했다. Seedance의 높은 품질의 영상으로 주목받고 있다.(영어)</li>\n<li><strong><a href=\"https://qwen.ai/blog?id=qwen-image-2.0\">Qwen-Image-2.0: Professional infographics, exquisite photorealism</a></strong> : Alibaba에서 새로운 이미지 생성 모델 Qwen-Image-2.0를 출시했다. Qwen-Image-2.0는 인포그래픽을 생성할 수 있게 1k 토큰 인스트럭션을 지원하고 2k 해상도와 함께 텍스트 렌더링도 강화되었다.(영어)</li>\n<li><strong><a href=\"https://waymo.com/blog/2026/02/the-waymo-world-model-a-new-frontier-for-autonomous-driving-simulation\">The Waymo World Model: A New Frontier For Autonomous Driving Simulation</a></strong> : 자율주행 택시인 Waymo에서 Google DeepMind Genie 3를 사용해서 월드 모델을 만들어서 자율주행의 시뮬레이션을 구성했다. 기존 시뮬레이션을 수집한 도로 데이터를 바탕으로 학습하지만, Waymo 월드 모델을 사용하면 날씨, 상황, 언어 등 다양한 상황을 만들어서 시뮬레이션할 수 있게 되었다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>볼만한 링크</h1>\n\n<ul>\n<li><strong><a href=\"https://addyosmani.com/blog/agentic-engineering/\">Agentic Engineering</a></strong> : Andrej Karpathy가 1년 전 만든 바이브 코딩이라는 용어가 크게 유행했지만 실제 제품에서는 한계를 보인다. 숙련된 엔지니어들은 AI를 끊임없이 감독하면서 생산성을 얻고 코드 품질을 유지하고 있는데 이는 바이브 코딩과는 전혀 다르기에 다른 용어가 필요하다. Simon Willison인 vibe engineering을 제안했고, Andrej Karpathy가 이번엔 Agentic Engineering을 제안했다. 이는 AI 에이전트를 조율하고 아키텍트, 리뷰어, 의사결정자 역할을 하는 엔지니어링이고 더 전문적으로 보이고 경계도 명확하게 보여주기 때문이라고 한다.(영어)</li>\n<li><strong><a href=\"https://mitchellh.com/writing/my-ai-adoption-journey\">My AI Adoption Journey</a></strong> : HashiCorp의 공동 창업자였던 Mitchell Hashimoto가 AI를 도입한 과정을 설명한 글이다. 본인은 의미 있는 도구를 도입할 때는 항상 비효율의 시기와 적절성의 시기를 거쳐서 워크플로우와 인생을 바꾸는 발견의 시기를 거치게 되는데 이러한 기조로 AI를 코딩에 어떻게 도입하게 되었는지는 단계별로 설명한다.(영어)<br />\n<br />\n<ul>\n<li>1단계는 ChatGPT같은 챗봇을 통해 의미 있는 작업을 중단해야 하는데 이는 가치를 찾기 위해서는 에이전트를 사용해야 하기 때문이다.</li>\n<li>2단계는 자신의 작품을 재현하는 것인데 처음에는 감명받지 못했지만, 수동 커밋한 작업을 에이전트가 똑같은 결과를 내도록 강요했다. 힘든 과정이었지만 이를 통해 세션을 실행할 수 있는 개별 과제로 나누고 검증할 방법을 제공해야 한다는 원리를 파악했고 이 과정이 큰 효율성으로 이어졌고 언제 에이전트를 사용하지 말아야 하는지도 알게 되었다.</li>\n<li>3단계는 본인이 일할 수 없는 시간에도 진전을 이룰 수 있을 거라는 생각에 매일 마지막 30분을 차단하고 한 명 이상의 에이전트를 시작했다. 이 과정도 힘들었지만, 심층 조사라거나 새로운 아이디어를 생각하는 등 새로운 방향이 보이기 시작했다.</li>\n<li>4단계부터는 AI가 어떤 작업을 잘하고 못하는지 자신감이 생겼고 모든 일을 맡기고 다른 일을 처리하는 단계로 넘어갔다.</li>\n<li>5단계는 하네스 설계 단계로 에이전트는 처음부터 올바른 결과를 내거나 최악의 상황에도 최소한의 수정만으로 결과를 낼 때 효율적이라서 이를 달성하기 위해 에이전트에게 잘못되었음을 자동으로 알려주는 것이 제일 좋다. 이를 하네스 엔지니어링이라고 부르고 있는데 간단한 문제는 <code>AGENTS.md</code>에 업데이트하고 그 외에는 프로그래밍이 된 도구를 사용한다.</li>\n<li>6단계는 항상 에이전트가 실행되는 것을 목표로 하고 있다. 아직 여러 에이전트를 동시에 돌리지 않고 그럴 생각도 없지만 항상 에이전트를 돌리는 것을 목표로 하고 있다.</li>\n</ul></li>\n<li><strong><a href=\"https://techcrunch.com/2026/02/12/spotify-says-its-best-developers-havent-written-a-line-of-code-since-december-thanks-to-ai/\">Spotify says its best developers haven’t written a line of code since December, thanks to AI</a></strong> : Spotify의 공동 CEO인 Gustav Söderström가 Shopify의 최고 개발자들이 12월 이후로 단 한 줄의 코드도 작성하지 않았다고 얘기했다. Spotify는 Honk라는 내부 시스템을 만들어서 Claude Code 등을 활용한 원격 코딩을 가능하게 만들었는데 이를 통해서 핸드폰으로도 버그를 수정하거나 기능을 추가할 수 있게 되어서 코딩과 배포가 엄청나게 가속화되었다고 한다.(영어)</li>\n<li><strong><a href=\"https://www.labs.greynoise.io/grimoire/2026-02-10-telnet-falls-silent/\">2026-01-14: The Day the telnet Died</a></strong> : 1월 14일 전 세계의 Telnet 트래픽이 급격히 83%까지 감소했고 이후 2월 10일까지도 기준치보다 59%가 감소한 상태를 유지하고 있다. 그리고 6일 뒤인 1월 20일 CVE-2026-24061인 GNU Inetutils telnetd에서 중요한 인증 우회 취약점이 발견되었다. 이 때문에 백본이나 트랜짓 제공업체가 CVE가 공개되기 전에 먼저 23 포트 필터링을 도입했고 이후 CVE가 공개된 것이 아닌지를 추측하고 있다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>IT 업계 뉴스</h1>\n\n<ul>\n<li><strong><a href=\"https://steipete.me/posts/2026/openclaw\">OpenClaw, OpenAI and the future</a></strong> : OpenClaw를 만든 Peter Steinberger가 OpenAI에 합류했다.(영어)</li>\n<li><strong><a href=\"https://www.brendangregg.com/blog/2026-02-07/why-i-joined-openai.html\">Why I joined OpenAI</a></strong> : 성능 엔지니어링의 대가라고 할 수 있는 Brendan Gregg가 <a href=\"https://www.brendangregg.com/blog/2025-12-05/leaving-intel.html\">Intel</a>을 퇴사하고 OpenAI를 선택했다. 많은 AI 회사를 만났고 흥미로운 공학 문제가 많이 보였지만 OpenAI에 이미 알고 있는 재능 있는 엔지니어가 가장 많아서 선택했다고 한다.(영어)</li>\n<li><strong><a href=\"https://www.anthropic.com/news/anthropic-raises-30-billion-series-g-funding-380-billion-post-money-valuation\">Anthropic raises $30 billion in Series G funding at $380 billion post-money valuation</a></strong> : Anthropic이 GIC와 Coatue가 주도한 시리즈 G 투자 라운드에서 300억 달러를 모금하고 기업가치를 3,800억 달러(약 540조 원)의 기업 가치를 평가받았다. 현재 연간 환산 매출(run-rate revenue)은 140억 달러이고 Claude Code의 연간 환산 매출은 25억 달러 이상으로 성장했고 여전히 사용자가 크게 성장하고 있다.(영어)</li>\n<li><strong><a href=\"https://www.spacex.com/updates#xai-joins-spacex\">xAI joins SpaceX to Accelerate Humanity’s Future</a></strong> : Elon Musk의 AI 회사인 xAI가 항공우주 회사인 SpaceX에 인수되었다.(영어)</li>\n<li><strong><a href=\"https://techcrunch.com/2026/02/09/chatgpt-rolls-out-ads/\">ChatGPT rolls out ads</a></strong> : OpenAI가 월 8달러의 저렴한 구독 플랜인 <a href=\"https://help.openai.com/en/articles/11989085-what-is-chatgpt-go\">Go 플랜</a>에서 광고 테스트를 시작한다고 발표했다. 이 광고는 Plus, Pro, Business, Enterprise, Education 플랜에는 적용되지 않으며 광고가 답변에도 영향을 주지 않는다고 밝혔다.(영어)</li>\n<li><strong><a href=\"https://n.news.naver.com/mnews/article/366/0001141501\">디시인사이드, 사모펀드에 2000억에 팔려... 반년 만에 본계약 체결</a></strong> : 사모펀드 운용사 에이치프라이빗에쿼티가 디시인사이드 인수의 본계약을 체결했고, 매각가는 2,000억 원 수준으로 알려졌다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>프로젝트</h1>\n\n<ul>\n<li><strong><a href=\"https://meshery.io/\">Meshery</a></strong> : Kubernetes 클러스터 관리 플랫폼으로 CNCF 프로젝트</li>\n<li><strong><a href=\"https://github.com/Koomook/data-go-mcp-servers\">Korea Data.go.kr MCP Servers</a></strong> : 한국 공공 데이터 포털의 API를 MCP 서버로 제공하는 프로젝트.</li>\n<li><strong><a href=\"https://docs.dartrelic.dev/\">Relic</a></strong> : Dart 웹 프레임워크.<br />\n<br></li>\n</ul>\n\n<h1>버전 업데이트</h1>\n\n<ul>\n<li><strong><a href=\"https://pandas.pydata.org/\">pandas</a> 3.0.0</strong> : Python 데이터 분석 라이브러리, <a href=\"https://pandas.pydata.org/community/blog/pandas-3.0.html\">릴리스 공지</a></li>\n<li><strong><a href=\"http://eslint.org/\">ESLint</a> v10.0.0</strong> : JavaScript 코드 분석 도구, <a href=\"https://eslint.org/blog/2026/02/eslint-v10.0.0-released/\">릴리스 공지</a></li>\n<li><strong><a href=\"https://router.vuejs.org/\">Vue Router</a> v5.0.0</strong> : Vue.js의 라우팅 라이브러리, <a href=\"https://github.com/vuejs/router/releases/tag/v5.0.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://www.android.com/\">Android</a> v17 Beta</strong> : 모바일 운영체제, <a href=\"https://android-developers.googleblog.com/2026/02/the-first-beta-of-android-17.html\">릴리스 공지</a></li>\n<li><strong><a href=\"https://argoproj.github.io/argo-cd/\">Argo CD</a> v3.1.0</strong> : Kubernetes 배포 도구, <a href=\"https://github.com/argoproj/argo-cd/releases/tag/v3.3.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://keda.sh/\">KEDA</a> v2.19.0</strong> : Kubernetes 오토스케일러, <a href=\"https://github.com/kedacore/keda/releases/tag/v2.19.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://gitbutler.com/\">GitButler</a> v0.19</strong> : Git 클라이언트, <a href=\"https://blog.gitbutler.com/gitbutler-0-19\">릴리스 공지</a></li>\n<li><strong><a href=\"http://nodejs.org/\">Node.js</a> v25.6.0 (Current)</strong> : 자바스크립트 런타임, <a href=\"https://nodejs.org/en/blog/release/v25.6.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://reacttraining.com/react-router/\">React Router</a> v7.13.0</strong> : React의 라우팅 라이브러리, <a href=\"https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#v7130\">릴리스 공지</a></li>\n<li><strong><a href=\"https://d7y.io/\">Dragonfly</a> v2.4.0</strong> : P2P 기반 파일 배포 및 이미지 가속 시스템, <a href=\"https://www.cncf.io/blog/2026/02/05/dragonfly-v2-4-0-is-released/\">릴리스 공지</a></li>\n<li><strong><a href=\"https://www.elastic.co/kr/products\">Elastic</a> v9.3.0</strong> : 엘라스틱 스택, <a href=\"https://www.elastic.co/blog/whats-new-elastic-9-3-0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://podman.io/\">podman</a> v5.8.0</strong> : 컨테이너 엔진, <a href=\"https://github.com/containers/podman/releases/tag/v5.8.0\">변경사항</a></li>\n<li><strong><a href=\"https://openvpn.net/\">OpenVPN</a> v2.7.0</strong> : VPN, <a href=\"https://github.com/OpenVPN/openvpn/releases/tag/v2.7.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://reactnative.dev/\">React Native</a> v0.84.0</strong> : React를 이용한 모바일 앱 개발 프레임워크, <a href=\"https://reactnative.dev/blog/2026/02/11/react-native-0.84\">릴리스 공지</a><br />\n<br />\n<ul>\n<li>Hermes V1이 기본 JavaScript 엔진이 됨.</li>\n<li>사전에 컨파일된 바이너리가 iOS에서 기본이 됨.</li>\n</ul></li>\n<li><strong><a href=\"https://www.dartlang.org/\">Dart</a> v3.11.0</strong> : 프로그래밍 언어, <a href=\"https://blog.dart.dev/announcing-dart-3-11-b6529be4203a\">릴리스 공지</a></li>\n<li><strong><a href=\"https://flutter.io/\">Flutter</a> v3.41</strong> : iOS, Android 네이티브 앱을 만드는 프레임워크, <a href=\"https://blog.flutter.dev/whats-new-in-flutter-3-41-302ec140e632\">릴리스 공지</a></li>\n<li><strong><a href=\"https://redis.io/\">Redis</a> 8.6</strong> : 키/밸류 스토어, <a href=\"https://redis.io/blog/announcing-redis-86-performance-improvements-streams/\">릴리스 공지</a></li>\n<li><strong><a href=\"https://ui.nuxt.com/\">Nuxt UI</a> v4.4.0</strong> : UI 라이브러리, <a href=\"https://github.com/nuxt/ui/releases/tag/v4.4.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://go.dev/\">Go</a> v1.26</strong> : 프로그래밍 언어, <a href=\"https://go.dev/doc/go1.26\">릴리스 공지</a></li>\n<li><strong><a href=\"https://clickhouse.com/\">ClickHouse</a> v26.1</strong> : 컬럼형 데이터베이스, <a href=\"https://clickhouse.com/blog/clickhouse-release-26-01\">릴리스 공지</a></li>\n<li><strong><a href=\"https://opensearch.org/\">OpenSearch</a> 3.5</strong> : 분산형 검색 엔진, <a href=\"https://opensearch.org/blog/opensearch-3-5-is-live/\">릴리스 공지</a></li>\n<li><strong><a href=\"http://www.vim.org/\">Vim</a> v9.2</strong> : 텍스트 에디터, <a href=\"https://www.vim.org/vim-9.2-released.php\">릴리스 공지</a></li>\n</ul>\n<p><strong><a href=\"https://blog.outsider.ne.kr/1786?commentInput=true#entry1786WriteComment\">댓글 쓰기</a></strong></p>",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://blog.outsider.ne.kr/1786"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[책] 데이터 엔지니어링 디자인 패턴",
    "partialText": "<h3 style=\"background-color: #ffffff; color: #666666; text-align: center;\" data-ke-size=\"size23\">한빛미디어 서평단 &lt;나는리뷰어다&gt; 활동을 위해서 책을 협찬받아 작성된 서평입니다</h3>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style2\" />\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-origin-width=\"960\" data-origin-height=\"655\"><span data-url=\"https://blog.kakaocdn.net/dn/bDEhS7/dJMcagxHbKY/UgmUIieIDfsMfy1Ahceoa0/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/bDEhS7/dJMcagxHbKY/UgmUIieIDfsMfy1Ahceoa0/img.png\" data-alt=\"데이터 엔지니어링 디자인 패턴\"><img src=\"https://blog.kakaocdn.net/dn/bDEhS7/dJMcagxHbKY/UgmUIieIDfsMfy1Ahceoa0/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbDEhS7%2FdJMcagxHbKY%2FUgmUIieIDfsMfy1Ahceoa0%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"960\" height=\"655\" data-origin-width=\"960\" data-origin-height=\"655\"/></span><figcaption>데이터 엔지니어링 디자인 패턴</figcaption>\n</figure>\n</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">데이터 엔지니어링 공부를 하다 보면 기술 스택은 화려한데 정작 '어떻게 설계해야 하나'라는 근본적인 고민에 빠질 때가 많죠. 이번에 읽은 <a href=\"https://www.hanbit.co.kr/store/books/look.php?p_code=B9262361709\" target=\"_blank\" rel=\"noopener\">데이터 엔지니어링 디자인 패턴</a>은 그런 막막함을 해소해 주기에 충분한 책이었습니다. 단순히 특정 툴의 사용법을 나열하는 게 아니라, 복잡한 파이프라인 속에서 마주하는 기술적 난제들을 '디자인 패턴'이라는 명확한 언어로 풀어냈다는 점이 정말 매력적이더라고요.</p>\n<p data-ke-size=\"size16\">가장 놀라웠던 건 이 책이 다루는 범위와 디테일입니다. 데이터 수집부터 보안, 가치 창출, 그리고 최근 화두인 관찰 가능성(Observability)까지 데이터의 생애 주기 전반을 아주 촘촘하게 파고듭니다. 특히 무려 70가지나 되는 디자인 패턴을 하나하나 정립해 둔 것을 보고 저자의 내공이 대단하다는 생각이 들었습니다. 실무에서 겪을 법한 구체적인 문제 상황들을 이 정도 숫자의 패턴으로 세분화해 놓으니, 마치 든든한 해결사 꾸러미를 얻은 기분이더군요. 약 2년 정도 데이터 엔지니어링 업무만 온전히 한 적이 있는데요. 제가 현업에서 구현해 놓은 파이프라인에 패턴 이름이 있다는 사실을 보고 묘한 희열을 느끼기도 했습니다 &mdash; 감사-쓰기-감사-배포(AWAP) 패턴</p>\n<p data-ke-size=\"size16\">내용 면에서도 굉장히 실용적입니다. 초반부 데이터 수집과 적재 전략을 지나, 제가 개인적으로 가장 중요하다고 생각하는 오류 관리와 멱등성 파트로 넘어가는 흐름이 아주 깔끔했습니다. 장애가 발생해도 시스템이 똑같은 결과를 보장하게 만드는 멱등성 설계는 실무자라면 누구나 머리를 싸매는 지점인데, 이를 패턴화 해서 설명해 주니 머릿속이 한결 맑아지는 느낌을 받았습니다.</p>\n<p data-ke-size=\"size16\">책 후반부에서 다루는 데이터 보안이나 스토리지 최적화, 그리고 시스템의 건강 상태를 체크하는 관찰 가능성 패턴들도 빼놓을 수 없습니다. 단순히 '데이터를 옮기는 일'에 그치지 않고, 어떻게 하면 더 안전하고 효율적으로, 그리고 투명하게 데이터를 관리할 수 있을지에 대한 깊은 통찰이 담겨 있습니다. 70개의 패턴을 하나씩 따라가다 보면, 어느새 데이터 아키텍처를 바라보는 시야가 훨씬 넓어져 있는 자신을 발견하게 됩니다.</p>\n<p data-ke-size=\"size16\">이 책을 보면서 가장 공감 됐던 문장은 사실... 패턴보다 아래 내용이었습니다. 아마도 소프트웨어 엔지니어라면 모두 다 마찬가지겠죠? 필 칼튼(1947-1997)은 소프트웨어 개발자이자 넷스케이프 제품의 아키텍처 책임자였다고 해요.&nbsp;</p>\n<blockquote data-ke-size=\"size16\" data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">엔지니어링&nbsp;업계에서&nbsp;인기&nbsp;있는&nbsp;속담&nbsp;하나는&nbsp;필&nbsp;칼튼이&nbsp;한&nbsp;말인데,&nbsp;'컴퓨터&nbsp;과학에서&nbsp;어려운&nbsp;것은&nbsp;두&nbsp;가지이다.&nbsp;캐시&nbsp;무효화와&nbsp;이름&nbsp;짓기'이다.</span></blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">현업에서 데이터 파이프라인을 설계하며 \"이게 최선일까?\"라는 의문이 들 때마다 이 책이 훌륭한 나침반이 되어줄 것 같습니다. 초보 엔지니어에게는 성장을 위한 탄탄한 기초 지도가, 시니어들에게는 자신의 설계를 점검하고 정교하게 다듬을 수 있는 좋은 레퍼런스가 될 거예요. 데이터 엔지니어로서 한 단계 더 도약하고 싶은 분들이라면 꼭 한번 곁에 두고 읽어보시길 추천합니다.</p>",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://jybaek.tistory.com/504752"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "How I Use Claude",
    "partialText": "<p>&ldquo;What separates people who use AI well from those who don&rsquo;t?&rdquo;</p>\n<p>It&rsquo;s a question I get from colleagues often. It&rsquo;s been three years since ChatGPT launched, and over a year since I started using Claude Code in earnest. In that time, the way I work has fundamentally changed. It&rsquo;s no longer just &ldquo;asking AI things&rdquo;—<strong>the way I think alongside AI</strong> has shifted.</p>\n<p>In this post, I want to share honestly how I use Claude: how I ask questions, the patterns I follow to solve problems, and what I&rsquo;ve discovered recently by combining it with Codex.</p>",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://novemberde.github.io/post/2026/02/17/How-I-Use-Claude-Engineer-AI-Workflow/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "나는 Claude를 이렇게 쓴다",
    "partialText": "<p>&ldquo;AI를 잘 쓰는 사람과 못 쓰는 사람의 차이는 뭘까?&rdquo;</p>\n<p>동료들에게 자주 받는 질문이다. ChatGPT가 나온 지 3년, Claude Code를 본격적으로 쓴 지 1년이 넘었다. 그 사이에 내 작업 방식은 근본적으로 바뀌었다. 단순히 &ldquo;AI에게 물어보는 것&quot;이 아니라, <strong>AI와 함께 생각하는 방식</strong> 자체가 달라졌다.</p>\n<p>이 글에서는 내가 Claude를 어떻게 활용하고 있는지—질문하는 방식, 문제를 해결하는 패턴, 그리고 최근 Codex와 병용하면서 발견한 것들을 솔직하게 공유하려 한다.</p>\n<h2 id=\"질문의-진화-이거-해줘에서-같이-생각하자로\">질문의 진화: &ldquo;이거 해줘&quot;에서 &ldquo;같이 생각하자&quot;로</h2>\n<p>처음 AI 도구를 쓸 때는 검색 엔진의 연장선이었다. &ldquo;Go에서 map을 순회하면서 삭제하려면?&rdquo; 같은 단답형 질문. Stack Overflow 대신 Claude에게 물어볼 뿐이었다.</p>",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://novemberde.github.io/post/2026/02/17/How-I-Use-Claude-Engineer-AI-Workflow-ko/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "AI 시대에는 어떤 글을 써야할까?",
    "partialText": "<p data-ke-size=\"size16\">최근에 BC 신용카드를 해지하려고 했다.<br />BC 카드는 페이북이 공식 앱이라 여기서 해지를 하려고 했다.<br />그런데 아무리 찾아봐도 카드 해지가 없었다.<br />분명 여러 블로그 글에는 페이북 앱에서 <code>해지</code> 검색 -&gt; <code>카드 해지</code> 를 하면 된다고 나오는데도 말이다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"1.jpg\" data-origin-width=\"1080\" data-origin-height=\"2400\"><span data-url=\"https://blog.kakaocdn.net/dn/dnqJPJ/dJMcagxFwh1/sX4JTKL8EWypHl1Ke8iDU0/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/dnqJPJ/dJMcagxFwh1/sX4JTKL8EWypHl1Ke8iDU0/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/dnqJPJ/dJMcagxFwh1/sX4JTKL8EWypHl1Ke8iDU0/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdnqJPJ%2FdJMcagxFwh1%2FsX4JTKL8EWypHl1Ke8iDU0%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"406\" height=\"902\" data-filename=\"1.jpg\" data-origin-width=\"1080\" data-origin-height=\"2400\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">주말이라 고객센터 연락이 안 될 것 같아 앱 내에서 지원하는 AI 챗봇에게 물어봤다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"2.jpg\" data-origin-width=\"1080\" data-origin-height=\"2400\"><span data-url=\"https://blog.kakaocdn.net/dn/RotIf/dJMb99L4MPZ/QIhyzxXoCFXOQCdC2enkA0/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/RotIf/dJMb99L4MPZ/QIhyzxXoCFXOQCdC2enkA0/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/RotIf/dJMb99L4MPZ/QIhyzxXoCFXOQCdC2enkA0/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRotIf%2FdJMb99L4MPZ%2FQIhyzxXoCFXOQCdC2enkA0%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"405\" height=\"900\" data-filename=\"2.jpg\" data-origin-width=\"1080\" data-origin-height=\"2400\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">구체적인 해지 방법은 안내해주지 못하고 카드 해지 주의 사항에 대해서만 계속 안내했다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"3.jpg\" data-origin-width=\"1080\" data-origin-height=\"2400\"><span data-url=\"https://blog.kakaocdn.net/dn/cm1uyw/dJMcac25Yhq/yIwJeCkhrKfd9HYfpJC2F1/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/cm1uyw/dJMcac25Yhq/yIwJeCkhrKfd9HYfpJC2F1/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/cm1uyw/dJMcac25Yhq/yIwJeCkhrKfd9HYfpJC2F1/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcm1uyw%2FdJMcac25Yhq%2FyIwJeCkhrKfd9HYfpJC2F1%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"382\" height=\"849\" data-filename=\"3.jpg\" data-origin-width=\"1080\" data-origin-height=\"2400\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">답답한 마음에 습관처럼 여러 AI 도구들에게 해지 방법을 물어봤다.</p>\n<p data-ke-size=\"size16\">Claude에게도</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"claude.png\" data-origin-width=\"1668\" data-origin-height=\"1080\"><span data-url=\"https://blog.kakaocdn.net/dn/ca1pJJ/dJMcafev34t/ONQfmcaKKK1AEJG3cAikIk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/ca1pJJ/dJMcafev34t/ONQfmcaKKK1AEJG3cAikIk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/ca1pJJ/dJMcafev34t/ONQfmcaKKK1AEJG3cAikIk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fca1pJJ%2FdJMcafev34t%2FONQfmcaKKK1AEJG3cAikIk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"1668\" height=\"1080\" data-filename=\"claude.png\" data-origin-width=\"1668\" data-origin-height=\"1080\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">GPT에게도</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"gpt.png\" data-origin-width=\"1930\" data-origin-height=\"1004\"><span data-url=\"https://blog.kakaocdn.net/dn/bB0FwB/dJMcac9P4SD/VDGKS3OtsT6lE9OsNlUuUk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/bB0FwB/dJMcac9P4SD/VDGKS3OtsT6lE9OsNlUuUk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/bB0FwB/dJMcac9P4SD/VDGKS3OtsT6lE9OsNlUuUk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbB0FwB%2FdJMcac9P4SD%2FVDGKS3OtsT6lE9OsNlUuUk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"1930\" height=\"1004\" data-filename=\"gpt.png\" data-origin-width=\"1930\" data-origin-height=\"1004\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">Gemini에게도</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"gemini.png\" data-origin-width=\"1630\" data-origin-height=\"1172\"><span data-url=\"https://blog.kakaocdn.net/dn/cZLDJM/dJMcaihXG4U/0BnwQX1QupeY0IBb98rJRK/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/cZLDJM/dJMcaihXG4U/0BnwQX1QupeY0IBb98rJRK/img.png\"><img src=\"https://blog.kakaocdn.net/dn/cZLDJM/dJMcaihXG4U/0BnwQX1QupeY0IBb98rJRK/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcZLDJM%2FdJMcaihXG4U%2F0BnwQX1QupeY0IBb98rJRK%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"1630\" height=\"1172\" data-filename=\"gemini.png\" data-origin-width=\"1630\" data-origin-height=\"1172\"/></span></figure>\n</p>\n<blockquote data-ke-style=\"style1\">\n<p data-ke-size=\"size16\">참고로 3개 AI 서비스 모두 가장 높은 모드로 질문했다.</p>\n</blockquote>\n<p data-ke-size=\"size16\"><b>모두가 페이북 앱 내에 해지가 있다고 안내했다</b>.</p>\n<p data-ke-size=\"size16\">좀 더 찾아보니 BC 카드는 예전에 BC카드 앱이 별도로 있다가 페이북 앱으로 전환이 되었다.<br />과거의 페이북 앱에는 직접 해지가 있었지만, 최근의 페이북 앱에는 해지 기능이 없어졌다.</p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"4.png\" data-origin-width=\"1196\" data-origin-height=\"596\"><span data-url=\"https://blog.kakaocdn.net/dn/rfnFK/dJMcaihXG5y/EvLILR0zhnaJZJedwSKZhk/img.png\" data-phocus=\"https://blog.kakaocdn.net/dn/rfnFK/dJMcaihXG5y/EvLILR0zhnaJZJedwSKZhk/img.png\"><img src=\"https://blog.kakaocdn.net/dn/rfnFK/dJMcaihXG5y/EvLILR0zhnaJZJedwSKZhk/img.png\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrfnFK%2FdJMcaihXG5y%2FEvLILR0zhnaJZJedwSKZhk%2Fimg.png\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"1196\" height=\"596\" data-filename=\"4.png\" data-origin-width=\"1196\" data-origin-height=\"596\"/></span></figure>\n</p>\n<p data-ke-size=\"size16\">그래서 대부분의 블로그 글이 과거의 BC카드 앱이나 과거의 페이북 앱 기준으로 작성된 글이 많았다.<br />아무래도 AI는 과거의 데이터를 기반으로 답변을 하니 어쩔 수 없단 생각에 직접 찾아보기로 했다.</p>\n<p data-ke-size=\"size16\">가장 최신의 방법을 찾으면 되니, 최신 기준으로 네이버 검색을 다시 했다.</p>\n<p data-ke-size=\"size16\">그런데 <b>가장 최신의 글들도 대부분이 AI가 작성한 블로그 글이었고, 그 AI는 예전에 작성된 글을 참고해서 여전히 과거의 해지 방법을 소개</b>하고 있었다.</p>\n<p data-ke-size=\"size16\">최신순으로 검색해도 내가 원하는 정보를 못 찾는 상황이 된 것이다.</p>\n<p data-ke-size=\"size16\">Claude에게 내가 원하는 조건의 해지 방법을 갖고 있는 네이버 블로그 글을 탐색하도록 시키고, 혹시 몰라 나도 하나씩 읽어보면서 찾아봤다.</p>\n<p data-ke-size=\"size16\">결국엔 <a href=\"https://blog.naver.com/yuretomo9/224108014416\">디지털 ARS로는 해지가 가능하다</a>는 것을 알게 되어서 디지털 ARS로 해지를 신청했다.</p>\n<p data-ke-size=\"size16\">신용카드 하나 해지하는 데 2시간을 보냈다.</p>\n<hr data-ke-style=\"style1\" />\n<p data-ke-size=\"size16\">AI가 답변을 다 해주는데 블로그 글을 쓰는 게 의미가 있는 것인가, 무엇을 써야 하는 것인가에 대한 질문을 자주 받는다.</p>\n<p data-ke-size=\"size16\">이번 일을 겪으면서 오히려 그 반대라는 확신이 생겼다.<br /><b>직접 해본 경험기를 남기는 것</b>이 훨씬 더 중요해졌다.</p>\n<p data-ke-size=\"size16\">AI 시대가 되면서, 어떤 방법이든 해결만 하면 되는 문제는 확실히 예전보다 쉬워졌다.<br />하지만 내가 원하는 특정 방법을 찾는 것은 오히려 더 어려워졌다.<br />실제로 그 일을 하지 않고도 그 일을 한 것처럼 과정을 공유하는 것이 너무나 쉬워졌기 때문이다.</p>\n<p data-ke-size=\"size16\">예전에도 원하는 정보를 찾는 것은 어려웠다.<br />그런데 이젠 가장 최신의 글조차도 과거 글의 복제본이어서 무효한 경우가 다반사가 되었다.</p>\n<p data-ke-size=\"size16\">그래서 점점 이런 것이 중요해진다고 생각한다.</p>\n<p data-ke-size=\"size16\">\"<b>저 사람은 항상 자신이 직접 하는 사람이야, 실제로 본인이 해본 것을 기록하는 사람이야</b>.\"</p>\n<p data-ke-size=\"size16\">작성자보다는 콘텐츠가 중요하다고 하는 시기도 있었지만, 이제는 작성자가 훨씬 더 중요하다.<br /><b>작성자가 신뢰할 만한 사람이냐</b>가 콘텐츠의 가치를 결정하는 시대가 된 것이다.</p>\n<p data-ke-size=\"size16\">그러니 AI의 도움을 받아 더 많이 직접 실행하고 경험해봐야 한다.<br />그리고 그걸 기록으로 남겨야 한다.</p>\n<p data-ke-size=\"size16\">AI로 얻게 된 가장 큰 장점은 더 많은 경험을 더 빠르게 해볼 수 있다는 것이다.<br /><b>AI를 간접 경험의 도구가 아니라, 직접 경험을 더 쉽고 빠르게, 더 깊게 해볼 수 있는 도구로 사용하는 것.</b><br />그것이 앞으로의 시대를 준비하는 가장 좋은 방법이 아닐까 싶다.</p>",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://jojoldu.tistory.com/865"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "회사에서 AI 개발 도구를 지원하지 않는다면",
    "partialText": "<p>요즘 다들 AI 도구에 대한 FOMO를 이야기하지만,<br>이메일로 고민 상담을 들어보면 여전히 AI 도구에 대한 사내의 공식적인 지원이 없는 경우가 많다.<br>(예전에 JetBrains 도구의 지원이 없어서 STS, Eclipse를 쓰던 것처럼..)</p>\n<p>물론, 금융권과 같이 특수하게 높은 보안 레벨을 유지해야 하는 서비스의 특성상 AI 도구 자체가 금지되는 경우도 있다.<br>이런 경우는 당연히 어쩔 수 없다.  </p>\n<p>하지만 그런 도메인의 특성이 없는 경우에도 AI 도구를 지원하지 않는 경우가 많다.<br>그럴 땐 어떻게 해야 할까?  </p>\n<p>10년 전이나 지금이나 개인의 생산성과 성장을 위해 필요하면 개인 비용으로 당연히 사용할 수 있다.</p>\n<p>그렇지만, 개인에 따라 그 비용도 부담스러울 수 있다.<br>요즘의 환율로 계산하면 거의 월 30만원은 돼야 하나의 도구를 제대로 써볼 수 있는 시대에는 특히나 그렇다.  </p>\n<p>지금의 AI 시대를 그냥 회사 탓하면서 보낼 순 없다.<br>그럴 경우엔 개인적으로 Amazon Web Services (AWS) Kiro와 JetBrains Junie, 이 두 가지를 검토해보는 것을 추천한다.</p>\n<p>이유는 단순하다.<br>이 두 도구는 이미 회사에서 쓰고 있을 가능성이 높은 플랫폼 위에 있기 때문이다.  </p>\n<p>JetBrains의 Junie는 All Product 라이선스가 있을 경우 AI Pro 라이선스로 사용할 수 있다.<br>(물론, JetBrains All Product 라이선스를 지원하면 AI 도구도 충분히 지원하는 회사이지 않겠냐고 할 수 있다.<br>이미 JetBrains IDE에 대한 지원을 하고 거기에 추가로 AI 도구까지 지원하는 그 +α의 비용을 부담스러워해서 미지원하는 경우가 생각보다 많다.)  </p>\n<p>이 경우 JetBrains의 Junie는 충분히 AI 개발 경험을 쌓을 수 있는 도구다.</p>\n<p>다른 AI 도구들의 Max Plan처럼 미친 듯이 토큰을 사용할 수 있을 정도는 아니지만, 그래도 어느 정도는 에이전틱 프로그래밍에 대한 경험을 쌓아볼 수는 있다.  </p>\n<p>AWS는 국내에서는 거의 대부분의 서비스가 사용하고 있는 클라우드이다.</p>\n<p>AWS Kiro의 장점은 바로 그 AWS Billing에서 비용이 관리되어 별도의 계약이나 재무적 협의가 필요하지 않다는 점, 그리고 요즘 AWS에서 크레딧 지원을 많이 해준다는 점이다.  </p>\n<p>Claude Code, Codex, Cursor와 같은 도구들은 아무리 좋아도 회사에 도입하려면 새로운 벤더와의 계약, 신규 예산 품의, 보안 검토 등을 처음부터 시작해야 한다.  </p>\n<p>그런데 Kiro와 Junie는 이미 회사가 쓰고 있는 AWS, 젯브레인 생태계 안에 있다.<br>즉, 새로운 벤더를 찾아 계약하는 것이 아니라 큰 협의 과정 없이 시작할 수 있다.</p>\n<p>앞서 이야기한 예산 품의, 보안 심사 같은 산들이 한꺼번에 낮아진다.</p>\n<p>솔직히 AI 코딩 도구의 성능 차이는 몇 달 단위로 뒤집힌다.<br>오늘 A가 좋아도 내일 B가 더 좋아질 수 있고, 그 반대도 마찬가지다.</p>\n<p>그래서 나는 &quot;어떤 도구가 가장 뛰어난가&quot;보다 &quot;어떤 도구를 우리 팀이 가장 빨리 쓸 수 있는가&quot;가 더 중요하다고 생각한다.</p>\n<p>아무리 좋은 도구도 도입까지 6개월이 걸리면 의미가 없다.<br>지금 당장 쓸 수 있는 도구를 먼저 도입하고, 팀이 AI 코딩에 익숙해지는 것이 훨씬 더 가치 있다.</p>\n<p>그런 관점에서 AI 도구를 사용하기 위해 사내에서 협의해야 할 것들이 너무 많다면, AWS Kiro와 JetBrains Junie를 고민해보는 것을 추천한다.</p>\n<hr>\n<p>&quot;좋은 건 알겠는데, 리더에게 어떻게 말씀드리지?&quot; 라는 고민이 있을 수 있다.    </p>\n<p>특히 Kiro의 경우 AWS 위에 있다 보니, 기존 예산 체계나 계정 관리 측면에서 리더를 설득할 수 있는 구체적인 포인트들이 있다.<br>Yan So 님이 이런 부분을 잘 정리해주신 글이 있어서 공유한다.</p>\n<p><a href=\"https://yanlog.yanbert.com/ko/blog/dear-team-lead-lets-adopt-kiro-20260211/\">Kiro를 기업에서 쓰기 좋은 이유 (IAM Identity Center)</a></p>\n<p>&quot;왜 우리 리더들은 AI 도구를 지원하지 않는 것인가&quot;에 대해 리더의 입장에서의 시각과 그들을 설득하기 위한 충분한 근거를 자세히 설명해 주셨다.<br>예산과 비용 처리 관점에서 왜 도입이 지연되는지, 그리고 리더 입장에서 Kiro를 어떤 포인트로 검토하면 좋을지가 실무적으로 정리되어 있다.</p>\n<p>AI 코딩 도구 도입이 아직인 조직이 있다면, 한번 읽어보고 팀 리더에게 제안해보자.</p>",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://jojoldu.tistory.com/864"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[SE-0508] Array expression trailing closures",
    "partialText": "<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">안녕하세요.&nbsp;<span style=\"color: #409d00;\"><b>그린</b></span>입니다  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이번 포스팅에서는&nbsp;<span style=\"background-color: #9feec3;\"><b>SE-0508 Array expression trailing closures</b></span>에 대해 정리해보겠습니다  </span><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"></span></p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"123123.001.jpeg\" data-origin-width=\"400\" data-origin-height=\"400\"><span data-url=\"https://blog.kakaocdn.net/dn/lVn5h/dJMcaaxtxgV/YOvOdlsqXs5DWM4QP2WLO1/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/lVn5h/dJMcaaxtxgV/YOvOdlsqXs5DWM4QP2WLO1/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/lVn5h/dJMcaaxtxgV/YOvOdlsqXs5DWM4QP2WLO1/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlVn5h%2FdJMcaaxtxgV%2FYOvOdlsqXs5DWM4QP2WLO1%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"400\" height=\"400\" data-filename=\"123123.001.jpeg\" data-origin-width=\"400\" data-origin-height=\"400\"/></span></figure>\n</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Intro</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift에서 trailing closure는 정말 자주 쓰는 문법이죠.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">그런데 array나 dictionary 타입 뒤에는 trailing closure를 쓸 수 없다는 걸 아셨나요?<br /><br /></span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">[String]&nbsp;같은 타입 뒤에 중괄호를 쓰면 파서가 제대로 인식하지 못해서 에러가 발생합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이번 SE-0508은 바로 이 제약을 풀어주는 제안입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이미&nbsp;<b>Accepted</b>&nbsp;상태이고 구현도 완료되었으니, 곧 실제로 활용할 수 있을거에요  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>왜 필요한가?</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array에 trailing closure를 받는&nbsp;init을 정의하는 건 꽤 합리적인 디자인입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">예를 들어&nbsp;@ArrayBuilder&nbsp;result builder가 있다면</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension Array {\n    init(@ArrayBuilder build: () -&gt; [Element]) {\n        self = build()\n    }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">또는 nil을 반환할 때까지 element를 생성하는 init</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension Array {\n    init(generate: () -&gt; Element?) {\n        self = []\n        while let element = generate() {\n            append(element)\n        }\n    }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>하지만 이렇게 쓸 수 없습니다</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">대부분의 경우 closure를 받는&nbsp;init은 trailing closure 문법으로 호출할 수 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">그런데&nbsp;Array나&nbsp;Dictionary&nbsp;타입에서는 파서가 이를 허용하지 않아요.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>// error: 'let' declarations cannot be computed properties\nlet value = [String] {\n  \"a\"\n}\n\n// error: variable with getter/setter cannot have an initial value\nvar value = [String] {\n  \"a\"\n}\n\n// error: closure expression is unused\nlet value = [String]\n{\n  \"a\"\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">대신 이렇게 써야 합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let value = [String].init {\n  \"a\"\n}\n\nlet value = [String]() {\n  \"a\"\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>InlineArray는 된다?</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">흥미롭게도&nbsp;InlineArray에서는 trailing closure가&nbsp;<b>이미 지원됩니다</b>:</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let powersOfTwo = [4 of Int] { index in\n  1 &lt;&lt; index\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p data-ke-size=\"size16\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array와&nbsp;Dictionary에서만 안 되는 건 불필요한 제약이고,&nbsp;InlineArray와도 일관성이 없습니다.</span></p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>제안된 해결책</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array 타입과 dictionary 타입 뒤에 trailing closure를 쓸 수 있게 합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let value = [String] {\n  \"a\"\n}\n\nlet value = [String: Int] {\n  (key: \"a\", value: 42)\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">이제 이런 코드가 정상적으로 파싱되고 컴파일됩니다!</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>어떻게 동작하나?</b></span></h2>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">현재 파싱 동작을 이해하려면 두 가지를 알아야 합니다.</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>1.&nbsp;[...]는 항상 literal로 파싱됨</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">표현식을 파싱할 때&nbsp;[...]&nbsp;토큰은 항상 array나 dictionary&nbsp;<b>literal</b>로 파싱됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">[String]이나&nbsp;[String: Int]&nbsp;같은 경우, 필요하면 타입 체크 단계에서 array/dictionary&nbsp;<b>타입</b>으로 변환됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">[String]이 실제로는&nbsp;let String = \"a\"&nbsp;프로퍼티를 사용하는 단일 요소 array literal일 수도 있으니까요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>2. 중괄호는 trailing closure... 단 literal 뒤는 제외</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">표현식 뒤에&nbsp;{&nbsp;토큰이 오면 trailing closure로 해석됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>단, 이전 표현식이 literal인 경우는 제외</b>입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift 5.2에서&nbsp;callAsFunction이 도입되기 전(SE-0253)까지는 이게 합리적이었습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">literal 뒤에 trailing closure가 올 valid한 케이스가 없었거든요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>솔루션</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><b><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array와 dictionary literal 뒤에 trailing closure를 허용하도록 변경합니다.</span></b></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이렇게 하면 이런 init(_:) trailing closure 예시가 제대로 파싱되고 컴파일됩니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let value = [String] {\n  \"a\"\n}\n\nlet value = [String: Int] {\n  (key: \"a\", value: 42)\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>추가 효과: callAsFunction도 지원</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">결과적으로 callAsFunction trailing closure도 지원됩니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension Array {\n    func callAsFunction&lt;T&gt;(mapElement: (Element) -&gt; T) -&gt; [T] {\n        map(mapElement)\n    }\n}\n\nlet value = [\"a\", \"b\", \"c\"] {\n    $0.uppercased()\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">작은 비용으로 언어의 표현력과 일관성이 크게 향상됩니다.</span></blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>호환성</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Source compatibility</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이 파싱 변경은 array literal 뒤에 오는 기존 closure literal의 의미를 바꿉니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 현재 실제로 컴파일되는 케이스는 거의 없어요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">대부분은 closure expression is unused 에러가 납니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>[\"a\", \"b\", \"c\"] { // error: closure expression is unused\n  \"a\"\n}\n\n[\"a\", \"b\", \"c\"]\n{ \"a\" } // error: closure expression is unused</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>에러가 안 나는 유일한 케이스</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Closure를 받는 result builder에서만 에러가 안 납니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>@resultBuilder\nenum FunctionArrayBuilder {\n    static func buildBlock(_ components: (() -&gt; Void)...) -&gt; [() -&gt; Void] {\n        components\n    }\n}\n\n@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    { print(array) }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이 코드는 이제 컴파일되지 않습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><b><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 이 result builder 케이스는 이미 매우 취약하고 비실용적입니다.</span></b></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>왜 취약한가?</b></span></h2>\n<ul style=\"list-style-type: circle; color: #000000; text-align: start;\" data-ke-list-type=\"circle\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>연속된 closure literal은 세미콜론 없이 지원 안 됨</b></span></li>\n</ul>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    { print(\"a\") }\n    { print(\"b\") } // error: extra trailing closure passed in call\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<ul style=\"list-style-type: circle; color: #000000; text-align: start;\" data-ke-list-type=\"circle\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>작은 변경으로도 컴파일이 깨짐</b></span></li>\n</ul>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>// Compiles\n@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    { print(array) };\n    { print(array.count) }\n}</code></pre>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>// Doesn't compile\n@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    let count = array.count\n    { print(array) }; // error: cannot convert value of type '()' to closure result type 'Bool'\n    { print(count) }\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<ul style=\"list-style-type: circle; color: #000000; text-align: start;\" data-ke-list-type=\"circle\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>callAsFunction이 있으면 의미가 바뀜</b></span></li>\n</ul>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension Int {\n  func callAsFunction(_ closure: () -&gt; Void) -&gt; Int {\n    closure()\n    return self\n  }\n}\n\n@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    let count = array.count\n    { print(array) }; // callAsFunction trailing closure, not an accumulated result builder value\n    { print(count) }\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">이런 케이스는 실제로 사용되는 예시가 없고, 더 복잡한 파싱 규칙으로 수용하는 것보다 이 source break를 받아들이는 게 낫다고 판단했습니다.</span></blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>ABI compatibility</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">기존 선언에 대한 새로운 callsite 문법만 추가하는 거라 ABI에 영향이 없습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>향후 방향</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>모든 literal에 trailing closure 허용?</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이 제안은 array와 dictionary literal만 지원합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">더 나아가서&nbsp;<b>모든 literal</b>에 trailing closure를 허용할 수도 있어요.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension String {\n  func callAsFunction(_ closure: (String) -&gt; Void) {\n    closure(self)\n  }\n}\n\n\"Hello world\" { // currently, error: closure expression is unused \n  print($0)\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">다른 trailing closure 케이스와 더 일관되고, 특별한 단점도 없습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">다만 array/dictionary만큼 강력하게 동기부여되지는 않아요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array와 dictionary는 타입 표현식이 literal로 파싱되는 잠재적 모호성 때문에 특별하거든요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>고려된 대안들</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>추가 파싱 휴리스틱</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>같은 줄에서만 허용?</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Source break는 array literal 다음 줄에 result builder closure가 오는 경우입니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    { print(array) }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">같은 줄에 있으면 이미 컴파일되지 않습니다.<br /><br /></span></blockquote>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array1 = [\"a\", \"b\", \"c\"] { // error: cannot convert return expression of type '()' to return type '[String]'\n        print(array)\n    }\n\n    let array2 = [\"a\", \"b\", \"c\"] { // error: variable with getter/setter cannot have an initial value\n        [\"d\"]\n    }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">같은 줄일 때만 trailing closure로 처리하면 source break를 피할 수 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 이건 다른 모든 brace/trailing closure 케이스와 일관성이 없어요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let array = [\"a\", \"b\", \"c\"].map \n{ \n  $0.uppercased()\n}\n\nif array.count &gt;= 3\n{\n  print(\"success: \\(array)\")\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">이런 임의적인 불일치는 코드 포매팅 도구 같은 생태계 전반에 복잡성을 추가합니다.</span></blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Array 타입만 지원?</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array/dictionary&nbsp;<b>타입</b>만 지원하고 다른 literal은 제외하는 방법도 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">[String]&nbsp;타입은 valid한 표현식이 아니니까 source compatibility 문제가 없겠죠.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 파싱 시점에는 [String]이 타입인지 literal인지 알 수 없습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let String = \"a\"\nlet array = [String] // an array literal, [\"a\"]\n{ print(array) }</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">단일 요소 array/dictionary literal이고 단일 identifier를 포함하는 경우만 허용할 수도 있지만, 이러면&nbsp;callAsFunction&nbsp;케이스가 불필요하게 제거됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Conclusion</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">SE-0508은 이미&nbsp;<b>Accepted</b>되었고 구현도 완료된 상태입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">개인적으로는 정말 합리적인 개선이라고 생각해요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">InlineArray에서는 되는데&nbsp;Array에서는 안 된다는 게 말이 안 됐거든요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">@ArrayBuilder&nbsp;같은 result builder와 함께 쓰면 정말 깔끔한 API를 만들 수 있을 것 같습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">작은 변경이지만 언어의 일관성과 표현력을 크게 높여주는 개선이네요  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>References</b></span></h2>\n<figure id=\"og_1771051388731\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"object\" data-og-title=\"swift-evolution/proposals/0508-array-expression-trailing-closures.md at main &middot; swiftlang/swift-evolution\" data-og-description=\"This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution\" data-og-host=\"github.com\" data-og-source-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0508-array-expression-trailing-closures.md\" data-og-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0508-array-expression-trailing-closures.md\" data-og-image=\"https://scrap.kakaocdn.net/dn/bS0M8s/dJMb81fOPWD/c76NIZp9xG0ojyKY2eBNtk/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/efaHyc/dJMb86OX17s/mxgcN5ifXfbwk4u9N9Y4xK/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600\"><a href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0508-array-expression-trailing-closures.md\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0508-array-expression-trailing-closures.md\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/bS0M8s/dJMb81fOPWD/c76NIZp9xG0ojyKY2eBNtk/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/efaHyc/dJMb86OX17s/mxgcN5ifXfbwk4u9N9Y4xK/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">swift-evolution/proposals/0508-array-expression-trailing-closures.md at main &middot; swiftlang/swift-evolution</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution</p>\n<p class=\"og-host\" data-ke-size=\"size16\">github.com</p>\n</div>\n</a></figure>\n<figure id=\"og_1771051390535\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"Support trailing closure syntax for single-argument Array and Dictionary initializers\" data-og-description=\"In the recent discussion about @ArrayBuilder, it came up that trailing closure syntax is not currently supported in the most intuitive way for Array initializers like init(@ArrayBuilder build: () -&gt; [Element]): I investigated this on the parsing side, and \" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900\" data-og-url=\"https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900\" data-og-image=\"https://scrap.kakaocdn.net/dn/dGvRso/dJMb8RjX80E/0o15WTQ5BcEMSwkM8oqcrk/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/bUV400/dJMb8WMlMqJ/Nx7x25m9RFBMMED0ubWtO0/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/dGvRso/dJMb8RjX80E/0o15WTQ5BcEMSwkM8oqcrk/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/bUV400/dJMb8WMlMqJ/Nx7x25m9RFBMMED0ubWtO0/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">Support trailing closure syntax for single-argument Array and Dictionary initializers</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">In the recent discussion about @ArrayBuilder, it came up that trailing closure syntax is not currently supported in the most intuitive way for Array initializers like init(@ArrayBuilder build: () -&gt; [Element]): I investigated this on the parsing side, and</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>\n<figure id=\"og_1771051391760\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"SE-0508: Array expression trailing closures\" data-og-description=\"Hi everyone, The review of SE-0508: Array expression trailing closures begins now and runs through February 12, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would l\" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/se-0508-array-expression-trailing-closures/84479\" data-og-url=\"https://forums.swift.org/t/se-0508-array-expression-trailing-closures/84479\" data-og-image=\"https://scrap.kakaocdn.net/dn/mrO38/dJMb9cBEklL/KSq5U4vhCLOSpsia3zRM90/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/bh9p0b/dJMb9bvYwCl/uSf6zpRxKdTLUowmZ3JME0/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/se-0508-array-expression-trailing-closures/84479\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/se-0508-array-expression-trailing-closures/84479\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/mrO38/dJMb9cBEklL/KSq5U4vhCLOSpsia3zRM90/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/bh9p0b/dJMb9bvYwCl/uSf6zpRxKdTLUowmZ3JME0/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">SE-0508: Array expression trailing closures</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Hi everyone, The review of SE-0508: Array expression trailing closures begins now and runs through February 12, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would l</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>\n<figure id=\"og_1771051392730\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"[Accepted] SE-0508: Array expression trailing closures\" data-og-description=\"Hi all, The review of SE-0508: Array expression trailing closures concluded on February 12, 2026. The language steering group has decided to accept the proposal. Feedback was positive on adding language support for trailing closures after sugared array and\" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/accepted-se-0508-array-expression-trailing-closures/84728\" data-og-url=\"https://forums.swift.org/t/accepted-se-0508-array-expression-trailing-closures/84728\" data-og-image=\"https://scrap.kakaocdn.net/dn/c0FFeY/dJMb9kTZaKi/KsEQq7QczXPkymQBv9cl41/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cF03Ps/dJMb9dHkf7G/rhBtpMJDOLaoZQ4yVBmvc1/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/accepted-se-0508-array-expression-trailing-closures/84728\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/accepted-se-0508-array-expression-trailing-closures/84728\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/c0FFeY/dJMb9kTZaKi/KsEQq7QczXPkymQBv9cl41/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cF03Ps/dJMb9dHkf7G/rhBtpMJDOLaoZQ4yVBmvc1/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">[Accepted] SE-0508: Array expression trailing closures</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Hi all, The review of SE-0508: Array expression trailing closures concluded on February 12, 2026. The language steering group has decided to accept the proposal. Feedback was positive on adding language support for trailing closures after sugared array and</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://green1229.tistory.com/609"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "필드 단위 변경 이력(History) 추적 시스템",
    "partialText": "객체의 필드 변경 이력을 자동으로 추적해, 무엇이 어떻게 바뀌었는지 명확히 기록합니다.",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://cheese10yun.github.io/diff-history-part-1/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[번역] 시니어 개발자들은 왜 잘못된 프로젝트를 말리지 않을까?",
    "partialText": "<blockquote>\n<p>원저자의 허락 하에 원문 &lt;<a href=\"https://lalitm.com/post/why-senior-engineers-let-bad-projects-fail/\">Why Senior Engineers Let Bad Projects Fail</a>&gt;을 한국어로 번역한 글입니다. 번역본에 원저자의 개입은 없으며 일부 오역 및 의역이 존재할 수 있습니다.</p>\n</blockquote>\n<p>제가 주니어 개발자였을 때 제 선배 개발자는 저와 둘이 있을 때 이런 불만을 털어놓곤 했습니다. 다른 팀의 프로젝트를 가리키며 “그 프로젝트는 잘 안 될 것 같아. 잘못된 문제를 풀고 있어.”라고 했습니다. 저는 &quot;선배는 그렇게 잘 알고 있으면서 왜 그 팀에 가서 말하지 않는 걸까?&quot;라고만 생각했습니다. 말하지 않는 게 선배의 영향력을 낭비하는 것처럼 느껴졌습니다.</p>\n<p>지난주, 멘티에게 &quot;옆 팀 프로젝트는 초기 설계를 잘못해서 결국 방향을 바꿀 수밖에 없을 것 같다&quot;고 설명하자 멘티는 &quot;그럼 그냥 그 팀에 의견을 말하면 되지 않나요?&quot;라고 질문했습니다. 예전에 제가 가졌던 의문을 똑같이 듣자 굉장히 아이러니함을 느꼈습니다. 그때부터 여러 생각이 맴돌았는데, 그동안 제 입장이 꽤 바뀌었다는 걸 깨달았습니다.</p>\n<p><strong>바로 옳은 것과 효과적인 것은 다르다는 것을 배웠기 때문입니다.</strong></p>\n<p>규모가 큰 회사에서, &quot;잘못된 프로젝트&quot;라고 생각된다면 그에 대해 말하는 건 좋습니다. 하지만 적당히 말해야 합니다. 개발 경력이 쌓이면서, 애초에 들을 생각이 없는 사람과 논쟁하는 건 무의미하며, 그럴 땐 조언은 아껴 두는 편이 낫다는 것을 배웠습니다.</p>\n<h2 id=\"잘못된-프로젝트란\">잘못된 프로젝트란?</h2>\n<p>제가 말하는 &quot;잘못된 프로젝트&quot;는 여러 의미를 포괄합니다.</p>\n<ul>\n<li><strong>UX 관점</strong>: 제품을 불필요하게 복잡하게 만들거나, 존재하지 않는 문제를 풀거나, 이미 자리 잡은 워크플로를 망치는 프로젝트</li>\n<li><strong>기술 관점</strong>: 너무 복잡하게 설계되거나, 라이브러리 선택이 잘못되었거나, 성능이 나쁜 아키텍처를 고수하는 프로젝트</li>\n<li><strong>정치 관점</strong>: 유행하는 키워드를 지나치게 쫓거나, 승진·성과를 위한 명분으로 만드는 프로젝트</li>\n</ul>\n<p>한 가지 짚고 넘어가야 할 것은, 프로젝트가 &quot;잘못되었다&quot; 라는 것은 생명주기 상 많은 구간에서 <em>매우</em> 주관적이라는 점입니다. 소프트웨어 엔지니어링은 대부분 트레이드오프의 연속이고, 완벽하지는 않지만 당시 가진 정보 안에서 최선으로 보이는 결정을 내리게 됩니다. 과거의 선택이 옳았는지는 의견이 갈리는 경우가 많고, 그게 명확해지는 건 훨씬 나중의 일입니다. 제품이 출시된 후 몇 년이 지나서일 수도 있습니다.</p>\n<p>다만 시니어로 올라갈수록 소프트웨어 프로젝트에 대한 감각이 생기고, 그 결과 프로젝트 중 일부만 봐도 &quot;이건 말이 안 된다&quot;고 느끼는 순간이 옵니다. 그런 직감이 들기 시작하면, &quot;프로젝트가 잘못되었다&quot;는 신호로 받아 들입니다. 즉, 모두가 나쁘다고 인정하기 전에 먼저 알아챌 수 있는 그런 프로젝트를 말합니다.</p>\n<p>저의 경험을 하나 들어보면, 몇 년 전 구글에서 있었던 일이 기억에 남습니다. 사내 발표회에서 &quot;판도를 바꿀&quot; 프로젝트 하나가 큰 주목을 받았습니다. 두 개의 매우 큰 조직이 겹치는 프로젝트였습니다. 기술적으로 놀랍고 세련됐고, 어려운 문제들에 대한 기발한 아이디어가 가득했습니다.</p>\n<p>하지만 발표회에 앉아 있던 저는 리드 개발자에게 고개를 돌려 속삭였습니다. &quot;이 프로젝트 성공할 가능성 없죠?&quot; 그는 저를 보더니 &quot;그렇지.&quot;라고 대답했습니다. 저희 둘은 발표 즉시 문제를 파악했습니다. 프로젝트는 플랫폼 팀이 플래그십 제품 팀에게 핵심 사용자 플로우에 대한 통제권을 내줄 것을 전제로 설계되어 있었습니다. 기술적으로는 맞는 방향이었지만, 어떤 리드나 PM도 그만큼 핵심적인 것을 다른 팀에 넘기지 않는다는 게 문제였습니다. 정치적인 관점에서 이 프로젝트는 현실에서 이루어질 수 없었습니다.</p>\n<p>프로젝트는 거의 2년 동안 조용히 진행됐습니다. 출시가 가까워질 때마다 &quot;아직 준비가 안 됐다&quot;며 미뤄졌고, 시간이 지나며 이야기는 줄다가, 결국 예상했던 &quot;전략적 프로젝트 방향 수정&quot; 메일이 도착했습니다. 인력은 재분배되고 코드는 삭제됐습니다. 회사는 &quot;그 과정에서 많은 것을 배웠다&quot;고 했지만, 저는 처음부터 실패가 정해진 것처럼 느꼈습니다. 기술적 완성도만큼 정치와 올바른 문제 정의가 중요하다는 걸 그 프로젝트에서 다시 한번 배웠습니다.</p>\n<h2 id=\"왜-막으면-안-될까\">왜 막으면 안 될까?</h2>\n<p>&quot;잘못된 프로젝트&quot;가 보이기 시작하고, 어느정도 스스로에게 전문성이 있다고 느꼈을 때, 저는 프로젝트를 지적하고 싶은 유혹을 느꼈습니다. 해당 팀에 연락해 &quot;이건 말이 안 됩니다&quot;라고 말하고, 이유를 설명하는 방식으로요. 팩트와 논리로 설득하려 했습니다.</p>\n<p>그리고 저는 실제로 그렇게 했습니다. 하지만 곧, 이런 행동에는 제가 생각지 못한 비용이 크다는 걸 깨달았습니다.</p>\n<p>일단, 소프트웨어 회사는 행동을 우선시하는 경향이 있습니다. 속도와 출시를 매우 중요하게 봅니다. 우려를 제기하면, 당연히 프로젝트의 <em>속도가 늦어지고</em> 예정에 없던 검토가 들어갑니다. 그래서 &quot;빨리 배포하려는 분위기&quot;를 넘어설 만큼 큰 이유가 없다면, 말을 해도 의미 있는 변화가 나올 가능성은 거의 없습니다. 오히려 무시당할 가능성이 큽니다.</p>\n<p>이와 관련하여, 팀이 우려를 진지하게 <em>받아들이는</em> 편이라 해도 자주 하면 안 됩니다. 한두 번일 땐 &quot;품질&quot;을 지키는 개발자로 보일 수 있지만, 너무 자주 하면 &quot;부정적인 사람&quot;으로 보입니다. 문제를 해결하는 사람이 아니라 문제를 만드는 사람으로 보이게 됩니다. 재앙을 막아내도 공은 거의 돌아오지 않습니다. 아무 일도 일어나지 않았기 때문에 사람들은 금방 잊어버립니다.</p>\n<p>또한, 반대할 때마다 누군가의 등급 평가나 높은 사람이 아끼는 프로젝트를 건드릴 수 있다는 문제가 있습니다. 관계를 망치고 &quot;적&quot;을 만들 위험이 있습니다. 대기업에서 자기와 의견이 다른 사람들은 당연히 어느정도 생기기 마련이지만, 그 수가 너무 많아지면 본업에도 영향을 미치기 시작합니다.</p>\n<p>마지막으로 심리적 영향도 있습니다. 전문성이 도움이 될 수 있는 영역에서 일하는 엔지니어는 수백 명인데, 당신은 한 명입니다. 개인의 집중력 양은 한계가 있는데, 대기업에서 잘못된 아이디어를 만들어 내는 건 너무 다양합니다. 경험상, 이런 것들을 막는 데 너무 깊이 관여하면 냉소적인 개발자가 되기 쉽고 여러분에게 전혀 좋지 않습니다.</p>\n<h2 id=\"영향력을-은행-계좌처럼\">영향력을 은행 계좌처럼</h2>\n<p>모든 나쁜 프로젝트를 막을 수 없다면 어떻게 해야 할까요? 전략적으로 접근해야 합니다. 모든 것을 고치려 하기보다, 본인의 영향력을 은행 계좌처럼 바라보는 관점을 가지면 좋습니다. 성실히 개발하고, 동료를 돕고, 성공적인 프로젝트를 출시하며, 전반적으로 조직 내의 마찰을 최소화하다보면, 매달 일정량의 &quot;영향력&quot;이 여러분의 계좌에 입금됩니다.</p>\n<p>그리고 정말 중요한 순간에는 영향력을 &quot;출금할&quot; 준비가 되어 있어야 합니다. 무언가를 막거나 우려를 제기할 때마다, 그 사안이 아무리 사소하더라도 본인의 잔고에서 수표를 끊는 것과 같습니다. 다만 항상 같은 금액인 건 아닙니다.</p>\n<ul>\n<li><strong>5,000₩ 수표</strong>: 코드 리뷰로 사소하게 지적하기, 부담이 적고 일상적으로 발생하는 지출</li>\n<li><strong>500,000₩ 수표</strong>: 아키텍처 결정을 문제 삼거나 일정에 대해 반대 의견을 내기, 어느 정도의 잔고가 필요함</li>\n<li><strong>50,000,000₩ 수표</strong>: 임원이 &quot;아끼는 프로젝트”를 없애려는 정도의 시도, 엄청난 지출로 몇 년에 한 번 정도만 감당할 수 있을지도 모름</li>\n</ul>\n<p>문제는 눈에 보이는 모든 작은 비효율에 대해 매번 5천 원씩 쓰기 시작할 때 발생합니다. 사소한 일마다 계속 &quot;안 된다&quot;고 말하면, 진짜 재앙을 막기 위해 큰 수표를 써야 할 때 계좌는 이미 텅 비어 있습니다.</p>\n<p>만약 &quot;잔고를 초과해&quot; 버리면, 곧바로 정치적 파산 상태에 돌입합니다. 사람들은 더 이상 회의에 당신을 부르지 않고, 의견을 묻지 않으며, 사실상 당신을 무시하며 일을 진행하기 시작합니다. 일단 파산하면 영향력은 0이 되며, 조직에 영향을 미칠 능력뿐 아니라 본인이 일을 추진하고 성과를 내는 능력에도 악영향을 끼치게 됩니다.</p>\n<h2 id=\"영향력은-언제-써야-하는가\">영향력은 언제 써야 하는가?</h2>\n<p>이제 우리는 모든 일에 의견을 낼 수 없다는 사실을 알게 됐습니다. 그렇다면 언제 의견을 <em>내는 게</em> 좋을지 판단해야 합니다.</p>\n<p>가장 먼저 해야 할 일은 겸손의 자세를 갖고, 자신이 실제로 판단을 내릴 만한 전문성을 갖추고 있는지 평가하는 것입니다. 시니어가 되면 의견이 많아지기 마련이지만, 그 의견이 항상 근거가 있는 건 아닙니다. 예를 들어 저는 프런트엔드 경험이 어느 정도는 있지만, 깊이 있는 조언을 할 만큼 전문적이라고 생각하진 않습니다. &quot;그럭저럭 해낼 수 있는 수준&quot;이지, 장기간 책임지고 다루면서 쌓인 깊은 전문성은 아니기 때문입니다. 좋은 판단에는 충분한 정보가 필요하다는 점을 간과하기 쉽습니다. 만약 본인이 이런 상황이라면, 의견을 가진 관찰자의 역할 정도의 선에서 멈추는 편이 낫습니다.</p>\n<p>또한 &quot;내 말이 곧 답이다&quot;라는 착각에서 반드시 벗어나야 합니다. 여러분이 하는 일은 명령을 내리는 것이 아니라, 하나의 관점을 제시하여 리스크를 공유하는 것입니다. 따라서 어떤 팀이 당신의 우려를 듣고도 그대로 진행하기로 결정한다면, 그 또한 받아들여야 합니다. 우리는 엔지니어일뿐, 권한을 행사할 수 있는 CEO가 아닙니다.</p>\n<p>이런 전제를 바탕으로, 저는 의견을 낼지 말지 결정할 때 다음 세 가지 요소를 주로 고려합니다.</p>\n<ol>\n<li><strong>이 프로젝트가 우리 팀과 얼마나 가까운가?</strong></li>\n<li><strong>이 프로젝트가 잘못되었을 때 우리 팀에 미치는 영향은 어느 정도인가?</strong></li>\n<li><strong>이 프로젝트가 잘못되었을 때 회사 전체에 미치는 영향은 어느 정도인가?</strong></li>\n</ol>\n<!-- 좀 더 읽기 쉽도록 인덱싱 넣었습니다 -->\n\n<h3 id=\"근접성\">근접성</h3>\n<p>프로젝트가 내 영역에 가까울수록, 무언가를 지적하는 데 드는 &quot;비용&quot;은 낮아집니다. 우리 팀 내부의 일이라면 신뢰 관계가 높기 때문에 비용이 거의 0에 가깝고, 간단한 대화만으로도 해결되는 경우가 많습니다. 하지만 더 넓은 조직 단위로 넘어가면 비용이 올라갑니다. 사회적 자본을 사용해야 하고, 때로는 본인의 평판을 걸어야 할 수도 있습니다. 조직 바깥의 프로젝트라면 비용은 대개 감당하기 어려울 정도로 커집니다. 영향력을 행사할 수단도 없고, 보고 체계도 다르며, 이를 막으려면 엄청난 규모의 &quot;출금&quot;이 필요하기 때문입니다.</p>\n<h3 id=\"팀에-미치는-영향\">팀에 미치는 영향</h3>\n<p>때로는 다른 조직의 결정이 우리 팀 업무에 큰 영향을 미치기도 합니다. 예를 들어 제가 담당하는 성능 툴인 <a href=\"https://perfetto.dev/\">Perfetto</a>는 구글 전반에서 사용되므로, 어떤 팀이 매우 복잡한 통합 작업에 대해 우리 팀에 승인을 요청하는 경우가 있습니다. 이 상황은 전형적인 리스크를 가집니다. 일이 잘되면 그 팀이 공을 가져가지만, 잘못될 경우에는 우리 팀이 원인 제공을 하지 않았음에도 문제를 해결해야 합니다. 이런 경우엔 의견을 내는 게 우리 팀을 보호하는 행위이므로 돌아오는 보상이 매우 큽니다.</p>\n<h3 id=\"회사에-미치는-피해-규모\">회사에 미치는 피해 규모</h3>\n<p>마지막으로 고려해야 할 것은 피해 범위입니다. 어떤 프로젝트는 실패하더라도 그 프로젝트 하나만 무너집니다. 하지만 어떤 프로젝트는 핵심 시스템과 긴밀히 연결되어 있어, 광범위한 피해를 유발하거나 수년간 지속되는 기술 부채를 만들어 냅니다. 이런 프로젝트는 장기적인 시스템의 건강을 해치는 치명적인 요인이 될 수 있습니다.</p>\n<h2 id=\"잘못된-프로젝트를-어떻게-대할-것인가\">잘못된 프로젝트를 어떻게 대할 것인가?</h2>\n<p>말을 언제 꺼내는지만 중요한 게 아니라 어떻게 꺼내는지도 중요합니다. 상황에 따라 할 수 있는 행동의 폭은 꽤 넓습니다.</p>\n<h3 id=\"개입할-때\">개입할 때</h3>\n<p>가장 극단적인 방법은 &quot;이건 하면 안 됩니다&quot;라고 직접 말하고 프로젝트를 중단시키려는 것입니다. 이는 거의 항상 리더에게 먼저 보고하고, 해당 프로젝트를 소유한 팀의 리더에게도 공식적으로 문제를 제기하는 절차를 밟아야 합니다. 따라서 본인이 옳다는 확신뿐 아니라, 이 프로젝트가 실제로 해롭고 위험하다는 점에 대해서도 강한 확신이 있어야 합니다. 어떤 경우에는 이렇게 하는 게 맞습니다. 특히 말하지 않았을 때의 대가가 우리 프로젝트나 팀의 존재 자체를 위협할 때는 더욱 그렇습니다.</p>\n<p>이보다 약간 더 부드럽지만 여전히 위험한 방법도 있습니다. 공식적인 문제 제기 대신 해당 팀에 직접 우려를 표하는 것입니다. 보통 팀과의 미팅이나 강한 어조의 &quot;우려&quot; 또는 &quot;반론&quot;을 적은 문서로 이뤄집니다. 충분히 강하게 말함으로써 이 방법은 프로젝트를 수행하려는 팀 스스로 &quot;이 프로젝트는 위험할 수 있다&quot;고 결론 내리게끔 하는 것을 목적으로 합니다.</p>\n<p>그보다 더 작은 개입이 있습니다. 즉, 전체적으로는 타당해 보이지만 접근 방식이 잘못된 상황에서, 일을 올바른 방향으로 살짝 유도하는 것입니다. 저는 Perfetto에서 이런 경우를 자주 봅니다. 어떤 팀이 Perfetto를 복잡하게 활용하겠다는 설계 문서를 보내오는데, 저는 그 방식이 결국 그 팀을 괴롭힐 것이라는 걸 알고 있습니다. 그래서 그들과 마주 앉아 문제를 파악하고, 더 나은 해결책으로 유도합니다. 이 과정은 한 시간 정도의 시간이 들지만, 결과적으로는 그 팀이 몇 달을 낭비하는 것을 막습니다. 그리고 일이 잘 풀리면, 팀의 속도를 다소 늦췄지만, 방해꾼이 아니라 도와주는 사람으로 인식될 수도 있습니다.</p>\n<h3 id=\"개입하지-않을-때\">개입하지 않을 때</h3>\n<p>때로는 직접적으로 뭔가를 하기에는 가성비가 좋지 않다고 생각되는 경우가 있습니다. 정치적 흐름이 너무 강하게 굳어져 있거나, 문제 자체가 영향력을 쓸 만큼 크지 않을 수도 있습니다. 이 시점에서 어떻게 행동할지는, 그 일이 우리 팀과 얼마나 관련이 있는지에 따라 달라집니다.</p>\n<p>프로젝트가 우리 팀의 업무와 크게 겹친다면, 눈에 띄지 않게 대비책을 마련하는 게 좋습니다. 예를 들어 해당 프로젝트에 대한 의존도를 줄이거나, 혹시 그 프로젝트가 사라지더라도 대응할 수 있도록 추상화 계층을 만들어두는 방식입니다. 여기에는 장기적인 전략도 있습니다. 잘못된 프로젝트라고 해도, 대개는 어느 정도 “좋은 아이디어의 핵심”이 존재합니다. 즉, 해결하려던 구체적인 문제나, 그 기반이 된 통찰이 있습니다. 만약 그것이 본인의 업무와 맞닿아 있다면, 그 핵심을 가져와서 더 나은 형태로 개선한 해결책을 자신의 프로젝트에 자연스럽게 녹여내는 것이 좋은 선택지가 됩니다. 그렇게 해두면, 해당 프로젝트가 늦어지거나 중단될 때 그 여파에 끌려다니지 않고, 미리 준비된 상태로 대응할 수 있습니다.</p>\n<p>반대로 본인이 그 일에 직접적으로 관련되어 있지 않다면, 선택은 간단합니다. 그냥 거리를 두면 됩니다. 친한 동료들과 사적으로는 불평하고 공감할 수 있겠지만, 공개적으로는 현실을 받아들이고 조용히 넘어가는 편이 낫습니다.</p>\n<h3 id=\"그-과정에서-팀을-이끌기\">그 과정에서 팀을 이끌기</h3>\n<p>마지막으로, 그 과정을 거치는 동안 자신의 팀을 잘 관리해야 합니다. 여러분이 어떤 프로젝트의 문제점을 알아차릴 수 있다면, 다른 시니어 개발자들도 아마 같은 문제를 보고 있을 가능성이 큽니다. 이때 팀원들을 속이거나, &quot;회사의 공식 입장을 그대로 따라가며&quot; 잘못된 프로젝트를 괜찮은 것처럼 포장하지 마세요. 그런 태도는 신뢰를 무너뜨립니다.</p>\n<p>대신, 불필요한 정치적 뒷이야기까지 늘어놓지 않으면서도 현재 상황에서 확인되는 사실은 솔직하게 공유해야 합니다. 그리고 이러한 제약 속에서도 본인이 할 수 있는 최선을 다하겠다고 팀에 말해주어야 합니다.</p>\n<h2 id=\"결론\">결론</h2>\n<p>그렇다면 지난주, 멘티의 질문에 저는 뭐라고 답했을까요?</p>\n<p>“제가 배운 건, 옳은 것과 효과적인 것은 다르다는 점이에요. 물론 그 팀에 가서 우려를 이야기할 수도 있습니다. 하지만 아마 듣지 않을 거고, 저는 오히려 제 신뢰를 소모하게 될 겁니다. 그리고 6개월 뒤에는 아무도 제가 맞았다는 걸 기억하지 않을 거예요. 그저 프로젝트를 막으려 했던 사람 정도로 기억하겠죠.”</p>\n<p>커리어 초반에는 좋은 아이디어가 결국 실력과 타당성으로 인정받는다고 믿고 싶을 겁니다. 충분히 논리적으로 설명하면 사람들이 납득할 거라고도 생각합니다. 하지만 기업은 그렇게 움직이지 않는다는 사실을 받아들이는 데 저도 꽤 오랜 시간이 걸렸습니다.</p>\n<p>그렇다고 해서 관심을 끊으라는 뜻은 아닙니다. 다만 본인의 신뢰와 영향력을 언제 사용할지 전략적으로 판단해야 한다는 의미입니다. 실제로 결과를 바꿀 수 있는 싸움, 침묵하면 우리 팀이 피해를 입는 싸움, 내가 틀렸을 때의 비용은 작지만 프로젝트가 실패했을 때의 비용이 큰 싸움을 잘 골라내야 합니다.</p>\n<p>그렇지 않은 프로젝트라면요? 동료들에게 조용히 하소연하고, 눈에 띄지 않게 대비책을 마련하며, 지켜보면 됩니다. 때로는 배울 점도 있고, 오히려 내가 틀렸고 프로젝트는 의외로 잘 굴러갈 수도 있습니다. 그리고 또 어떤 경우에는, 일이 어떻게 망가질지 정확히 예측했던 것에 대한 씁쓸한 만족감을 느끼게 될 수도 있습니다.</p>\n<p>물론 이런 방식은 모든 걸 직접 고쳐버리는 것만큼 통쾌하지는 않습니다. 하지만 현실적이며, 무엇보다도 나 자신을 보호해 줍니다.</p>",
    "date": "2026-02-19T16:57:32.797Z",
    "url": "https://velog.io/@typo/why-senior-engineers-let-bad-projects-fail"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "진짜로 코딩의 판도는 바뀌었다. 개발자는 어떻게 해야 할까?",
    "partialText": "<blockquote>\n<p>&#39;진짜 한번 해볼까? 한번 코드를 내가 직접 작성하지 않고 어디까지 가능할지를 확인해봐야겠다! 한계를 정확히 알아줘야지&#39;</p>\n</blockquote>\n<p>두달전 재미로 시작하게 된 사이드 프로젝트에서 시작한 에이전트 기반 코딩은 단순하게 &quot;채팅만으로 어디까지 코딩할 수 있을까?&quot;로 시작해서 지금은 에이전트 기반 코딩의 시대가 도래했다는 것을 체감했고 개발의 방식이 완전히 바뀌었습니다.</p>\n<p>이제는 AI에게 일을 시켰을때 검증을 걱정하지 않을 정도로 하는 수준이 오면서 개발하는 방식이 완전히 바뀌었다. 어셈블러에서 C++로 오듯 코드에서 자연어 수준으로 넘어가는 것을 느낍니다. 코드를 직접 수정하지 않고서도 대부분의 개발이 가능한 수준, 아니 그 이상이 되었습니다.</p>\n<p>에이전트가 GitHub 이슈를 스스로 해결하는 벤치마크(SWE-bench)에서 2023년 초기 성공률은 2%였습니다. 2%짜리 주사위를 반반 확률로 한 번이라도 성공하려면 35번을 던져야 해요. 바이브 코딩이 개발자의 빈축을 산 이유죠.</p>\n<p>지금은 어떨까요? 같은 벤치마크의 검증된 문제셋(SWE-bench Verified) 기준으로 79%입니다. 한 번 던지면 79%. 못해도 네 번이면 99%. 거의 성공하고 틀리면 &quot;안되는데? 다시 해봐.&quot; 한번 더 시키면 그만인 수준이 되었습니다.</p>\n<h3 id=\"그렇다면-앞으로-개발자는-뭘-해야-할까요\">그렇다면 앞으로 개발자는 뭘 해야 할까요?</h3>\n<p>하지만 모든 문제가 79%일 수 없습니다. 실제 현업 수준의 복잡한 문제를 모은 별도의 벤치마크(SWE-bench Pro)에서는 최고 모델도 23%라고 합니다. 3번 정도 돌리면 반반의 확률로 성공하는 수준이군요. 그것도 매번 접근 방식을 바꿔가며 돌렸을 때 이야기입니다. 같은 방식으로 반복하면 오히려 더 깊은 수렁에 빠지면서 같은 실패를 반복할 가능성이 높아요. 이따금 우리가 에이전트를 돌리다 겪는 모습입니다. 그래서 가끔 개발자가 방향을 잡아줘야 하죠. 그러면 개발자는 이렇게 조금씩 방향만 잡아주면 되는 사람일까요? </p>\n<blockquote>\n<p>&quot;어? 이게 왜 되지?&quot;</p>\n</blockquote>\n<p>개발자에게 가장 무서운건 버그가 분명 있었고 나는 분명 그 버그를 수정한 적이 없었는데 그냥 되는 경우입니다. 개발자에게는 차라리 깨끗한 실패와 에러가 낫습니다. 코드 수정의 실패는 단순한 실패가 아니기 때문입니다. 분석이나 보고서는 실패하면 버리면 끝이에요. 원본이 그대로니까.</p>\n<p>하지만 코드 수정은? 파일 여러 개를 건드려놓고 일부는 맞고 일부는 틀리고 테스트는 통과하는데 사이드이펙트가 숨어있을 수도 있고 리뷰가 &quot;됐다/안됐다&quot;가 아니라 코드 리뷰가 됩니다. 그것도 내가 짠 코드가 아니라 남이 짠 코드의 리뷰.</p>\n<p>대규모의 유지보수에 많은 인력이 들어가는 이유는 한번 잘못된 설계로 진행하면 그 누적된 문제를 복구하고 고치는 비용이 너무 비싸기 때문이죠. AI도 마찬가지예요. 특히나 잘못된 구조를 정석이라고 믿고 고치다보면 노이즈가 컨텍스트를 방해합니다. AI의 시행착오는 비용입니다.</p>\n<h3 id=\"개발자-ai의-시행착오의-비용을-줄여주는-사람\">&quot;개발자, AI의 시행착오의 비용을 줄여주는 사람&quot;</h3>\n<p>그러면 이 시대에 개발자의 역할은 뭘까요? 세 가지를 한번 생각해봤습니다.</p>\n<p>1 문제를 쪼개는 사람 — 23%짜리 어려운 문제를 79%짜리 여러 개로 분해하는 것. 에이전트가 한 번에 성공할 수 있는 단위로 만들어주는 겁니다.</p>\n<p>2 실패를 빠르게 판별하는 사람 — 에이전트의 결과물이 쓸 만한지, 버려야 하는지, 부분 성공의 함정에 빠진 건 아닌지. 이 판단을 빠르게 내릴수록 시행착오의 비용이 줄어듭니다.</p>\n<p>3 성공률 자체를 높이는 환경을 설계하는 사람 — 좋은 테스트, 명확한 인터페이스, 잘 분리된 모듈. 코드베이스의 아키텍처가 곧 에이전트의 성공률을 결정하는 변수가 됩니다.</p>\n<p>사실 이건 좋은 시니어가 주니어를 키울 때 하는 일과 많이 겹칩니다. 하지만 결정적 차이가 하나 있어요.</p>\n<h3 id=\"에이전트는-욕망이-없고-성장하지-않습니다\">&quot;에이전트는 욕망이 없고, 성장하지 않습니다.&quot;</h3>\n<p>주니어는 냅둬도 알아서 성장합니다. 잘하고 싶다는 욕망이 있으니까요. 물론 좋은 시니어가 옆에 있으면 더 빠르지만, 본인의 의지로 알아서 커갑니다. 에이전트는? 절대적으로 가만히 있어요. 프롬프트를 다듬고 규칙을 정리하면 성공률은 올라가지만, 그건 에이전트가 성장한 게 아니라 환경을 설계한 사람의 역량이 올라간 겁니다.</p>\n<p>그래서 역설적으로, 에이전트 시대에 사람의 가치가 더 선명해집니다. 문제를 쪼개려면 제품이 어디로 가야 하는지 알아야 하고, 실패를 판별하려면 좋은 코드에 대한 감각이 있어야 하고, 환경을 설계하려면 미래에 어떤 변경이 올지 예측해야 합니다. 이건 전부 경험과 의지에서 나오는 것들이고, 자동화가 안 되는 영역입니다.</p>\n<p>저는 지금 제 클론을 만들고 있습니다. 에이전트는 똑똑한데 일은 못하는 사원이에요. 지식은 있는데 일하는 감각이 없는 거죠. 문제를 어떻게 쪼개는지, 실패를 어떻게 판단하는지, 어떤 구조가 좋은 구조인지 — 제가 일하는 방식을 하나하나 알려주고 있는데, 이게 신입사원 키우는 재미와 똑같습니다.</p>\n<p>에이전트가 아직 23%인 지금이 오히려 가르치는 법을 익히기 좋은 때라고 생각합니다. 79%가 되면 다들 그냥 갖다 쓰겠지만, 지금 가르치는 법을 익혀둔 사람은 그때 훨씬 더 잘 쓸 수 있을 테니까요.</p>\n<p>저도 이제 막 눈을 뜬 직후라 아직은 대단하게 정리되지는 못했지만 조만간 정리된 아티클을 만들어서 공유하려고 합니다. 우선 제가 발견한거 하나를 공유드립니다.</p>\n<blockquote>\n<p>&quot;스킬을 등록하는 스킬을 등록해&quot;\n&quot;... 를 스킬로 등록해&quot;</p>\n</blockquote>\n<p>콜롬부스의 달걀. 아는 사람에게는 너무 당연한 데, 이걸 처음 입력하는 순간이 진짜 시작이 됩니다. 이 첫 단추가 여러분들이 에이전트를 쓰는 관점을 바꾸는데 도움이 되기를 바랍니다.</p>",
    "date": "2026-02-19T16:57:32.798Z",
    "url": "https://velog.io/@teo/ai-agent-prolog"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "폭풍의 안과 밖",
    "partialText": "오랜만에 회사에 다니면서 또 다른 대격변의 시대에 들어선 것 같다는 생각이 든다. 지난 1년간 나도 폭풍 안에 있다고 생각했지만, 사실은 그 폭풍을 밖에서 바라보기만 했던 것 같다.\n돌이켜보면 나는 운 좋게도 여러 변화의 순간을 경험해왔다. 딥러닝과 텐서플로가 시작되던 시점, 'GPU라는 걸 쓰면 연산이 빨라서 학습이 가능하다'던 시절에 AI를 공부했다. IT 버블 시기는 경험하지 못했지만, '자바 3명 타세요'라고 하던 암흑기에 개발을 시작해 스타트업이라는 개념으로 투자가 확대되고 급성장하는 시절을 그 안에서 겪었다. 그때 끝일 거라 생각했는데, 변화라는 게 또 존재할 줄 몰랐다. AI와 코딩이 만나는 격변의 시기에, 어쩌면 마지막 격변이라고 하고 싶은 이 시기에 내가 다시 들어서게 되었다.\n1년간 혼자 개발하면서는 AI와 코딩하는 것에 대해 아무런 생각이 없었다. 나 혼자 할 때는 내가 생각하는 깔끔한 구조를 유지하면서 AI와 빠르게 개발할 수 있었다. AI 이전에도 안정성을 확보하면서 구조적으로 괜찮지만 빠르게 제품화하는 걸 나름 잘했는데, AI가 있으니 그냥 최고의 상태가 되었다. 그런데 회사에서 활용하는 것에 대해서는 다른 시각이 필요하다는 걸 느꼈다. 주니어들과 함께 하다 보니 어설픈 상태에서 AI와 빠르게 작업하는 상황에 직면하게 되었기 때문이다.\n잘하는 사람은 AI가 짠 코드를 보지 않아도 AI가 좋은 퀄리티의 코드를 만들어낸다. 반면 그렇지 않은 사람이 AI를 아무리, 토큰을 아무리 써도 한계가 있다. 더 중요한 것은, 잘하지 못하는 사람이 AI를 쓰게 되면 오히려 잘하는 사람이 되기에는 더 멀어지는 것 같다는 점이었다.\n지금 시대에 매니징을 하다 보면 여러 고민이 생겼다. 이전에 내가 매니징 했던 것과 너무 다른 상황이고, 기존의 방법대로 하면 안될것 같다는 생각이 들었다. 기술 공부에 회의를 느끼는 사람도 있고, 회사에서는 AI로 더 빠르게 아웃풋을 내기를 기대하지만 정작 본인은 그 AI와 함께 빠르게 만들어내고 있는 결과물에 만족하지 못해 성장할 수 없다고 느끼기도 한다. 이런 고민을 가진 팀원들을 어떻게 가이드해야 할까? 나는 AI 코딩 시대 전에 개발을 시작해서 여러 성장의 경험을 할 수 있었는데, 지금 성장해야 하는 사람들에게는 어떻게 해야 할까?\n이런 질문들을 마주하면서 계속 생각해보니, 결국 AI를 '어떻게' 쓰느냐의 문제라는 생각이 든다. 아이러니하게도 AI가 코딩을 더 쉽게 만들어줄수록, 개발자에게는 더 높은 수준의 판단력이 요구되는 것 같다. AI는 '어떻게 만들지'는 잘 해결하지만, '왜 이걸 만들어야 하는지', '이게 정말 필요한 건지'는 판단하지 못한다.\n조금 더 미래에는 모르겠지만, 지금 수준에서는 '왜'를 판단하는 능력이 핵심인 것 같다. 좋은 구조가 뭔지 아는 감각, AI가 내놓은 결과물을 보고 이게 맞는지 틀린지 판단하는 눈. 이런 것들은 결국 직접 고민해본 경험에서 나온다. 그래서 AI를 쓰더라도 먼저 스스로 생각해보는 과정이 필요하고, 그 과정을 만들어주는 게 지금 내가 할 수 있는 가이드라고 생각한다.\n5년 뒤 누군가의 예언대로 AGI가 온다면 뭐, 그때는 또 다른 변화에 맞춰야겠지. 그 전까지는 일단 이 방향으로 해보려고 한다.",
    "date": "2026-02-19T16:57:32.798Z",
    "url": "https://w0nder.land/posts/63-%ED%8F%AD%ED%92%8D%EC%9D%98%20%EC%95%88%EA%B3%BC%20%EB%B0%96"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "검색 엔진은 어떻게 대소문자 구분 없이 검색할까?",
    "partialText": "<h2 id=\"%EA%B0%99%EC%9D%80-%EB%AC%B8%EC%9E%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">&quot;&#xAC19;&#xC740; &#xBB38;&#xC790;&quot;&#xB780; &#xBB34;&#xC5C7;&#xC778;&#xAC00;?</h2><p>&#xAC80;&#xC0C9; &#xC5D4;&#xC9C4;&#xC744; &#xB9CC;&#xB4E4;&#xB2E4; &#xBCF4;&#xBA74; &quot;&#xAC19;&#xC740; &#xBB38;&#xC790;&quot;&#xB77C;&#xB294; &#xAC1C;&#xB150;&#xC774; &#xC0DD;&#xAC01;&#xBCF4;&#xB2E4; &#xB2E8;&#xC21C;&#xD558;&#xC9C0; &#xC54A;&#xB2E4;&#xB294; &#xC0AC;&#xC2E4;&#xC744; &#xAE68;&#xB2EB;&#xAC8C; &#xB41C;</p>",
    "date": "2026-02-19T16:57:32.798Z",
    "url": "https://pangyoalto.com/search-engine-text-normalization/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[Swift][Macro] 환경별 Swift 매크로 분기 처리: 환경에 따라 다른 매크로 호출",
    "partialText": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n<html><body>\n<p>Swift 매크로를 사용하다보면 개발 환경에서 생성된 코드가 운영 환경에서는 불필요한 경우가 발생할 수 있습니다. 특정 Protocol을 구현한 Mock 객체를 생성하는 매크로를 사용한다고 가정해봅시다. <a href=\"https://github.com/Matejkob/swift-spyable\">swift-spyable</a>, <a href=\"https://github.com/Kolos65/Mockable\">Mockable</a> 등의 매크로를 이용해서 Mock 객체를 쉽게 생성할 수 있습니다.</p>\n\n<p>이들 매크로의 코드는 전처리기를 이용해서 <code class=\"language-plaintext highlighter-rouge\">#if DEBUG ... #endif</code> 구문을 사용해서 개발 환경에서만 생성되도록 할 수 있습니다.</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">@Mockable</span>\n<span class=\"kd\">protocol</span> <span class=\"kt\">MyService</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">doSomething</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n\n<span class=\"cp\">#if DEBUG</span>\n<span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"kt\">MyServiceMock</span><span class=\"p\">:</span> <span class=\"kt\">MyService</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">doSomethingCallCount</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">doSomethingCallCount</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"cp\">#endif</span>\n</code></pre></div></div>\n\n<p>하지만 이러한 방식은 생성된 매크로 코드를 다른 모듈에서 인식을 할 수 없는 단점이 있습니다.(예: Mock 객체를 다른 모듈에서 사용해야 하는 경우, 인식이 되지 않음. 단순 코드 작성하면 동작하나, 자동완성이 되지 않음.)</p>\n\n<p>개발 환경에서는 생성된 코드를 통해 테스트를 진행하고, 운영 환경에서는 코드가 생성되지 않도록 하는 방법은 없을까요?</p>\n\n<h2 id=\"매크로-인터페이스-분기-처리\">매크로 인터페이스 분기 처리</h2>\n\n<p>매크로 템플릿을 통해 생성하면 기본 매크로인 <code class=\"language-plaintext highlighter-rouge\">stringify</code> 를 만들 수 있습니다.</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">@freestanding</span><span class=\"p\">(</span><span class=\"n\">expression</span><span class=\"p\">)</span>\n<span class=\"kd\">public</span> <span class=\"n\">macro</span> <span class=\"n\">stringify</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">String</span><span class=\"p\">)</span> <span class=\"o\">=</span>\n    <span class=\"cp\">#externalMacro(module: \"MyMacroMacros\", type: \"StringifyMacro\")</span>\n</code></pre></div></div>\n\n<p>외부에서는 매크로를 호출하지만, 실제로는 매크로 모듈의 매크로를 호출하는 방식입니다. 즉, 여기서는 매크로 모듈에 전처리기를 이용해서 분기 처리를 할 수 있습니다.</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">#if DEBUG</span>\n\n<span class=\"kd\">@freestanding</span><span class=\"p\">(</span><span class=\"n\">expression</span><span class=\"p\">)</span>\n<span class=\"kd\">public</span> <span class=\"n\">macro</span> <span class=\"n\">stringify</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">String</span><span class=\"p\">)</span> <span class=\"o\">=</span> \n    <span class=\"err\">#</span><span class=\"nf\">externalMacro</span><span class=\"p\">(</span><span class=\"nv\">module</span><span class=\"p\">:</span> <span class=\"s\">\"MyMacroMacros\"</span><span class=\"p\">,</span> <span class=\"nv\">type</span><span class=\"p\">:</span> <span class=\"s\">\"StringifyMacro\"</span><span class=\"p\">)</span>\n\n<span class=\"cp\">#else</span>\n\n<span class=\"kd\">@freestanding</span><span class=\"p\">(</span><span class=\"n\">expression</span><span class=\"p\">)</span>\n<span class=\"kd\">public</span> <span class=\"n\">macro</span> <span class=\"n\">stringify</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">String</span><span class=\"p\">)</span> <span class=\"o\">=</span> \n    <span class=\"err\">#</span><span class=\"nf\">externalMacro</span><span class=\"p\">(</span><span class=\"nv\">module</span><span class=\"p\">:</span> <span class=\"s\">\"MyMacroMacros\"</span><span class=\"p\">,</span> <span class=\"nv\">type</span><span class=\"p\">:</span> <span class=\"s\">\"DummyMacro\"</span><span class=\"p\">)</span>\n\n<span class=\"cp\">#endif</span>\n</code></pre></div></div>\n\n<p>이와 같이 매크로 인터페이스를 분기 처리하면, 환경에 관계없이 동일하게 매크로를 호출할 수 있습니다.</p>\n\n<h3 id=\"dummymacro의-역할\">DummyMacro의 역할</h3>\n\n<p>여기서 <code class=\"language-plaintext highlighter-rouge\">DummyMacro</code>는 운영 환경에서 매크로가 불필요한 작업을 수행하지 않도록 설계합니다. 예를 들어, <code class=\"language-plaintext highlighter-rouge\">stringify</code> 매크로의 경우 <code class=\"language-plaintext highlighter-rouge\">DummyMacro</code>는 단순히 입력받은 값을 그대로 반환하기만 하도록 구현할 수 있습니다.</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// MyMacroMacros/DummyMacro.swift</span>\n<span class=\"kd\">public</span> <span class=\"kd\">struct</span> <span class=\"kt\">DummyMacro</span><span class=\"p\">:</span> <span class=\"kt\">ExpressionMacro</span> <span class=\"p\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">func</span> <span class=\"nf\">expansion</span><span class=\"p\">(</span>\n        <span class=\"n\">of</span> <span class=\"nv\">node</span><span class=\"p\">:</span> <span class=\"kd\">some</span> <span class=\"kt\">FreestandingMacroExpansionSyntax</span><span class=\"p\">,</span>\n        <span class=\"k\">in</span> <span class=\"nv\">context</span><span class=\"p\">:</span> <span class=\"kd\">some</span> <span class=\"kt\">MacroExpansionContext</span>\n    <span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">ExprSyntax</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 단순히 입력 인자를 그대로 반환하거나 결과값만 전달</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"</span><span class=\"se\">\\(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">argumentList</span><span class=\"o\">.</span><span class=\"n\">first</span><span class=\"o\">!.</span><span class=\"n\">expression</span><span class=\"se\">)</span><span class=\"s\">\"</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이렇게 하면 운영 환경의 바이너리에는 복잡한 Mock 생성 로직이나 디버깅용 코드가 포함되지 않으며, 매크로 확장으로 인한 빌드 시간 오버헤드도 최소화할 수 있습니다.</p>\n\n<h2 id=\"결론-관심사의-분리와-깔끔한-코드\">결론: 관심사의 분리와 깔끔한 코드</h2>\n\n<p>이 방식의 핵심 이점은 다음과 같습니다.</p>\n\n<ol>\n  <li>\n<strong>관심사의 분리</strong>: 매크로를 사용하는 쪽에서 <code class=\"language-plaintext highlighter-rouge\">#if DEBUG</code>를 일일이 관리할 필요가 없습니다. 환경에 따른 동작 결정은 매크로 인터페이스 정의 단계에서 한 번만 처리됩니다.</li>\n  <li>\n<strong>깨끗한 코드</strong>: 호출부 코드가 복잡해지지 않아 가독성이 높아지고 유지보수가 쉬워집니다.</li>\n  <li>\n<strong>DX(개발 경험) 향상</strong>: 모듈 간 참조 시 발생하는 인식 문제나 자동완성 누락 문제를 매크로 수준에서 해결하여 더 쾌적한 개발 환경을 제공합니다.</li>\n</ol>\n\n</body></html>",
    "date": "2026-02-19T16:57:32.798Z",
    "url": "https://minsOne.github.io/conditional-swift-macros-generating-development-code-vs-production-dummy-macros"
  }
]