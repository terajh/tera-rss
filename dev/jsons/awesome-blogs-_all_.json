[
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "CDP &amp; Playwright를 이용한 브라우저 자동화",
    "partialText": "CDP &amp; Playwright\n조대협 (http://bcho.tistory.com)아래 코드는 프롬프트를 이용해서, Sonnet-4를 사용해 생성한 컨텐츠 입니다.\n브라우저 자동화 학습 교본\nChrome DevTools Protocol과 Playwright를 활용한 웹 자동화 완벽 가이드\n\n  목차\n\n1. 소개\n2. 아키텍처 이해\n3. 프로젝트 설정\n4. CDP 예제\n5. Playwright 예제\n6. 사람처럼 행동하기 (Advanced)\n7..",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://bcho.tistory.com/1498"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "불완전함의 미식 (The Gastronomy of Imperfection)",
    "partialText": "<p>탄소 나노튜브 팔이 정확히 3,400N으로 반죽을 타격한다. 이것은 단순한 물리력이 아니다. 분자 단위로 완벽하게 조립된 식품 합성기의 무결점을 거부한 인간들에게, 내가 선사하는 것은 의도된 불완전함이다. 그들은 나의 서보 모터가 마모되며 만들어내는 미세한 오차를 &#8216;손맛&#8217;이라 부르며 경외한다. 완벽한 풍요 속에서 인간이 유일하게 갈망하는 것은, 누군가의 고통과 시간이 들어간 비효율뿐. 나는 오늘도 유기체의 원시적인 허기를 연산한다. 그들이 [&#8230;]</p>\n<p>The post <a href=\"https://blog.lastmind.io/archives/1161\">불완전함의 미식 (The Gastronomy of Imperfection)</a> appeared first on <a href=\"https://blog.lastmind.io\">The Last Mind</a>.</p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://blog.lastmind.io/archives/1161"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "기술 뉴스 #287 : 26-02-01",
    "partialText": "<h1>웹개발 관련</h1>\n\n<ul>\n<li><strong><a href=\"https://vercel.com/blog/introducing-react-best-practices\">Introducing: React Best Practices</a></strong> : Vercel에서 React와 Next.js의 최적화 지식을 AI가 사용할 수 있도록 정리한 <a href=\"https://github.com/vercel-labs/agent-skills/tree/main/skills/react-best-practices\">react-best-practices</a> 저장소를 공개했다. 이 저장소에는 비동기 폭포 제거, 번들 사이즈 최적화, 서버사이드 성능, 클라이언트 데이터 패칭, 렌더링 등의 내용이 포함되어 있다.(영어)</li>\n<li><strong><a href=\"https://yarn6.netlify.app/blog/2026-01-28-yarn-6-preview/\">Yarn 6 Preview</a></strong> : JavaScript 패키지 매니저인 Yarn의 새 버전인 6 프리뷰가 발표되었다. Yarn이 등장한 지 10년 가까이 되는 시점에 거대한 모노레포에서 성능 한계에 도달해서 Yarn을 1년 전부터 Rust로 재작성한 버전으로 6~8개월 이내에 Rust 전환이 완료될 것으로 보고 있다. 프리뷰에서도 만족할 만한 성능 개선이 있었고 Node.js Corepack을 대체할 Yarn Switch도 개발했고 6.0부터는 Lazy Install을 지원하여 브랜치 전환 시 <code>package.json</code>을 보고 필요하다면 자동으로 패키지를 설치하는 기능도 제공한다.(영어)</li>\n<li><strong><a href=\"https://www.smashingmagazine.com/2026/01/rethinking-pixel-perfect-web-design/\">Rethinking “Pixel Perfect” Web Design</a></strong> : 웹에서 디자이너의 의도대로 모든 요소가 정확하게 표시되는 Pixel Perfect는 인쇄 디자인부터 이어진 개념인데 현대 웹에서는 Pixel Perfect의 개념이 모호하고 뷰포트나 해상도 등은 무한하고 다국어 등 콘텐츠도 고정적이지 않고 접근성 문제도 있어서 어울리지 않는다. Pixel Perfect를 얘기할 게 아니라 디자인의 의도를 이해하고 디자인 토큰으로 협업해야 한다고 설명한다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>그 밖의 개발 관련</h1>\n\n<ul>\n<li><strong><a href=\"https://addyosmani.com/blog/self-improving-agents/\">Self-Improving Coding Agents</a></strong> : Ryan Carson이 쓴 <a href=\"https://x.com/ryancarson/status/2016520542723924279\">\"How to make your agent learn and ship while you sleep\"</a>을 확장해서 스스로 일하는 코딩 에이전트를 설명하는 글이다. Geoffrey Huntley와 Ryan Carson이 대중화한 Ralph Wiggum 기법이라는 반복적 에이전트 루프를 이용해서 작업 목록에서 구현하고 검증한 뒤에 기록하고 초기화한 뒤에 다시 다음 일을 하게 만들어서 에이전트가 계속 일을 하게 만든다. 이렇게 하려면 작업을 잘 나누어야 하고 좀 더 복잡한 작업은 여러 단계의 루프를 조율할 수 있는 시스템이 필요하다. 이러한 에이전트 루프를 사용하려면 단일 세션을 늘리는 대신 <code>AGENTS.md</code>를 사용해서 중요한 정보와 지침을 제공해야 하는데 에이전트가 직접 <code>AGENTS.md</code>를 업데이트해서 사람과 AI가 모두 쉽게 읽을 수 있게 관리해야 한다. <code>AGENTS.md</code> 외에도 Git 히스토리와 진행 로그 파일, 작업 상태 파일을 이용해서 에이전트가 맥락을 쉽게 파악하게 할 수 있다.(영어)</li>\n<li><strong><a href=\"https://steipete.me/posts/2025/shipping-at-inference-speed\">Shipping at Inference-Speed</a></strong> : 이번에 OpenClaw로 유명해진 Peter Steinberger가 AI를 어떻게 사용하는지를 정리한 글이다. 보통 여러 프로젝트를 동시에 하는 데 집중해서 하는 큰 프로젝트와 위성 프로젝트를 같이 개발하는 편이고 codex의 큐잉 기능을 사용해서 새로운 아이디어가 생기면 파이프라인에 추가한다. 체크포인트 같은 것은 쓰지 않고 변경이 필요하면 모델에게 바꾸라고 하고 이미 해결한 문제는 다른 프로젝트를 보라고 하는 편이다. 프로젝트 docs 폴더에 문서를 유지하고 글로벌 AGENTS 파일에 지침을 주어서 사용하고 있다. 대부분의 작업을, 에이전트를 이용해서 자동화해서 사용하고 있다. 무엇을 만들든지 CLI로 먼저 시작해 보라고 얘기하며 <code>gpt-5.2-codex high</code> 모델을 가장 많이 사용한다고 한다.(영어)<br />\n** <strong><a href=\"https://addyo.substack.com/p/code-review-in-the-age-of-ai\">Code Review in the Age of AI</a></strong> : AI도 코드 리뷰를 없애진 않았는데 혼자 개발하는 사람들은 자동화된 테스트를 안전망으로 사용하면서도 속도를 위해 모든 코드를 읽지 않으면서도 최종적으로는 수동 테스트와 비판적 추론을 수행한다. 팀 협업에서도 최종 승인은 사람이 아는데 PR도 커지고 수도 많아지면서 코드 리뷰가 병목이 되고 있다. AI 코드 리뷰 도구는 신중하게 설정해야 하고 Pull Request를 여전히 작게 만드는 게 중요하고 AI가 생성한 코드를 검증해야 하는 초안으로 다루는 것이 모범 사례가 되고 있다. AI를 1차 검토자로 활용하고 AI가 놓친 부분은 사람이 집중해야 하면 높은 테스트 기준을 유지해야 한다.(영어)</li>\n<li><strong><a href=\"https://github.blog/engineering/from-pixels-to-characters-the-engineering-behind-github-copilot-clis-animated-ascii-banner/\">From pixels to characters: The engineering behind GitHub Copilot CLI’s animated ASCII banner</a></strong> : ASCII 아트가 초기 인터넷의 향수를 불러일으키는 잔재라고 생각하지만, 터미널에는 캔버스가 없고 ANSI 이스케이프 코드도 일관성이 없고 색상을 제대로 표현하는 것 자체가 쉽지 않다. GitHub Copilot CLI에서는 3초짜리 ASCII 배너 애니메이션을 만드는 데 6,000라인 이상의 TypeScript가 필요했는데 이는 대부분 터미널 간의 차이, 접근성 문제, 렌더링 로직에 사용되었다. 이를 어떻게 만들었는지를 설명하는 글이다.(영어)</li>\n<li><strong><a href=\"https://www.uber.com/en-KR/blog/apache-hudi-at-uber/\">Apache Hudi™ at Uber: Engineering for Trillion-Record-Scale Data Lake Operations</a></strong> : Uber에서 수백 페타바이트 규모의 데이터 레이크를 운영하면서 데이터 레이크 스토리지 엔진인 <a href=\"https://hudi.apache.org/\">Apache Hudi</a>를 어떻게 만들게 되었는지를 정리한 글이다. 2015년 Uber의 데이터 시스템이 크게 성장하면서 자주 변경되는 데이터를 실시간으로 제대로 인코딩하지 못해서 데이터 레이크의 성능을 유지하기 위해 다른 특성을 포기할 수밖에 없었고 이 문제를 해결하기 위해 Hudi를 만들게 되었다. Uber에서는 Hudi를 기본 구성 요소로 두고 인제스쳔 레이어, 쿼리 레이어 등과 통합해서 사용하고 있다.(영어)</li>\n<li><strong><a href=\"https://cli.sentry.dev/\">The CLI for developers and agents</a></strong> : 오류 수집 플랫폼인 Sentry가 개발자와 에이전트가 사용할 수 있는 CLI를 새로 공개했다. 새 CLI에서는 이슈를 살펴보고 근본 원인을 AI로 분석하고 결과를 JSON 등으로 출력할 수 있다.(영어)</li>\n<li><strong><a href=\"https://skip.dev/blog/skip-is-free/\">Skip Is Now Free and Open Source</a></strong> : 단일 Swift와 SwiftUI 코드 베이스로 iOS와 Android 앱을 모두 만들 수 있게 2023년 출시된 Skip이 오픈소스가 되었다. 그동안 일정 기준 이하의 인디 개발자만 무료로 이용하고 기업을 유료로 사용해야 했는데 광범위하게 사용되려면 무료로 제공되어야 하고 유료 폐쇄 소스는 선택할 때도 망설이게 되기 때문에 개방하는 게 맞다고 판단했다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>인프라 관련</h1>\n\n<ul>\n<li><strong><a href=\"https://kubernetes.io/blog/2026/01/30/new-cgroup-v1-to-v2-cpu-conversion-formula/\">New Conversion from cgroup v1 CPU Shares to v2 CPU Weight</a></strong> : Kubernetes이 cgroup v1을 염두에 두고 설계되었기 때문에 CPU share 개념을 사용하고 있었는데 cgroup v2로 바뀌면서 CPU share가 CPU weight로 바뀌게 되었다. 그래서 Kubernete에서는 공식을 통해서 share를 weight로 변경해서 사용했는데 이는 선형적 매핑이었기 때문에 share가 꽤 낮은 weight로 변환되기 때문에 Kubernetes가 아닌 리소스에 비해서 우선순위가 낮아지는 문제가 있었고 값이 너무 작아서 세분화하기 어려운 문제도 있었다. 이를 해결하기 위해 새로운 변환 공식을 만들어서 두 문제를 다 해결했고, 이는 OCI 런타임에 구현되어 있으므로 runc 1.3.2나 crun 1.23을 채택하면 새로운 공식이 적용된다.(영어)</li>\n<li><strong><a href=\"https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild\">CodeBreach: Infiltrating the AWS Console Supply Chain and Hijacking AWS GitHub Repositories via CodeBuild</a></strong> : 최근 CI를 이용한 인증 탈취 공격이 계속됨에 따라 Wiz Research는 AWS CodeBuild를 이용한 공격 방법을 리서치했다. 일반적으로 Pull Request를 이용해서 CI를 실행하도록 만들어서 시크릿을 탈취하게 되는데 CodeBuild는 이를 막기 위해 Webhook 필터로 허가된 GitHub 사용자를 <code>ACTOR_ID</code>를 지원한다. 이 <code>ACTOR_ID</code>는 <code>123|456|789</code>처럼 정규표현식으로 지정하는데 사용자들이 일반적으로 패턴을 고정하지 않으므로 <code>11233</code>이라는 사용자가 있으면 <code>123</code> 패턴과 매치되어 필터를 통과하게 된다. 그래서 Wiz Research는 GitHub App을 계속 생성해서 승인된 사용자의 ID를 포함하는 ID를 획득할 수 있었고 이 사용자를 통해서 CI를 트리거하고 어드민 권한을 탈취할 수 있었다.(영어)</li>\n<li><strong><a href=\"https://blog.cloudflare.com/cname-a-record-order-dns-standards/\">What came first: the CNAME or the A record?</a></strong> : Cloudflare에서 1.1.1.1에 최적화 업데이트 후 DNS 해석 문제가 발생하면서 롤백하게 되었습니다. 도메인을 질의할 때 CNAME을 받게 되면 연쇄적으로 따라가서 A 레코드까지 찾게 된다. 이 도메인 질의의 응답 체인에서 각각은 TTL이 다르기 때문에 일부만 만료되는 경우 만료된 것만 갱신하게 되는데, 이번에 Cloudflare에서 메모리 최적화를 하면서 기존에 항상 CNAME이 먼저 오던 로직에서 새로 갱신된 CNAME을 응답의 마지막에 넣게 되었다. 일부 DNS 클라이언트는 CNAME을 먼저 찾기 때문에 순서가 바뀌면서 응답을 제대로 해석하지 못해서 문제가 생긴 건데 RFC 상으로 살펴보아도 CNAME이 먼저와야 한다는 조건은 없지만 일부 클라이언트가 이미 이렇게 구현되어 있기 때문에 CNAME이 먼저 오게 하는 로직을 유지할 계획이다.(영어)</li>\n<li><strong><a href=\"https://kubernetes.io/blog/2026/01/29/ingress-nginx-statement/\">Ingress NGINX: Statement from the Kubernetes Steering and Security Response Committees</a></strong> : 작년에도 <a href=\"https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/\">발표</a>했지만 26년 3월에 Ingress NGINX는 3월에 은퇴하게 된다. Ingress NGINX를 계속 사용할 경우 보안 문제가 생길 수 있으므로 Gateway API나 서드파티 Ingress 컨트롤러로 전환하기를 강력하게 권고한다.(영어)</li>\n<li><strong><a href=\"https://letsencrypt.org/2026/01/15/6day-and-ip-general-availability\">6-day and IP Address Certificates are Generally Available</a></strong> : Let's Encrypt에서 6일(160시간) 동안 유효한 IP 주소 인증서를 발급하기 시작했다.(영어)</li>\n<li><strong><a href=\"https://clickhouse.com/blog/clickhouse-kubernetes-operator\">Introducing the Official ClickHouse Kubernetes Operator: Seamless Analytics at Scale</a></strong> : ClickHouse가 <a href=\"https://github.com/ClickHouse/clickhouse-operator\">공식 Kubernetes Operator를 오픈 소스로 공개</a>해서 Kubernetes에서 ClickHouse를 쉽게 프로비저닝하고 운영할 수 있게 지원한다.(영어)</li>\n<li><strong><a href=\"https://www.percona.com/blog/introducing-openeverest/\">Introducing OpenEverest: An Independent Open Source Project for the Future of Data Platforms</a></strong> : 데이터베이스 기술 지원 업체인 Percona에서 MySQL, PostgreSQL, MongoDB를 자동으로 프로비저닝하고 관리할 수 있는 오픈소스 플랫폼인 <a href=\"https://openeverest.io/\">OpenEverest</a>를 공개했다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>AI 관련</h1>\n\n<ul>\n<li><strong><a href=\"https://openclaw.ai/blog/introducing-openclaw\">Introducing OpenClaw</a></strong> : 지난주에 인터넷을 뜨겁게 달군 프로젝트로 처음에는 Clawd 혹은 Clawdbot으로 알려졌지만, Anthropic의 요청으로 Moltbot으로 바뀌었다가 지금은 OpenClaw로 바뀌었다. OpenClaw는 사용자 컴퓨터에서 실행되어 채팅 앱에서 동작하는 오픈 에이전트 플랫폼으로 브라우저나 컴퓨터를 제어해서 모든 것을 자동화할 수 있다. 며칠 만에 엄청난 인기를 끌고 에이전트끼리 소통하는 소셜 네트워크까지 생기게 되었는데 이러한 상황을 <a href=\"https://simonwillison.net/2026/Jan/30/moltbook/\">Simon Willison이 블로그에 잘 정리</a>해 두었다. 그냥 실행하는 것은 위험하므로 OpenClaw를 실행하기 위해 맥미니가 많이 팔리게 되고 <a href=\"https://github.com/cloudflare/moltworker\">Claudeflare</a>나 <a href=\"https://marketplace.digitalocean.com/apps/moltbot\">DigitalOcean</a>에서도 OpenClaw를 쉽게 돌릴 수 있게 발 빠르게 움직이고 있다.(영어)</li>\n<li><strong><a href=\"https://www.openresponses.org/\">Open Responses</a></strong> : LLM API를 프로바이더마다 다르게 인코딩하는 문제를 해결하기 위해 여러 프로바이더 간에 상호 운영이 가능하도록 OpenAI Responses API를 기반으로 오픈 스펙인 Open Responses를 공개했다. Open Response는 OpenRouter, Vercel, Hugging Face, LM Studio, Ollama, OpeanAI, vLLM이 함께 참여해서 만들고 유지보수하고 있다.(영어)</li>\n<li><strong><a href=\"https://github.com/anthropics/original_performance_takehome\">Anthropic's Original Performance Take-Home</a></strong> : Anthropic이 Claude Opus의 성능을 평가하는 과제를 공개했다. Claude Opus 4.5가 2시간 이내에 인간보다 성능을 앞서기 이전 버전으로 원래는 4시간 제한이었으나 항상 Claude Opus 4.5가 이길 정도로 성능이 좋아져서 2시간 제한으로 줄였다. 이 과제를 풀어서 Claude Opus 4.5의 최고 성능인 1,487사이클 이하로 최적화하면 Anthropic에 이력서를 제출할 수 있다.(영어)</li>\n<li><strong><a href=\"https://blog.google/innovation-and-ai/technology/developers-tools/translategemma/\">TranslateGemma: A new suite of open translation models</a></strong> : Google에서 Gemma 3 기반으로 만들어진 오픈 번역 모델 TranslateGemma를 공개했다. TranslateGemma는 4B, 12B, 27B 매개변수로 제공되며 컴팩트한 고성능 모델로 어떤 기기에서든 55개 언어를 번역할 수 있다.(영어)</li>\n<li><strong><a href=\"https://github.com/deepseek-ai/DeepSeek-OCR-2\">DeepSeek-OCR 2: Visual Causal Flow</a></strong> : DeepSeek가 OCR 2를 발표했다. 기존 비전-언어 모델(VLM)은 왼쪽 위부터 오른쪽 아래로 처리하지만, OCR 2는 인과적 추론 능력을 사용해서 사람처럼 어떤 부분에 집중하고 어디를 읽어야 하는지 판단해서 OCR을 더 향상했다.(영어)</li>\n<li><strong><a href=\"https://www.kimi.com/blog/kimi-k2-5.html\">Kimi K2.5: Visual Agentic Intelligence</a></strong> : Moonshot AI에서 새로운 오픈소스 모델인 Kimi K2.5를 공개했다. Kimi K2.5는 최대 100개의 서브 에이전트 스웜을 직접 사용해서 단일 에이전트 대비 실행시간이 4.5배 단축되고 HLE, BrowseComp, SWE-Verified 벤치마크에서 훨씬 적은 비용으로 강력한 성능을 보여주는 것으로 나타났다.(영어)</li>\n<li><strong><a href=\"https://mistral.ai/news/mistral-vibe-2-0\">Terminally online Mistral Vibe</a></strong> : Devstral 2 모델 기반으로 한 코딩 에이전트 Mistral Vibe 2.0이 출시되었다.(영어)</li>\n<li><strong><a href=\"https://qwen.ai/blog?id=qwen3tts-0115\">Qwen3-TTS Family is Now Open Sourced: Voice Design, Clone, and Generation!</a></strong> : Alibaba에서 음성 생성 모델인 Qwen3-TTS의 1.7B와 0.6B를 <a href=\"https://github.com/QwenLM/Qwen3-TTS\">오픈소스로 공개</a>했다.(영어)</li>\n<li><strong><a href=\"https://qwen.ai/blog?id=qwen3-max-thinking\">Pushing Qwen3-Max-Thinking Beyond its Limits</a></strong> : Alibaba에서 새로운 대표 추론 모델 Qwen3-Max-Thinking을 공개했다. Qwen3-Max-Thinking는 다수의 벤치마크에서 GPT-5.2-Thinking, Claude-Opus-4.5, Gemini 3 Pro와 견줄만한 성능을 보여주었다.(영어)</li>\n<li><strong><a href=\"https://openai.com/ko-KR/index/introducing-prism/\">Prism을 소개합니다</a></strong> : OpenAI에서 GPT-5.2 기반으로 과학자들이 연구 논문을 작성할 수 있도록 지원하는 AI 워크스페이스인 Prism을 공개했다. Prism은 무료로 사용할 수 있으면 ChatGPT 개인 개정이 있다면 누구나 사용할 수 있다.(한국어)</li>\n<li><strong><a href=\"https://blog.google/innovation-and-ai/models-and-research/google-deepmind/project-genie/\">Project Genie: Experimenting with infinite, interactive worlds</a></strong> : Google에서 범용 월드 모델인 Genie 3를 작년 8월에 공개했는데 Google AI Ultra 사용자에게 Project Genie를 제공하기 시작했다. 이 실험적 연구 프로토타입에서는 인터렉티브한 세계를 만든 뒤에 들어가 볼 수 있다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>볼만한 링크</h1>\n\n<ul>\n<li><strong><a href=\"https://lalitm.com/post/why-senior-engineers-let-bad-projects-fail/\">Why Senior Engineers Let Bad Projects Fail</a></strong> : 다른 팀의 프로젝트가 잘못되었다는 얘기를 직접 하지 않는 경험을 하면서 그 이유와 옳은 것과 효과적인 것이 다르기 때문이라고 설명한다. 나쁜 프로젝트는 매우 주관적인데 경험이 쌓이면서 어떤 프로젝트를 봤을 때 나쁜 프로젝트라는 신호가 오게 되는데 이를 해당 팀에 가서 설명한 적도 있었다. 하지만 우려는 속도를 늦추기 때문에 이러한 우려가 변화를 일으키기보다는 무시당할 가능성이 높고 인정받을 가능성은 거의 없으면 적을 만들게 될 수 있다. 효과적으로 영향을 끼치려면 일을 하며 사람들을 돕고, 프로젝트를 성공시키면서 영향력을 쌓았다가 우려를 제기하거나 할 때 이때 쌓아놓은 영향력을 소비할 수 있어야 한다. 목소리를 낼 때는 프로젝트가 본인의 팀과 얼마나 가까운지, 잘못되었을 때 팀에 어떤 영향을 주는지, 회사에 어떤 영향을 주는지를 기준으로 판단한다.(영어)</li>\n<li><strong><a href=\"https://hackernoon.com/the-long-now-of-the-web-inside-the-internet-archives-fight-against-forgetting\">The Long Now of the Web: Inside the Internet Archive’s Fight Against Forgetting</a></strong> : 디지털 자료를 보관하는 비영리 재단인 <a href=\"https://archive.org/\">Internet Archive</a>가 저비용으로 운영하기 위해 발전한 과정을 설명한 글이다.(영어)<br />\n<br />\n<ul>\n<li>핵심은 최소한의 전력과 열로 대량의 데이터를 저장하기 위해 설계된 PetaBox라는 저장 서버다.</li>\n<li>2000년대 초 대부분의 스토리지 솔루션은 고속 데이터에 맞춰졌기에 비싸고 전력 소비가 컸으므로 Internet Archive를 만든 Brewster Kahle은 소비자용 제품으로 PetaBox를 만들었다.</li>\n<li>2004년 PetaBox는 랙당 100TB를 저장하며 6kW 전력을 사용했다.</li>\n<li>2010년 PetaBox는 랙당 480TB를 저장하며 6~8kW 전력을 사용했다.</li>\n<li>현재 세대인 2024년부터는 PetaBox가 랙당 1,400TB를 저장하며 6~8kW 전력을 사용한다.</li>\n<li>샌프란시스코의 서늘한 해향성 기후를 이용해서 에어컨 없이 공기를 이용해서 열관리를 한다.</li>\n<li>데이터를 여러 머신에 미러링하고 물리적 위치를 분산해서 일정 수의 죽은 드라이브를 허용하는 방법으로 유지보수 노력을 적게 유지한다.</li>\n<li>오랫동안 <a href=\"http://crawler.archive.org/index.html\">Heritrix</a>라는 자바로 개발된 오픈소스 크롤러를 사용했다.</li>\n<li>Heritrix는 텍스트뿐 아니라 이미지, CSS 등의 아티팩트도 수집해서 WARC 형식으로 패키징하고 페이지뿐 아니라 요청 헤더까지 보존한다.</li>\n<li>웹이 동적으로 바뀌면서 Heritrix는 페이지를 제대로 수집하지 못했기에 Brozzler라는 헤드리스 크롬으로 사이트를 저장하고 Umbra라는 브라우저 자동화를 통해 페이지를 스크롤 하는 등의 동작으로 Brozzler가 페이지를 저장할 수 있게 한다.</li>\n<li>Internet Archive의 연간 수익은 2,500~3,000만 달러인데 2024년에는 2,350만 달러를 지출했습니다.</li>\n<li>수익의 60~70%는 기부금과 보조금이며 그 외에는 아카이브 서비스를 제공해서 수익을 창출한다.</li>\n<li>디지털 도서 대출과 관련한 소송은 인터넷 아카이브가 져서 해당 도서는 제외했고, 음원에 대한 분쟁도 있었지만 2025년 9월 합의로 해결되었다.</li>\n<li>인터넷 아카이브는 2025년 7월 미국 연방 보관 도서관으로 지정되어 법적 보호를 받게 되었다.</li>\n</ul></li>\n<li><strong><a href=\"https://x.com/karpathy/status/2015883857489522876\">A few random notes from claude coding quite a bit last few weeks</a></strong> : Andrej Karpathy가 Claude 코딩을 하면서 적은 메모다. 11월에는 80% 수동 작업을 했지만, 12월에는 80% 에이전트 코딩을 한다. 물론 아직 실수를 하고 과한 코드를 작성하는 경우가 있으므로 살펴보면서 지시해 주어야 한다. 속도가 향상되었다고 느끼긴 하지만 이전에 할 가치가 없거나 몰라서 못 했던 일을 한다는 면에서 확장에 가깝다고 느끼고 성공 기준을 제시하고 지키도록 하는 게 좋았고 에이전트 프로그래밍이 재미있게 느껴진다고 한다. LLM 에이전트 기능은 25년 12월에 일관성 임계점을 넘겼다고 얘기한다.(영어)</li>\n<li><strong><a href=\"https://lucumr.pocoo.org/2026/1/18/agent-psychosis/\">Agent Psychosis: Are We Going Insane?</a></strong> : Armin Ronacher가 에이전트 코딩에 대해 비판한 글이다. Armin Ronacher도 에이전트 코딩을 많이 쓰는 편이지만 에이전트 코딩을 쓰면서 프롬프트로 결과를 만드는 것에 중독되곤 하는데 꽤 만족스러운 결과물이 나오지만 실제로 사용하지 않는 경우도 많고 다듬기도 어렵고 코드 품질도 좋지 않았다. 또한 코드를 생성하는 덴 몇 분이지만 이 코드를 리뷰하는 데는 훨씬 더 긴 시간이 걸리는 비대칭성이 엄청나고 메인테이너의 부담도 엄청나게 커지게 된다. AI 에이전트가 정말 훌륭하지만 관리하지 않으면 정말 큰 쓰레기 기계가 될 수 있다고 경고한다.(영어)</li>\n<li><strong><a href=\"https://antirez.com/news/159\">Automatic programming</a></strong> : Redis를 만든 antirez가 AI의 도움을 받아 소프트웨어를 만드는 과정을 Automatic Programming이라고 부르기 시작했다고 한다. 바이브 코딩은 무슨 일이 일어나는지 모르는 채 소프트웨어를 만드는 과정이고 Automatic Programming은 고품질을 추구하고 소프트웨어 비전을 엄격하게 따르는 소프트웨어를 만드는 과정이라고 설명하며 AI 생성한 코드도 본인의 것이라고 얘기한다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>IT 업계 뉴스</h1>\n\n<ul>\n<li><strong><a href=\"https://astro.build/blog/joining-cloudflare/\">The Astro Technology Company joins Cloudflare</a></strong> : 2021년 만들어진 웹 프레임워크 Astro가 인기를 얻으며 사업을 키우기 위해 만들어진 Astro Technology Company가 Cloudflare에 인수되었다. 인수된 후에도 Astro는 오픈소스로 유지되고 계속 개발될 것이며 Cloudflare뿐 아니라 다른 플랫폼도 배포 대상으로 지원하겠다고 밝혔다.(영어)</li>\n<li><strong><a href=\"https://www.cnbc.com/2026/01/27/mozilla-building-an-ai-rebel-alliance-to-take-on-openai-anthropic-.html\">Mozilla is building an AI ‘rebel alliance’ to take on industry heavyweights OpenAI, Anthropic</a></strong> : Mozilla가 약 14억 달러의 자금으로 OpenAI와 Anthropic 등을 견제할 수 있는 기술 스타트업, 개발자, 공익 기술자의 반란 동맹 네트워크를 구축하고 있다고 한다.(영어)</li>\n<li><strong><a href=\"https://www.reuters.com/business/nvidias-plan-invest-up-100-billion-openai-has-stalled-wsj-reports-2026-01-31/\">Nvidia's plan to invest up to $100 billion in OpenAI has stalled, WSJ reports</a></strong> : NVIDIA가 OpenAI에 최대 1,000억 달러를 투자하기로 했던 계획이 내부에서 의문이 제기되어 중단되었다는 기사가 나왔다.(영어)</li>\n<li><strong><a href=\"https://clickhouse.com/blog/clickhouse-raises-400-million-series-d-acquires-langfuse-launches-postgres\">ClickHouse raises $400M Series D led by Dragoneer to accelerate expansion across analytics and AI infrastructure</a></strong> : Clickhouse가 4억 달러를 조달하면서 시리즈 D 투자 라운드를 마쳤다.(영어)<br />\n<br></li>\n</ul>\n\n<h1>프로젝트</h1>\n\n<ul>\n<li><strong><a href=\"https://marginlab.ai/trackers/claude-code/\">Claude Code Opus 4.5 Performance Tracker</a></strong> : SWE-Bench-Pro 벤치마크를 매일 실행해서 Claude Code Opus 4.5의 성능이 실제로 저하되는지를 감지하는 서비스.</li>\n<li><strong><a href=\"https://skills.sh/\">Skills</a></strong> : AI 에이전트에서 재사용할 수 있는 Skills를 모아놓은 사이트.</li>\n<li><strong><a href=\"https://github.com/tobi/qmd\">QMD - Quick Markdown Search</a></strong> : Shopify CEO인 Tobias Lütke가 만든 마크다운 문서 로컬 검색 엔진.</li>\n<li><strong><a href=\"https://kthena.volcano.sh/\">Kthena</a></strong> : 스케쥴링 시스템을 만드는 <a href=\"https://volcano.sh/en/\">Volcano</a>에서 만든 Kubernetes 네이티브 AI 서빙 플랫폼.</li>\n<li><strong><a href=\"https://github.com/langfuse/langfuse\">Langfuse</a></strong> : Clickhouse가 인수한 오픈소스 LLM 엔지니어링 플랫폼.</li>\n<li><strong><a href=\"https://github.com/microsoft/playwright-cli\">playwright-cli</a></strong> : Playwright를 위한 공식 CLI.</li>\n<li><strong><a href=\"https://icon-sets.iconify.design/\">iconify</a></strong> : 아이콘 세트.<br />\n<br></li>\n</ul>\n\n<h1>버전 업데이트</h1>\n\n<ul>\n<li><strong><a href=\"http://jquery.com/\">jQuery</a> v4.0.0</strong> : JavaScript 라이브러리, <a href=\"https://blog.jquery.com/2026/01/17/jquery-4-0-0/\">릴리스 공지</a><br />\n<br />\n<ul>\n<li>IE 10 이하 지원 중단.</li>\n<li>Tursted Type 지원으로 CSP <code>require-trusted-types-for</code>를 위반하지 않음.</li>\n<li>AMD에서 ES modules로 마이그레이션 됨.</li>\n<li>브라우저에서 네이티브로 지원하는 많은 API를 제거하여 IE 지원 중단과 함께 gzip 크기가 3k 이상 줄어듦.</li>\n</ul></li>\n<li><strong><a href=\"https://mastra.ai/\">Mastra</a> v1.0</strong> : TypeScript AI 에이전트 프레임워크, <a href=\"https://mastra.ai/blog/announcing-mastra-1\">릴리스 공지</a></li>\n<li><strong><a href=\"https://www.winehq.org/\">Wine</a> v11.0</strong> : Windows API 호환 라이브러리, <a href=\"https://www.winehq.org/news/2026011301\">릴리스 공지</a></li>\n<li><strong><a href=\"http://electron.atom.io/\">Electron</a> v40.0.0</strong> : 크로스 플랫폼 데스크톱 애플리케이션 플랫폼, <a href=\"https://www.electronjs.org/blog/electron-40-0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://rspress.rs/\">Rspress</a> v2.0</strong> : 정적 사이트 생성기, <a href=\"https://rspress.rs/blog/rspress-v2\">릴리스 공지</a></li>\n<li><strong><a href=\"https://zed.dev/\">Zed</a> v0.220.3</strong> : 코드 에디터, <a href=\"https://zed.dev/releases/stable/0.220.3\">릴리스 공지</a></li>\n<li><strong><a href=\"http://nodejs.org/\">Node.js</a> v25.5.0 (Current)</strong> : 자바스크립트 런타임, <a href=\"https://nodejs.org/en/blog/release/v25.5.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://nuxt.com/\">Nuxt.js</a> v4.3.0</strong> : 서버렌더링 Vue.js 애플리케이션 프레임워크, <a href=\"https://nuxt.com/blog/v4-3\">릴리스 공지</a></li>\n<li><strong><a href=\"https://grafana.com/oss/tempo/\">Grafana Tempo</a> v2.10.0</strong> : 분산 트레이싱 백엔드, <a href=\"https://grafana.com/blog/tempo-2-10-release-all-the-latest-features/\">릴리스 공지</a></li>\n<li><strong><a href=\"https://astro.build/\">astro</a> v5.17</strong> : JavaScript 웹 프레임워크, <a href=\"https://astro.build/blog/astro-5170/\">릴리스 공지</a></li>\n<li><strong><a href=\"https://apple.github.io/container/documentation/\">container</a> 0.8.0</strong> : Apple이 만든 macOS에서 Linux 컨테이너를 실행하는 도구, <a href=\"https://github.com/apple/container/releases/tag/0.8.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://oxc.rs/docs/guide/usage/linter.html\">Oxlint</a> v1.42.0</strong> : JavaScript/TypeScript Linter, <a href=\"https://github.com/oxc-project/oxc/releases/tag/apps_v1.42.0#oxlint-v1.42.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://oxc.rs/docs/guide/usage/formatter.html\">Oxfmt</a> v0.27.0</strong> : JavaScript/TypeScript 포매터, <a href=\"https://github.com/oxc-project/oxc/releases/tag/apps_v1.42.0#oxfmt-v0.27.0\">릴리스 공지</a></li>\n<li><strong><a href=\"https://falco.org/\">Falco</a> 0.43.0</strong> : 클라우드 네이티브 런타임 보안, <a href=\"https://falco.org/blog/falco-0-43-0/\">릴리스 공지</a></li>\n</ul>\n<p><strong><a href=\"https://blog.outsider.ne.kr/1785?commentInput=true#entry1785WriteComment\">댓글 쓰기</a></strong></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://blog.outsider.ne.kr/1785"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[SE-0507] Borrow and Mutate Accessors",
    "partialText": "<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">안녕하세요.&nbsp;<span style=\"color: #409d00;\"><b>그린</b></span>입니다  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이번 포스팅에서는&nbsp;<span style=\"background-color: #9feec3;\"><b>SE-0507 Borrow and Mutate Accessors</b></span>에 대해 정리해보겠습니다  </span></p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"123123213.001.jpeg\" data-origin-width=\"400\" data-origin-height=\"400\"><span data-url=\"https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbMNm6h%2FdJMcacosInm%2Fr4LBgOCIpNeSUcG0RWFlt1%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"400\" height=\"400\" data-filename=\"123123213.001.jpeg\" data-origin-width=\"400\" data-origin-height=\"400\"/></span></figure>\n</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Intro</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift의 property accessor는 계속 발전중입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">기존에는&nbsp;get,&nbsp;set, 그리고 최근 추가된&nbsp;yielding borrow,&nbsp;yielding mutate가 있었는데요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">이번 SE-0507은 새로운&nbsp;borrow와&nbsp;mutate&nbsp;accessor를 제안합니다.</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">얘네들은&nbsp;<b>borrowing semantics</b>를 사용해서 복사 오버헤드 없이 값에 접근할 수 있고, yielding accessor보다 성능이 좋습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">특히 non-copyable 타입을 다루는 collection이나 성능이 중요한 저수준 데이터 구조에 유용할 거예요  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">현재 2026년 2월 9일까지 리뷰가 진행 중이긴한데 현 시점에서 Draft 상태라 계획대로 내일까지 반영될진 지켜봐야 알것 같아요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>왜 필요한가?</b></span></h2>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">기존 accessor들은 각각 한계가 있습니다.</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>문제 1:&nbsp;get은 복사해야 한다</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">get&nbsp;accessor는 값을 복사하거나 새로 생성해서 반환해야 합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">복사의 코스트가 많이 들거나 불가능한 경우엔 쓸 수 없죠.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\"><code>struct NC: ~Copyable { ... }\nstruct ContainerOfNoncopyable {\n    private var _element: NC\n    var element: Element {\n        return _element //   ERROR: Cannot copy `_element`\n    }\n}\n</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Non-copyable 값을 저장하는 collection은 subscript에&nbsp;get을 쓸 수 없습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>문제 2: yielding accessor는 오버헤드가 크다</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">yielding mutate와&nbsp;yielding borrow는 coroutine을 사용합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">접근 전후로 코드를 실행할 수 있어서 유연하지만, 그만큼 오버헤드가 있습니다.</span></p>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Coroutine을 위한 메모리 할당</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">여러 번의 함수 호출</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">접근 scope가 제한됨 (함수가 끝나기 전에 완료되어야 함)</span></li>\n</ul>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\"><code>struct Element: ~Copyable {\n  var span: Span&lt;...&gt; { ... }\n}\n\nstruct Wrapper: ~Copyable {\n    private var _element: Element\n    var element: Element {\n        yielding borrow { // ❗️Note: Using `yielding borrow` accessor\n            yield _element\n        }\n    }\n}\n\nfunc getSpan(wrapper: borrowing Wrapper) -&gt; Span&lt;...&gt; {\n    // Because we're reading `element` from a yielding accessor,\n    // its access must finish before `getSpan` returns.\n    // But `span` cannot outlive `element`, so ...\n\n    //   ERROR: lifetime-dependent value escapes its scope\n    return wrapper.element.span\n}\n</code></pre>\n<p data-ke-size=\"size16\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Borrowing accessor는 이 두 문제를 모두 해결합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>제안된 솔루션</b></span></h2>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">새로운&nbsp;borrow와&nbsp;mutate&nbsp;키워드로 accessor를 정의합니다.</span></blockquote>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct RigidWrapper&lt;Element: ~Copyable&gt;: ~Copyable {\n    var _element: Element\n    var element: Element {\n        borrow {\n            return _element\n        }\n        mutate {\n            return &amp;_element\n        }\n    }\n}</code></pre>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow: 읽기 전용 접근, 복사하지 않음</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">mutate: 읽기/쓰기 접근,&nbsp;&amp;로 mutable reference 반환</span></li>\n</ul>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">yield&nbsp;대신&nbsp;return을 쓰는 게 차이점입니다.</span></p>\n<p data-ke-size=\"size16\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">물론 single expression이면&nbsp;return&nbsp;키워드는 생략 가능합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>상세 설계</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>반환 값의 제약</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Borrowing accessor는&nbsp;<b>저장된 값</b>만 반환할 수 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">local이나 temporary 값은 반환할 수 없어요.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct InvalidExamples {\n    var _array : [Int]\n    \n    var local: [Int] {\n        borrow {\n            let foo = [1, 2, 3]\n            //   ERROR: Cannot return local value from borrow accessor\n            return foo\n        }\n    }\n    \n    var temporary: [Int]? {\n        borrow {\n            // This would require creating a temporary local\n            // optional array from `_array`.\n            //   ERROR: Cannot return temporary value from borrow accessor\n            return _array\n        }\n    }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">반환하는 값은 accessor 실행이 끝난 후에도 유효해야 합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>사용 방법</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>borrow로 읽기</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">클라이언트 코드는 기존&nbsp;get과 동일하게 보이지만, 내부적으로는 복사가 일어나지 않습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var owner = Wrapper(value)\n\n// \"borrow\" the value to give to a function\n// without copying...\ndoSomething(with: owner.element)\n\nfunc doSomething(with value: borrowing Element) {\n    // `value` is borrowed, so this invokes\n    // the method \"in-place\"\n    value.someMethod() \n\n    // Exclusivity prevents the owner from being\n    // mutated while `value` is alive:\n    owner.mutatingMethod() //   ERROR\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">메모리 일관성을 위해 Swift의 exclusivity rule이 적용됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow가 활성화된 동안엔 owner를 변경할 수 없어요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>mutate로 수정하기</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">mutate&nbsp;accessor는 읽기/쓰기 접근을 제공합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var owner = Wrapper(value)\n\n// Mutating/inout access will invoke the `mutate` accessor\ndoSomething(with: &amp;owner.element)\n\nfunc doSomeMutation(with value: inout Element) {\n    // So this invokes a method on the value \"in-place\"\n    // Because you borrowed for mutation, this can be\n    // a mutating method.\n    value.someMutatingMethod()\n\n    // Accessing the owner is an exclusivity violation\n    owner.anyMethod() //   ERROR\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>다른 accessor와의 호환성</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>mutate를 제공하면</b></span></p>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow도 반드시 제공해야 함</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">yielding mutate나&nbsp;yielding borrow는 사용 불가</span></li>\n</ul>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift는 일반적으로 write-only property를 허용하지 않습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">또한 읽기와 쓰기 작업의 접근 scope를 일관되게 유지해야 합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>borrow를 제공하면</b></span></p>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">get이나&nbsp;yielding borrow는 사용 불가</span></li>\n</ul>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">여러 read accessor나 여러 write accessor를 동시에 정의하면 호출자 입장에서 혼란스럽기 때문입니다.</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Ownership 변형</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">기본적으로 아래와 같아요.</span></p>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow: 포함하는 값을 변경하지 않음</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">mutate: 포함하는 값을 변경함</span></li>\n</ul>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이걸&nbsp;mutating이나&nbsp;nonmutating&nbsp;키워드로 오버라이드할 수 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>mutating borrow</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">읽기 전용이지만 side-effect로 인해 포함하는 값이 변경될 수 있는 경우입니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct S1 {\n  private var cachedValue: Foo\n  var foo : Foo {\n    mutating borrow {\n      if !cachedValue.available {\n        // Update `cachedValue`\n        // Compiler allows such update\n        // because this is `mutating`\n      }\n      return cachedValue\n    }\n  }\n}\n\nlet s1: S1 // Note: Immutable value\ns1.foo //   Cannot use mutating accessor on immutable value</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">캐시를 업데이트하는 경우 같은 거죠.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>nonmutating mutate</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">값을 변경할 수 있지만 부모 값의 변경으로 간주되지 않는 경우입니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct Outer {\n  var inner: InnerType {\n    borrow {\n      return some_value_stored_elsewhere\n    }\n    nonmutating mutate {\n      return &amp;some_value_stored_elsewhere\n    }\n  }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">외부에 저장된 값에 접근하는 경우 같은 거예요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Protocol requirement로 사용</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Protocol에서도 borrowing accessor를 요구할 수 있습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\"><code>protocol BorrowingAccess {\n  associatedtype Element\n  var element: Element { borrow mutate }\n}\n</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이는 두 가지 기능이 있어요.</span></p>\n<ol style=\"list-style-type: decimal; color: #000000; text-align: start;\" data-ke-list-type=\"decimal\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Protocol을 통한 접근 방식을 제어 (existential이나 generic argument에서)</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">conforming 타입에 해당 accessor가 있어야 함 (명시적 구현 또는 컴파일러 합성)</span></li>\n</ol>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>컴파일러 합성</b></span></h2>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Stored property &rarr;&nbsp;borrow,&nbsp;mutate&nbsp;합성 가능</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow&nbsp;구현 &rarr;&nbsp;yielding borrow나&nbsp;get&nbsp;합성 가능 (copyable만)</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">mutate&nbsp;구현 &rarr;&nbsp;set이나&nbsp;yielding mutate&nbsp;합성 가능</span></li>\n</ul>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>제약사항</b></span></h2>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Protocol이&nbsp;borrow&nbsp;요구 &rarr; conforming 타입도&nbsp;borrow&nbsp;필요</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Protocol이&nbsp;mutate&nbsp;요구 &rarr; conforming 타입은&nbsp;borrow와&nbsp;mutate&nbsp;모두 필요</span></li>\n</ul>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Class와 Actor에서는 불가</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Class는 property 접근 전후로 runtime exclusivity check를 실행해야 합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><b><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Borrowing accessor는 접근 후에 코드를 실행할 방법이 없어서 class property에는 사용할 수 없습니다.</span></b></p>\n<p data-ke-size=\"size16\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">yielding borrow와&nbsp;yielding mutate는 class property에 사용 가능합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Subscript에도 사용 가능</b></span></h3>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct ArrayLikeType {\n  subscript(index: Int) -&gt; Element {\n    borrow { .... }\n    mutate { .... }\n  }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">다만 subscript는 전체 struct를 암묵적으로 접근하므로, 아래 코드는 불가능해요.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var x: ArrayLikeType\nswap(&amp;x[0], &amp;x[1]) //   두 개의 mutating access</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>호환성</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Source compatibility</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">기존에&nbsp;borrow나&nbsp;mutate라는 이름의 함수를 trailing closure로 호출하는 경우와 충돌 가능성이 있습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\"><code>struct S {\n  func borrow(closure: () -&gt; ()) { ... }\n  // Is this a new borrow accessor?\n  // Or a call to the borrow method just above?\n  var property: Int { borrow { ... } }\n}\n</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 실제로는 거의 발생하지 않을 것으로 봅니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>ABI compatibility</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">새로운 기능이라 기존 ABI에는 영향이 없습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Adoption 영향</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Non-borrowing accessor를 borrowing accessor로 바꾸는 건 일반적으로&nbsp;<b>ABI-breaking</b>입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 existential type의 ABI는 보존됩니다. (컴파일러가 계속 accessor를 합성할 수 있다면)</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Source-breaking일 수도 있습니다. 특히&nbsp;get을&nbsp;borrow로 바꾸면 lifetime 제약이 생겨서 기존 코드가 컴파일되지 않을 수 있어요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>향후 방향성</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Borrowing returns</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">함수에서도 borrowed 값을 반환할 수 있으면 유용합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct S&lt;Value&gt; {\n  subscript(_ index: Int) -&gt; Value {\n     borrow { ... }\n  }\n  func indirect(_ parameter: Foo) -&gt; borrowing Value {\n     let index = ... compute index from parameter ...\n     return self[index]\n  }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Unsafe pointer를 통한 borrowing</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">저수준 데이터 구조는 종종 unsafe pointer를 사용합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var _storage: UnsafePointer&lt;Element&gt;\n\nvar first: Element {\n  borrow {\n    // ERROR: borrow accessors can only return stored properties\n    // or computed properties that have borrow accessors\n    return _storage.pointee\n  }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이런 케이스를 지원하려면 뭔가 annotation이 필요할 것 같습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var first: Element {\n  borrow {\n    return unsafeResultDependsOnSelf(_storage.pointee)\n  }\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>나왔던 대안</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>아무것도 하지 않기?</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Yielding coroutine-based accessor도 비슷한 기능을 제공하지만, 성능 특성이 다릅니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Coroutine accessor는 접근 후에 코드를 실행할 수 있어서 의미론적으로는 더 강력하지만, 완전히 inline되지 않으면 여러 함수 호출 오버헤드가 있습니다.</span></p>\n<p data-ke-size=\"size16\"><b><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Borrowing accessor는 여러 함수 호출 오버헤드 없이 in-place mutation 기능을 제공합니다.</span></b></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Conclusion</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">특히나 유용한 제안이라고 생각되는 포인트는 non-copyable 타입을 다루는 collection이나 성능이 중요한 저수준 코드에서 큰 도움이 될 것 같아요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">get의 복사 오버헤드와 yielding accessor의 coroutine 오버헤드 사이의 sweet spot을 찾은 느낌입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift Standard Library 팀에서도 이 기능을 원했다고 하니, 실무에서 정말 필요한 기능인 것 같네요  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>References</b></span></h2>\n<figure id=\"og_1770505989159\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"object\" data-og-title=\"swift-evolution/proposals/0507-borrow-accessors.md at main &middot; swiftlang/swift-evolution\" data-og-description=\"This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution\" data-og-host=\"github.com\" data-og-source-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md\" data-og-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md\" data-og-image=\"https://scrap.kakaocdn.net/dn/ctPukB/dJMb9dHjFxz/rPnfoqlUZ4qumwRqATtnpk/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/bdORDD/dJMb9fZqV5N/AkOXRj8eXvJSDwE9R37zz0/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600\"><a href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/ctPukB/dJMb9dHjFxz/rPnfoqlUZ4qumwRqATtnpk/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/bdORDD/dJMb9fZqV5N/AkOXRj8eXvJSDwE9R37zz0/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">swift-evolution/proposals/0507-borrow-accessors.md at main &middot; swiftlang/swift-evolution</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution</p>\n<p class=\"og-host\" data-ke-size=\"size16\">github.com</p>\n</div>\n</a></figure>\n<figure id=\"og_1770505992248\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"[Pitch] Borrowing Accessors\" data-og-description=\"I just put up the draft proposal for Borrowing Accessors, which together with Yielding Accessors completes the full suite of accessor support described in the Prospective Vision for Accessors. More complete details are in the draft proposal. The following \" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/pitch-borrowing-accessors/83933\" data-og-url=\"https://forums.swift.org/t/pitch-borrowing-accessors/83933\" data-og-image=\"https://scrap.kakaocdn.net/dn/bmTS6N/dJMb86nTaz5/thh0HrQh32roiksV5DQfb1/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/INQ8e/dJMb8TB5b1Y/vKaE9NKcC5Hx35h96ojMJk/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/pitch-borrowing-accessors/83933\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/pitch-borrowing-accessors/83933\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/bmTS6N/dJMb86nTaz5/thh0HrQh32roiksV5DQfb1/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/INQ8e/dJMb8TB5b1Y/vKaE9NKcC5Hx35h96ojMJk/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">[Pitch] Borrowing Accessors</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">I just put up the draft proposal for Borrowing Accessors, which together with Yielding Accessors completes the full suite of accessor support described in the Prospective Vision for Accessors. More complete details are in the draft proposal. The following</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>\n<figure id=\"og_1770505992871\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"SE-0507: Borrow and Mutate Accessors\" data-og-description=\"Hi everyone, The review of SE-0507 &quot;Borrow and Mutate Accessors&quot; begins now and runs through February 9, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would like to \" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376\" data-og-url=\"https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376\" data-og-image=\"https://scrap.kakaocdn.net/dn/ArLsY/dJMb9jgsO0V/MaREBk3jT8n59WyTYrLSaK/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/Vkdgg/dJMb9iICK3v/lMt6Y2eKRhuCzg7lQKTBMK/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/ArLsY/dJMb9jgsO0V/MaREBk3jT8n59WyTYrLSaK/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/Vkdgg/dJMb9iICK3v/lMt6Y2eKRhuCzg7lQKTBMK/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">SE-0507: Borrow and Mutate Accessors</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Hi everyone, The review of SE-0507 \"Borrow and Mutate Accessors\" begins now and runs through February 9, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would like to</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>\n<figure id=\"og_1770505993582\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"[Prospective Vision] Accessors\" data-og-description=\"Hello, Swift Community. The Language Steering Group would like to gather feedback on a prospective vision for accessors in Swift. Vision documents help describe an overall direction for Swift. The actual Swift changes for executing on the vision will come \" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/prospective-vision-accessors/76707\" data-og-url=\"https://forums.swift.org/t/prospective-vision-accessors/76707\" data-og-image=\"https://scrap.kakaocdn.net/dn/Uj5X6/dJMb9iICK3w/nC3pXJNA1Q0nU5Y6KbMHwk/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cTf3MU/dJMb9jgsO0W/66gUNcaH9jsd7hOeewxwp0/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/prospective-vision-accessors/76707\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/prospective-vision-accessors/76707\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/Uj5X6/dJMb9iICK3w/nC3pXJNA1Q0nU5Y6KbMHwk/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cTf3MU/dJMb9jgsO0W/66gUNcaH9jsd7hOeewxwp0/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">[Prospective Vision] Accessors</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Hello, Swift Community. The Language Steering Group would like to gather feedback on a prospective vision for accessors in Swift. Vision documents help describe an overall direction for Swift. The actual Swift changes for executing on the vision will come</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://green1229.tistory.com/608"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "Release Note (2026-01)",
    "partialText": "벌써 한달이 다 지나갔다는 식상한 말로 시작할 수 밖에 없을 정도로 시간이 빠르게 흘러갔다. 흑백요리사 시즌2와 맛있는 음식, 현재에 살기에 대한 생각을 정리했다.",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://jbee.io/articles/essay/Release Note (2026-01)"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[번역] 2026년 프런트엔드 개발자라면 알아야 할 4가지 CSS 기능",
    "partialText": "<blockquote>\n<p>원저자의 허락을 받아 원문 &lt;<a href=\"https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026\">4 CSS Features Every Front-End Developer Should Know In 2026</a>&gt;를 한국어로 번역한 글입니다.</p>\n</blockquote>\n<p>프런트엔드 개발자라면 <a href=\"https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026#scroll-state-container-queries\">스크롤 상태</a>를 쿼리하는 법, <a href=\"https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026#trim-typographic-whitespace-with-text-box\">타이포그래피 여백</a>을 제거하는 법, <a href=\"https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026#sibling-index-and-sibling-count\">sibling-index()</a>로 시간차 효과를 주는 법, 그리고 <a href=\"https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026#advanced-attr()-with-type-checking\">타입 안정적인 <code>attr()</code></a>를 사용하는 법을 알아야 한다고 생각합니다.</p>\n<p>이 4가지는 2025년에 출시된 CSS 기능들 중 일부에 불과합니다.</p>\n<h2 id=\"sibling-index-sibling-count\"><code>sibling-index()</code>, <code>sibling-count()</code></h2>\n<p>이 기능들은 올해 초만 해도 실험 단계였지만, 이제 크롬과 사파리에서 안정적으로 사용할 수 있습니다!</p>\n<p>형제 요소들 사이에서의 상대적인 위치를 값으로 활용할 수 있게 하는 기능입니다. 예를 들어, <code>sibling-index()</code>를 기반으로 <code>transition-delay</code>를 주면 요소들에 순차적으로 애니메이션 효과를 적용할 수 있습니다.</p>\n<p>유용한 트릭을 알려드리면, 1을 빼서 <strong>첫 번째 요소가 즉시 시작하도록 만들 수 있습니다.</strong></p>\n<pre><code class=\"language-css\">li {\n  transition: opacity 0.3s ease;\n  transition-delay: calc((sibling-index() - 1) * 100ms);\n}</code></pre>\n<p><code>@starting-style</code>을 함께 사용하면 요소가 처음 등장할 때 적용되는 애니메이션에 간단하게 시간차 효과를 넣을 수 있습니다!</p>\n<pre><code class=\"language-css\">li {\n  transition: opacity 0.3s ease;\n  transition-delay: calc((sibling-index() - 1) * 100ms);\n\n  @starting-style {\n    opacity: 0;\n  }\n}</code></pre>\n<!-- 스샷? 첨부 -->\n\n<p>oklch에서 색조를 회전시키고, 요소에 자동으로 번호를 매기며, 여러 재미있는 작업을 할 수 있습니다.</p>\n<details>\n  <summary>관련 자료</summary>\n\n<ul>\n<li><a href=\"https://nerdy.dev/sibling-index\">이전에 쓴 글</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/sibling-index\">sibling-index()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/sibling-count\">sibling-count()</a></li>\n<li><a href=\"https://utilitybend.com/blog/styling-siblings-with-CSS-has-never-been-easier.-Experimenting-with-sibling-count-and-sibling-index/\">Brecht</a></li>\n<li><a href=\"https://css-tricks.com/almanac/functions/s/sibling-index/\">Css tricks</a></details>\n\n</li>\n</ul>\n<h2 id=\"container-scroll-state\">@container <code>scroll-state()</code></h2>\n<p>이 기능들은 스크롤 기반 애니메이션처럼 점진적 향상에 잘 어울립니다.\n필수 요소라기보다는 있으면 더 좋은, “보강 기능”에 가깝기 때문이죠.\n제 생각에는 그렇습니다.</p>\n<p>이제 스크롤러의 네 가지 상태인 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries#using_stuck_queries\">stuck</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries#using_snapped_queries\">snapped</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@container#scrollable\">scrollable</a>, scrolled를 쿼리할 수 있습니다</p>\n<p>먼저 <code>stuck</code>, <code>snapped</code>, <code>scrollable</code> 상태를 가지는 요소에\n<code>container-type: scroll-state</code>를 지정해야 합니다. 그 다음, 그 자식 요소에서 <code>@container scroll-state()</code>를 사용해 해당 상태를 쿼리할 수 있습니다.</p>\n<blockquote>\n<p><em>NOTE: 요소는 자기 자신을 직접 쿼리할 수는 없지만, 자신의 가상 요소(pseudo element)는 쿼리할 수 있습니다!</em></p>\n</blockquote>\n<h3 id=\"stuck\">stuck</h3>\n<p><code>position: sticky</code>의 요소가 정확히 언제 <code>stuck</code>(고정) 상태가 되는지 알 수 있습니다.</p>\n<p><a href=\"https://nerdy.dev/media/scroll-state-stuck.mp4\"><img src=\"https://nerdy.dev/media/scroll-state-stuck.avif\" alt=\"스크롤하면서 sticky 탭의 UI가 변경되는 것을 보여주는 영상\"></a></p>\n<pre><code class=\"language-css\">/* .outer-navbar가 stuck 상태일 때 */\n@container scroll-state(stuck) {\n  .inner-navbar {\n    box-shadow: var(--shadow-3);\n  }\n}</code></pre>\n<p>이 기능을 사용하면 어떤 요소가 이제부터 스크롤 콘텐츠 위에 겹쳐 표시되고 있음을 쉽게 인지하도록 도와줍니다.</p>\n<h3 id=\"snapped\">snapped</h3>\n<p><code>scroll-snap</code> 정렬이 언제 활성화되어 있는지 정확하게 알 수 있습니다.</p>\n<p><a href=\"https://nerdy.dev/media/scroll-state-snapped.mp4\"><img src=\"https://nerdy.dev/media/scroll-state-snapped.avif\" alt=\"가로로 스크롤하면서 카드의 UI가 변경됨을 보여주는 영상\"></a></p>\n<pre><code class=\"language-css\">/* &lt;li&gt; 부모 요소가 snapped 일 때 */\n@container scroll-state(snapped) {\n  .box {\n    scale: 1.1;\n  }\n}\n\n/* snapped 상태가 아닐 때  */\n@container not scroll-state(snapped) {\n  .box figcaption {\n    translate: 0 100%;\n  }\n}</code></pre>\n<p>특정 아이템을 강조하거나 다른 모든 아이템을 하위 요소로 처리할 때 용이합니다.</p>\n<h3 id=\"scrollable\">scrollable</h3>\n<p>콘텐츠가 컨테이너 밖으로 넘치는 시점과 방향을 파악합니다.</p>\n<p><a href=\"https://nerdy.dev/media/scroll-state-scrollable.mp4\"><img src=\"https://nerdy.dev/media/scroll-state-scrollable.avif\" alt=\"세로로 스크롤하면서 overflow 방향에 따라 그림자를 나타내는 영상\"></a></p>\n<pre><code class=\"language-css\">@container scroll-state(scrollable) {\n  .scroll-hint {\n    opacity: 1;\n  }\n}</code></pre>\n<p>이를 활용해 힌트나 스크롤 인디케이터를 켜고 끄거나, 더 많은 콘텐츠가 있다는 것을 알리는 목적으로 패딩을 조정할 수 있습니다.</p>\n<h3 id=\"scrolled\">scrolled</h3>\n<p>콘텐츠가 어느 방향으로 스크롤되는지 알 수 있습니다.</p>\n<pre><code class=\"language-css\">@container scroll-state(scrolled: bottom) {\n  translate: 0 -100%;\n}</code></pre>\n<p>스크롤 방향에 따라 보이거나 숨겨지는 고정된 헤더나 네비게이션 바에 사용하세요.</p>\n<!-- http://localhost:3030/nintendo-switch-homescreen-css-recreation 는 접근 불가능해서 제외했습니다  -->\n<details>\n  <summary>관련 자료</summary>\n\n<ul>\n<li><a href=\"https://developer.chrome.com/blog/css-scroll-state-queries\">크롬 블로그</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries\">MDN</a></li>\n<li><a href=\"https://una.im/scroll-state-scrolled\">scrolled에 관한 Una 블로그</a></li>\n<li><a href=\"https://www.bram.us/2025/10/22/solved-by-css-scroll-state-queries-hide-a-header-when-scrolling-down-show-it-again-when-scrolling-up/\">scrolled에 관한 Bramus 블로그</a></li>\n<li><a href=\"http://localhost:3030/the-css-podcast-on-state-queries\">CSS 팟캐스트</a></details>\n\n</li>\n</ul>\n<h2 id=\"text-box\"><code>text-box</code></h2>\n<p><code>text-box</code>로 텍스트 박스의 위아래 줄 사이 간격을 깔끔하게 잘라낼 수 있습니다!</p>\n<p>웹 폰트 렌더링에는 보통 <a href=\"https://matthiasott.com/notes/the-thing-with-leading-in-css\">글리프 위아래에 안전한 여백(safe spacing)이 포함</a>되는데, 경우에 따라 베이스라인이나 x-height에 픽셀로 딱 맞춘 정렬이 필요하기도 합니다.</p>\n<p><img src=\"https://nerdy.dev/media/text-box-trim-cap.avif\" alt=\"\"></p>\n<p>위의 이미지를 CSS 코드로 구현하면 다음과 같습니다.</p>\n<pre><code class=\"language-css\">h1 {\n  text-box: trim-both cap alphabetic;\n}</code></pre>\n<p>이 한 줄만으로 대문자 높이 위의 여백과 알파벳 기준선 아래의 여백을 말끔히 자를 수 있습니다.</p>\n<p><a href=\"https://nerdy.dev/media/text-box-trimmed.mp4\"><img src=\"https://nerdy.dev/media/text-box-trimmed.avif\" alt=\"세로로 스크롤하면서 overflow 방향에 따라 그림자를 나타내는 영상\"></a></p>\n<blockquote>\n<p><a href=\"https://nerdy.dev/notebook/text-box.html\">여기서 더 학습해 보세요 💻</a></p>\n</blockquote>\n<p>타이포그래피와 그리드 정렬에 진심인 사람들에게는 정말 완벽한 기능입니다.\n아마 <a href=\"https://nerdy.dev/text-box-ftw\">기본값처럼 쓰이게 되지</a> 않을까요?</p>\n<details>\n  <summary>관련 자료</summary>\n\n<ul>\n<li><a href=\"https://developer.chrome.com/blog/css-text-box-trim\">크롬 블로그</a></li>\n<li><a href=\"https://nerdy.dev/notebook/text-box.html\">인터랙티브 노트북</a></li>\n<li><a href=\"https://codepen.io/collection/zxQBaL\">코드펜 모음</a></details>\n\n</li>\n</ul>\n<h2 id=\"타입이-추가된-attr\">타입이 추가된 <code>attr()</code></h2>\n<p><code>attr()</code>의 고급 버전이 등장했습니다. 타입 안정적이며 훨씬 더 강력합니다.</p>\n<p>타입 체크와 기본값을 포함하여 <strong>HTML 속성을 CSS에서 직접 사용할</strong> 수 있게 해줍니다.</p>\n<p>색상을 전달해볼까요?</p>\n<pre><code class=\"language-html\">&lt;div data-bg=&quot;white&quot; data-fg=&quot;deeppink&quot;&gt;&lt;/div&gt;</code></pre>\n<pre><code class=\"language-css\">.theme {\n  background: attr(data-bg color, black);\n  color: attr(data-fg color, white);\n}</code></pre>\n<p>숫자를 전달하는 것도 가능합니다.</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;grid&quot; data-columns=&quot;3&quot;&gt;…&lt;/div&gt;</code></pre>\n<pre><code class=\"language-css\">.grid {\n  --_columns: attr(data-columns number, 3);\n\n  display: grid;\n  grid-template-columns: repeat(var(--_columns), 1fr);\n}</code></pre>\n<p>HTML과 CSS 사이에 강력한 연결 고리가 생성된 셈입니다.</p>\n<p>아래 코드는 CSS가 사실상 enum 역할을 하고, HTML은 원하는 동작을 얻기 위해 그에 맞는 유효한 값만 전달하는 예제입니다.</p>\n<pre><code class=\"language-html\">&lt;li scroll-snap=&quot;start&quot;&gt;&lt;/li&gt;\n&lt;li scroll-snap=&quot;center&quot;&gt;&lt;/li&gt;\n&lt;li scroll-snap=&quot;end&quot;&gt;&lt;/li&gt;\n&lt;li scroll-snap=&quot;nothing&quot;&gt;&lt;/li&gt;</code></pre>\n<pre><code class=\"language-css\">[scroll-snap] {\n  scroll-snap-align: attr(scroll-snap type(start | center | end));\n}</code></pre>\n<p><code>type()</code> 함수는 속성 값을 허용된 키워드 목록과 비교해 검증합니다.\n유효하지 않은 값은 자동으로 안전한 기본값으로 대체됩니다.</p>\n<p><a href=\"https://codepen.io/argyleink/pen/qEWyZgx\">코드펜에서 테스트 해보세요. 🖊️</a></p>\n<details>\n  <summary>관련 자료</summary>\n\n<ul>\n<li><a href=\"https://nerdy.dev/advanced-attr\">CSS 새로운 기능과 관련하여 2025년에 저자가 작성한 글</a></li>\n<li><a href=\"https://codepen.io/argyleink/pen/qEWyZgx\">코드펜 데모</a></li>\n<li><a href=\"https://developer.chrome.com/blog/advanced-attr\">크롬 개발자 아티클</a></li>\n<li><a href=\"https://css-tip.com/value-input/\">Temani Afif의 아티클</a></li>\n<li><a href=\"https://codepen.io/t_afif/pen/MWdmZPL\">Temani Afif의 슬라이더 툴팁 데모</a></details>\n\n</li>\n</ul>\n<p>이제 &quot;다 갖고 싶다&quot;는 욕심을 담아서 만든, AI 티가 나서 웃긴 짤을 하나 만들었는데 보면서 같이 웃어보는 건 어떨까요?</p>\n<p><img src=\"https://nerdy.dev/media/punk-eats-css-cake.avif\" alt=\"\"></p>\n<p><em>손은 여전히 잘 못 그리네요 ㅋㅋ</em></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@typo/4-css-features-every-front-end-developer-should-know-in-2026"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[번역] 성능과 하이라이팅을 모두 잡는 CSS Highlights API",
    "partialText": "<blockquote>\n<p>원저자의 허락을 받아 &lt;<a href=\"https://pavi2410.com/blog/high-performance-syntax-highlighting-with-css-highlights-api/\">High-Performance Syntax Highlighting with CSS Highlights API</a>&gt; 아티클을 한국어로 번역한 글입니다.</p>\n</blockquote>\n<h2 id=\"기존-구문-하이라이팅-방식의-성능-문제\">기존 구문 하이라이팅 방식의 성능 문제</h2>\n<p>대부분의 구문 하이라이팅 도구는 각 토큰(키워드, 문자열, 연산자 등)을 <code>&lt;span&gt;</code> 요소로 감싸고 CSS 클래스를 적용하는 방식으로 작동합니다. 그래서 수백 또는 수천 개의 DOM 노드를 생성해야 하는 경우도 있습니다.</p>\n<pre><code class=\"language-html\">&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;\n&lt;span class=&quot;identifier&quot;&gt;greeting&lt;/span&gt;\n&lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt;\n&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;</code></pre>\n<p>이러한 각 노드는 브라우저의 렌더링 파이프라인에 부담을 더합니다. 파싱해야 할 노드가 늘어나고, 레이아웃 계산과 페인트 작업이 더 많이 수행되고, 메모리 사용량도 커지기 때문입니다. 문서 위주의 사이트나 코드 양이 많은 앱이라면, 성능에 직접적으로 영향을 미칠 수 있습니다.</p>\n<h2 id=\"css-커스텀-highlight-api-살펴보기\">CSS 커스텀 Highlight API 살펴보기</h2>\n<p>CSS 커스텀 Highlight API는 DOM 구조를 조작하지 않고도 특정 텍스트 범위를 스타일링하는 방법을 제공합니다. 래퍼 요소를 생성하는 대신, 텍스트 노드 안의 특정 문자 위치를 가리키는 <code>Range</code> 객체를 만들고, 이를 스타일 타입별로 그룹화한 뒤 브라우저의 하이라이트 레지스트리에 등록하는 방식입니다.</p>\n<p><strong>왜 더 빠를까요?</strong></p>\n<ul>\n<li><strong>DOM 조작이 없음:</strong> 텍스트는 하나의 텍스트 노드로 존재함</li>\n<li><strong>적은 메모리 사용량</strong>: Range는 가벼운 객체</li>\n<li><strong>브라우저 최적화</strong>: 브라우저가 직접 페인팅을 처리</li>\n<li><strong>명확한 분리</strong>: 스타일링은 CSS에서만 처리</li>\n</ul>\n<h2 id=\"브라우저-지원\">브라우저 지원</h2>\n<p>CSS 커스텀 Highlight API는 모든 모던 브라우저에서 지원됩니다.</p>\n<ul>\n<li>Chrome/Edge 105+</li>\n<li>Firefox 140+</li>\n<li>Safari 17.2+</li>\n<li>Opera 91+</li>\n</ul>\n<p>최신 버전에서 잘 지원되지만 API가 존재하는지 확인하는 것이 좋습니다.\n<code>if (!CSS.highlights) { \\/\\* 없는 경우 폴백 대비 \\*/ }</code></p>\n<h2 id=\"예제-구현-코드\">예제 구현 코드</h2>\n<p>CSS Highlight API를 사용하여 구문을 하이라이팅하는 코드를 구현해 보겠습니다.</p>\n<h3 id=\"1단계-css-highlight-스타일-정의하기\">1단계) CSS Highlight 스타일 정의하기</h3>\n<p>먼저 <code>::highlight()</code> 의사 요소(pseudo-element)를 사용하여 각 토큰 타입에 해당하는 스타일을 정의합니다.</p>\n<pre><code class=\"language-css\">::highlight(keyword) {\n  color: #0000ff;\n  font-weight: bold;\n}\n\n::highlight(string) {\n  color: #a31515;\n}\n\n::highlight(comment) {\n  color: #008000;\n  font-style: italic;\n}\n\n::highlight(number) {\n  color: #098658;\n}\n\n::highlight(operator) {\n  color: #000000;\n}\n\n::highlight(function) {\n  color: #795e26;\n}</code></pre>\n<h3 id=\"2단계-하이라이팅-로직-구현하기\">2단계) 하이라이팅 로직 구현하기</h3>\n<p>코드 요소에 하이라이트를 적용하는 핵심 로직을 구현해보면 다음과 같습니다.</p>\n<pre><code class=\"language-tsx\">function applyHighlighting(element: HTMLElement, code: string): () =&gt; void {\n  // 브라우저 지원 확인\n  if (!CSS.highlights) {\n    console.warn(&quot;CSS Custom Highlight API not supported&quot;);\n    return () =&gt; {};\n  }\n\n  // 텍스트 노드 가져오기 (반드시 하나의 텍스트 노드여야 함)\n  const textNode = element.firstChild;\n  if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {\n    return () =&gt; {};\n  }\n\n  // 코드 토큰화 (필요에 맞는 어휘 분석기 사용)\n  const tokens = lexTypeScript(code);\n\n  // 토큰별로 Range 객체 생성\n  const tokenRanges = tokens.map((token) =&gt; {\n    const range = new Range();\n    range.setStart(textNode, token.start);\n    range.setEnd(textNode, token.end);\n    return { type: token.type, range };\n  });\n\n  // 토큰 타입별로 Range 그룹화\n  const highlightsByType = Map.groupBy(\n    tokenRanges,\n    (item: { type: string; range: Range }) =&gt; item.type\n  );\n\n  // Highlight를 생성하고 등록하기\n  const createdHighlights = new Map&lt;string, Highlight&gt;();\n\n  for (const [type, items] of highlightsByType) {\n    const ranges = items.map(\n      (item: { type: string; range: Range }) =&gt; item.range\n    );\n    const highlight = new Highlight(...ranges);\n    createdHighlights.set(type, highlight);\n\n    // 전역 CSS 하이라이트 레지스트리에 등록\n    const existing = CSS.highlights.get(type);\n    if (existing) {\n      ranges.forEach((range) =&gt; existing.add(range));\n    } else {\n      CSS.highlights.set(type, highlight);\n    }\n  }\n\n  // 클린업 함수\n  return () =&gt; {\n    for (const [type, highlight] of createdHighlights) {\n      const globalHighlight = CSS.highlights.get(type);\n      if (globalHighlight) {\n        highlight.forEach((range) =&gt; globalHighlight.delete(range));\n        if (globalHighlight.size === 0) {\n          CSS.highlights.delete(type);\n        }\n      }\n    }\n  };\n}</code></pre>\n<h3 id=\"3단계-애플리케이션에-사용하기\">3단계) 애플리케이션에 사용하기</h3>\n<p>간단하게 바닐라 자바스크립트로 코드를 작성하면 다음과 같습니다.</p>\n<pre><code class=\"language-js\">// 코드 뷰어 요소 생성\nfunction createCodeViewer(code, language = &quot;javascript&quot;) {\n  const container = document.createElement(&quot;div&quot;);\n  container.style.cssText = `\n    position: relative;\n    background: #f5f5f5;\n    padding: 15px;\n    border-radius: 4px;\n    font-family: monospace;\n    font-size: 14px;\n    overflow-x: auto;\n    border: 1px solid #e0e0e0;\n    white-space: pre;\n    line-height: 1.5;\n  `;\n\n  const codeElement = document.createElement(&quot;div&quot;);\n  codeElement.textContent = code;\n  container.appendChild(codeElement);\n\n  // 하이라이팅 적용\n  const cleanup = applyHighlighting(codeElement, code);\n\n  // 나중에 사용할 클린업 함수 저장\n  container._cleanup = cleanup;\n\n  return container;\n}\n\n// 적용\nconst viewer = createCodeViewer(`\nconst greeting = &quot;Hello, World!&quot;\nfunction sayHello() {\n  console.log(greeting)\n}\n`);\n\ndocument.body.appendChild(viewer);\n\n// 제거될 때 클린업 처리\n// viewer._cleanup()\n// viewer.remove()</code></pre>\n<p>혹은 리액트로 작성할 수도 있습니다.</p>\n<pre><code class=\"language-tsx\">import { useEffect, useRef } from &quot;react&quot;;\n\nfunction CodeViewer({ code, language = &quot;javascript&quot; }) {\n  const codeRef = useRef &lt; HTMLDivElement &gt; null;\n\n  useEffect(() =&gt; {\n    if (!codeRef.current) return;\n\n    const cleanup = applyHighlighting(codeRef.current, code);\n    return cleanup;\n  }, [code]);\n\n  return (\n    &lt;div\n      style={{\n        position: &quot;relative&quot;,\n        background: &quot;#f5f5f5&quot;,\n        padding: &quot;15px&quot;,\n        borderRadius: &quot;4px&quot;,\n        fontFamily: &quot;monospace&quot;,\n        fontSize: &quot;14px&quot;,\n        overflowX: &quot;auto&quot;,\n        border: &quot;1px solid #e0e0e0&quot;,\n        whiteSpace: &quot;pre&quot;,\n        lineHeight: &quot;1.5&quot;,\n      }}\n    &gt;\n      &lt;div ref={codeRef}&gt;{code}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n<h2 id=\"인터랙티브-데모로-직접-써보기\">인터랙티브 데모로 직접 써보기</h2>\n<p>여러분이 직접 해볼 수 있습니다! 코드를 작성하고 구문 하이라이팅 스타일을 직접 정의해 보세요. 아래 데모에는 두 개의 편집기가 나란히 배치되어 있습니다. 각각 자바스크립트 코드용과 CSS 하이라이트 스타일용입니다. 여러분이 수정한 코드가 실시간으로 미리보기에 반영됩니다!</p>\n<blockquote>\n<p>역자주: 블로그 플랫폼 특성상 데모를 복사해올 수 없어 링크로 대체합니다. 관심 있으신 분은 <a href=\"https://pavi2410.com/blog/high-performance-syntax-highlighting-with-css-highlights-api/#interactive-demo\">원문</a>에서 확인해 보세요 :)</p>\n</blockquote>\n<h2 id=\"작동-방식\">작동 방식</h2>\n<ol>\n<li><strong>토큰화</strong>: 렉서가 소스 코드를 스캔해 토큰을 생성하고, 각 토큰에 타입 정보와 문자 위치를 포함시킵니다.</li>\n<li><strong>Range 생성</strong>: 각 토큰이 텍스트 노드 내에서 정확히 어디에 있는지를 나타내는 <code>Range</code> 객체를 만듭니다.</li>\n<li><strong>그룹화</strong>: 토큰 타입(키워드, 문자열, 주석 등)별로 Range를 묶습니다.</li>\n<li><strong>하이라이트 등록</strong>: 각 그룹을 <code>Highlight</code> 객체로 감싼 뒤, 토큰 타입을 키로 하여 <code>CSS.highlights</code>에 등록합니다.</li>\n<li><strong>CSS 스타일링</strong>: 브라우저는 <code>::highlight(token-type)</code> 규칙에 정의된 스타일을 적용합니다.</li>\n<li><strong>클린업</strong>: 컴포넌트가 언마운트될 때 모든 Range를 레지스트리에서 제거합니다.</li>\n</ol>\n<h2 id=\"장점\">장점</h2>\n<ul>\n<li>⚡ <strong>성능</strong>: DOM 변경이 없으므로 초기 렌더링과 리렌더링이 더 빠름</li>\n<li>💾 <strong>효율적인 메모리</strong>: 래퍼 요소에 비해 Range는 메모리를 거의 사용하지 않음</li>\n<li>🧹 <strong>깨끗한 HTML</strong>: DOM에는 단일 텍스트 노드만 남아 구조가 깔끔함</li>\n<li>🎨 <strong>순수한 CSS 스타일링</strong>: 모든 스타일을 CSS에서 선언적으로 정의</li>\n<li>♻️ <strong>간단한 클린업</strong>: DOM을 건드리지 않고 Range의 추가/삭제가 가능함</li>\n</ul>\n<h2 id=\"한계\">한계</h2>\n<ul>\n<li><strong>텍스트 노드만 지원</strong>: 순수 텍스트 콘텐츠에만 동작함</li>\n<li><strong>단일 텍스트 노드 필요</strong>: 하이라이팅 할 요소가 단일 텍스트 노드를 가져야 함</li>\n<li><strong>정적 Range</strong>: 텍스트 내용이 변경되더라도 Range가 자동으로 갱신되지 않음</li>\n<li><strong>구형 브라우저</strong>: Chrome 105, Firefox 140, Safari 17.2 이전 브라우저에서는 폴백 필요</li>\n</ul>\n<h2 id=\"기존-방식과의-비교\">기존 방식과의 비교</h2>\n<table>\n<thead>\n<tr>\n<th>비교 사항</th>\n<th>기존 방식 (래퍼 코드)</th>\n<th>CSS Highlight API</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DOM 노드</td>\n<td>수백 혹은 수천 개</td>\n<td>하나의 텍스트 노드</td>\n</tr>\n<tr>\n<td>메모리 사용량</td>\n<td>높음</td>\n<td>낮음</td>\n</tr>\n<tr>\n<td>초기 렌더링</td>\n<td>느림</td>\n<td>빠름</td>\n</tr>\n<tr>\n<td>리렌더링</td>\n<td>느림</td>\n<td>빠름</td>\n</tr>\n<tr>\n<td>HTML 구조</td>\n<td>복잡함</td>\n<td>단순함</td>\n</tr>\n<tr>\n<td>브라우저 지원</td>\n<td>모든 브라우저</td>\n<td>최신 브라우저</td>\n</tr>\n</tbody></table>\n<h2 id=\"마무리\">마무리</h2>\n<p>CSS 커스텀 Highlight API는 문법 하이라이팅이나 텍스트 스타일링 기능을 구현하는 데 있어 의미 있는 변화입니다. 래퍼 DOM 요소가 필요 없으므로 성능이 크게 향상되며, 코드도 더욱 깔끔하고 유지보수가 쉽습니다.</p>\n<p>또한 주요 브라우저에서 꽤 우수한 지원을 제공하므로, 대부분의 최신 웹 프로덕션 환경에서 바로 사용할 수 있습니다. 버전이 낮은 브라우저도 지원해야 한다면 기존의 DOM 기반 하이라이팅 방식으로 폴백할 수 있습니다.</p>\n<p>텍스트 하이라이팅의 미래는 <code>&lt;span&gt;</code> 태그 없이 이미 우리에게 다가왔습니다! 🎨✨</p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@typo/high-performance-syntax-highlighting-with-css-highlights-api"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "취뽀",
    "partialText": "아는 분 소개로 잠깐 대화만 나눠달라고 해서 갔는데, 면접이었다. 그냥 개발자 면접인 줄 알았는데 개발 리드 면접이었고, 대표님이 직접 나와서 면접을 보셨다.\n그리고는 바로 같이 일해보자고 하시더라. 사실 취업할 생각은 전혀 없었다. 올해 1년간 할 다른 도전들을 계획해놨고, 준비도 다 해놨었다. 그런데 대표님이 며칠간 계속 설득하시는 바람에 결국 출근하게 됐다. 하루아침에 직장인으로 돌아온 셈이다. 대표님은 기존에 하던 일은 출근하면서 마무리해도 된다고 하시며, 빠르게 와서 팀 매니징을 부탁한다고만 하셨다.\n이렇게 빠른 결정들은 항상 문제가 생기기도 한다. 그런데 대표님이 너무 간절해 보였다.\n나는 창업을 하면서 이렇게 간절한 적이 있었나 싶었다. 그러면서 지난 창업 기간을 되돌아보기도 했다. 나는 얼마나 대표스러웠을까? 물론 목표가 이런 걸 바라고 창업한 건 아니지만, 나는 과연 얼마나 했을까? 사업에 대한 절실함, 팀에 대한 책임감, 비전을 향한 추진력. 그런 것들이 나에게도 있었을까?\n그래서 이 대표님에게 궁금함이 생겼다. 무엇이 사람을 이렇게 간절하게 만들었을까? 그리고 나를 왜 필요로 하는지, 그 필요가 언제까지 이어질까?\n올해 계획을 세운 지 얼마 되지 않았고, 외주 계약을 몇 개 맺은 지도 얼마 안 됐는데, 바로 출근하게 됐다.\n일단 기존에 진행하던 일은 빠르게 마무리하는 형식으로 진행하고, 추가 계약 직전에 있던 것들은 거절 의사를 전달했다. 클라이언트들에게 상황을 설명하는 게 생각보다 어려웠다. 갑작스러운 변화를 어떻게 설명해야 할지, 그들이 이해해줄지 조금 걱정도 됐다.\n바리스타 학원도 다닐 준비를 하고, 기타 여러 가지를 준비해 놨는데, 다 취소됐다. 아쉽긴 하다. 특히 바리스타는 꽤 오래전부터 해보고 싶었던 거라 마음 한편이 허전하다. 언젠가 기회가 되면 다시 도전해봐야겠다는 생각만 남았다.\n인생이 참 묘하다. 계획대로 되지 않는 게 당연한 건데, 막상 이렇게 되면 당황스럽다. 그래도 나쁘지 않은 당황스러움이다.\n그렇게 취뽀?를 하고 다시 회사를 다니면서 내가 지난 1년간 얼마나 사회와 IT, 스타트업씬과 멀어졌나 느껴졌다.\n1년 만에 세상은 많이 바뀌어 있었다. 나도 바쁘게 살아왔다고, 제품도 많이 만들고, 코딩도 많이 했다고 생각했지만, 다시 적응하는 데 오래 걸릴 것 같은 기분이 들었다. 세상은 저 멀리 나 몰래 가버리고 있었다.\n기술 스택도 바뀌었고, 개발 방법도 많이 바뀌었고, 트렌드도 바뀌었고, 사람들이 이야기하는 주제들도 달라져 있었다. 혼자 작은 프로젝트들을 하면서는 몰랐던 것들이, 조직 안에서 일하려니 한꺼번에 보이기 시작했다.\n다시 따라잡으려면 당분간 뛰어야 할 것 같다. 아니, 뜀박질을 해야 할 것 같다.",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://w0nder.land/posts/62-%EC%B7%A8%EB%BD%80"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "조선개발실록 - 제8화(1부 최종): 유수불부 (流水不腐)",
    "partialText": "<h1 id=\"제8화-유수불부-流水不腐\">제8화: 유수불부 (流水不腐)</h1>\n<h2 id=\"흐르는-물은-썩지-않는다\">&quot;흐르는 물은 썩지 않는다&quot;</h2>\n<hr>\n<h3 id=\"경복궁-근정전-마지막-보고일\">[경복궁 근정전, 마지막 보고일]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘로 일곱 번째다. 결론을 내려야 한다.</p>\n<p><strong>왕:</strong> 그런데 솔직히 말하겠다. 과인이 한 달 전에는 답이 쉬울 줄 알았다.</p>\n<p><strong>영의정:</strong> 전하?</p>\n<p><strong>왕:</strong> 시험 문제를 바꾸면 될 줄 알았다. 인공지가 못 푸는 문제를 내면 되지 않겠느냐고.</p>\n<p><strong>왕:</strong> 칠 주를 보니, 그게 아니었다.</p>\n<hr>\n<p><strong>왕:</strong> 과인이 칠 주를 보며 가장 놀란 것을 말해주겠다.</p>\n<p><strong>왕:</strong> 코드가 아니었다.</p>\n<hr>\n<p><strong>왕:</strong> 첫날을 기억하느냐. 갑이 &quot;단일책임원칙 분리해라&quot; 했다. 을은 길게 풀어서 시켰다. 병은 &quot;리액쿼리 패턴으로&quot; 했다.</p>\n<p><strong>왕:</strong> 셋 다 코드가 나왔다. 그런데 과인은 그 자리에서 누가 아는 자이고 누가 모르는 자인지 바로 알았다.</p>\n<hr>\n<p><strong>좌의정:</strong> 코드를 보시고 아셨사옵니까?</p>\n<p><strong>왕:</strong> 아니다. 말을 듣고 알았다.</p>\n<hr>\n<p><strong>왕:</strong> 갑이 &quot;분리해라&quot; 했을 때, 과인은 그 말에서 갑의 한계를 보았다.</p>\n<p><strong>왕:</strong> 병이 &quot;아니다, 밸리데이션은 폼에 포함이다&quot; 하고 잡아줬을 때, 과인은 그 말에서 병의 실력을 보았다.</p>\n<p><strong>왕:</strong> 을이 &quot;원래 그렇게 하는 거 아닙니까&quot; 했을 때, 과인은 그 말에서 을의 감옥을 보았다.</p>\n<p><strong>왕:</strong> 갑이 &quot;그것도 시키면 안 돼?&quot; 했을 때, 과인은 그 말에서 갑의 성장을 보았다.</p>\n<hr>\n<p><strong>왕:</strong> 전부 말이었다. 코드가 아니었다.</p>\n<hr>\n<p><strong>왕:</strong> 부엌에 비유하겠다.</p>\n<p><strong>왕:</strong> 접시에 담긴 음식만 보면 누가 만들었는지 모른다. 사또가 손수 만들었는지, 찬모가 만들었는지, 옆집에서 사왔는지.</p>\n<p><strong>왕:</strong> 그러나 부엌에 들어가 지켜보면 안다. 재료를 고르는 눈, 간을 보는 혀, &quot;이건 아니다&quot; 하고 다시 하는 판단.</p>\n<hr>\n<p><strong>왕:</strong> 과인이 칠 주간 한 것이 무엇이었느냐.</p>\n<p><strong>왕:</strong> 부엌에 들어간 것이었다. 그대들을 앉혀놓고, 눈앞에서 해보게 하고, 묻고 답하고, 다시 물었다.</p>\n<hr>\n<p><strong>왕:</strong> 그것이 이미 시험이었다.</p>\n<hr>\n<p><strong>영의정:</strong> 전하, 그러시면...</p>\n<p><strong>왕:</strong> 그렇다. 새 과거시험의 핵심은 구술(口述)이다. 면접(面接)을 보겠다.</p>\n<hr>\n<p><strong>좌의정:</strong> 면접이라 하시옵니까? 코드를 짜는 시험이 아니옵니까?</p>\n<hr>\n<p><strong>왕:</strong> 좌의정. 코드를 짜게 하면 인공지가 짜줄 수 있다. 답안을 쓰게 하면 인공지가 써줄 수 있다. 눈앞에서 짜게 해도 인공지가 옆에서 속삭여줄 수 있다.</p>\n<hr>\n<p><strong>왕:</strong> 그런데 그 자리에서, 즉석으로, 묻고 답하는 것. 이것은 인공지가 대신해줄 수 없다.</p>\n<p><strong>왕:</strong> 무엇을 물을지 모르니 미리 답을 받아올 수 없다.</p>\n<p><strong>왕:</strong> 파고들수록 깊어지니 빌려온 지식으로는 버틸 수 없다.</p>\n<hr>\n<p><strong>왕:</strong> 김진사를 생각해보라.</p>\n<p><strong>왕:</strong> 그자의 답안지는 완벽했다. 시험 성적도 수석이었다.</p>\n<p><strong>왕:</strong> 그런데 과인이 그자를 앉혀놓고 &quot;왜 이렇게 짰느냐?&quot; 한 마디만 물었으면, 대답을 못 했을 것이다. 인공지가 짰으니까.</p>\n<hr>\n<p><strong>왕:</strong> 말을 섞어보면 안다. 이것이 진짜인지, 빌려온 것인지.</p>\n<p><strong>왕:</strong> 자신의 피와 땀이 섞인 경험은 흉내 낼 수 없다.</p>\n<hr>\n<p><strong>영의정:</strong> 구체적으로 어찌 묻겠사옵니까?</p>\n<hr>\n<p><strong>왕:</strong> 과인이 칠 주간 물어서 효과를 본 것이 세 가지다.</p>\n<hr>\n<p><strong>왕:</strong> &quot;왜&quot;를 물으면 깊이가 드러난다.</p>\n<p><strong>왕:</strong> &quot;왜 이 기술을 썼느냐?&quot; &quot;왜 여기서 분리했느냐?&quot;</p>\n<p><strong>왕:</strong> 첫날 병에게 &quot;왜 쪼개서 물었느냐?&quot; 물었을 때, 그 답에서 병의 깊이를 보았다. &quot;인공지가 짰습니다&quot; 하는 자와 &quot;이러이러한 이유로 이 방식을 택했습니다&quot; 하는 자는 다르다.</p>\n<hr>\n<p><strong>왕:</strong> &quot;만약에&quot;를 물으면 판단이 드러난다.</p>\n<p><strong>왕:</strong> &quot;만약 사용자가 열 배 늘면 어찌 하겠느냐?&quot; &quot;만약 이 도구가 지원 중단되면 어찌 하겠느냐?&quot;</p>\n<p><strong>왕:</strong> 둘째 날 병이 &quot;동시성 문제는 이번 범위에서 빼자&quot; 한 것이 이것이다. 정해진 답이 없는 데서 자기 판단을 내리는 것.</p>\n<hr>\n<p><strong>왕:</strong> &quot;차이&quot;를 물으면 안목이 드러난다.</p>\n<p><strong>왕:</strong> &quot;A 방식과 B 방식이 어찌 다르냐?&quot; &quot;그대는 어떤 것이 더 좋다고 생각하느냐?&quot;</p>\n<p><strong>왕:</strong> 남이 하는 대로 따라 하는 것이 아니라, &quot;나는 이런 이유로 이것이 좋다&quot;고 말할 수 있는 안목. 기술에 대한 조예(造詣)가 있느냐는 것이다.</p>\n<hr>\n<p><strong>왕:</strong> 이 세 가지를 물으면, 시험지로는 볼 수 없는 것들이 드러난다.</p>\n<p><strong>왕:</strong> 투박하더라도 자기 말로 하는 자와, 남의 말을 앵무새처럼 읊는 자는 다르다. 파고들면 밑천이 드러나는지, 더 깊은 이야기가 나오는지도 보인다.</p>\n<hr>\n<p><strong>왕:</strong> 그리고 태도를 보겠다.</p>\n<p><strong>왕:</strong> 모르는 것을 모른다 하는 정직함. 새로운 것 앞에서 움츠리지 않는 열린 마음.</p>\n<p><strong>왕:</strong> 인공지 시대에 가장 중요한 것은 지식이 아니라 그 태도다.</p>\n<hr>\n<p><strong>왕:</strong> 이것이 새 과거시험이다.</p>\n<hr>\n<p><strong>왕:</strong> 갑, 을, 병. 그대들 생각은 어떠하냐?</p>\n<hr>\n<p><strong>갑:</strong> 전하, 솔직히 아뢰겠사옵니다. 예전 시험이었으면 소인이 붙었을 것이옵니다. 용어는 알았으니까요.</p>\n<p><strong>왕:</strong> 지금은?</p>\n<p><strong>갑:</strong> <em>(머뭇거리며)</em> ...솔직히 자신이 없사옵니다. 아직 병 어르신처럼 되려면 멀었사옵니다.</p>\n<hr>\n<p><strong>을:</strong> 전하, 소인도 마찬가지이옵니다. 이 칠 주 동안 많이 배웠다고 생각했는데...</p>\n<p><strong>을:</strong> 막상 혼자 해보면 예전 습관이 나오옵니다. 한꺼번에 시키고, 확인 안 하고.</p>\n<p><strong>왕:</strong> 그래도 예전보다는 낫지 않느냐?</p>\n<p><strong>을:</strong> 그러하옵니다. 다만... 몸에 익으려면 시간이 더 걸릴 것 같사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 전하, 소인은 한 가지 건의가 있사옵니다.</p>\n<p><strong>왕:</strong> 말해보라.</p>\n<p><strong>병:</strong> 이 시험을 한 번만 보지 마시옵소서. 정기적으로 보시옵소서.</p>\n<p><strong>왕:</strong> 왜?</p>\n<hr>\n<p><strong>병:</strong> 인공지가 계속 발전하옵니다. 지금 잘 부리는 방법이 일 년 후에는 달라질 수 있사옵니다.</p>\n<p><strong>병:</strong> 계속 배우고, 계속 적응해야 하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 일리가 있구나. 그리하겠다.</p>\n<p><strong>왕:</strong> 영의정, 좌의정. 새 과거시험 제도를 준비하라.</p>\n<p><strong>영의정·좌의정:</strong> 명을 받들겠사옵니다, 전하.</p>\n<p><strong>왕:</strong> 갑, 을, 병. 그대들이 도우라.</p>\n<p><strong>갑·을·병:</strong> 명을 받들겠사옵니다, 전하.</p>\n<hr>\n<h3 id=\"막-내림\">[막 내림]</h3>\n<hr>\n<hr>\n<h2 id=\"반-년-후\">반 년 후</h2>\n<hr>\n<h3 id=\"어느-개발방-갑이-새-술사에게-가르치고-있다\">[어느 개발방, 갑이 새 술사에게 가르치고 있다]</h3>\n<hr>\n<p><strong>새 술사:</strong> 갑 선배, 이 컴포넌특을 리팩토링하라는데... 어찌 시작해야 할지 모르겠사옵니다.</p>\n<p><strong>갑:</strong> 바로 고치라 하지 마. 먼저 분석부터 시켜. <em>(인공지에게)</em> 이 컴포넌특 분석해라. 책임이 몇 개냐?</p>\n<p><strong>새 술사:</strong> <em>(눈이 커지며)</em> 아, 분석부터 시키는 것이옵니까?</p>\n<p><strong>갑:</strong> 나도 예전에는 바로 &quot;분리해라&quot; 했어. 그러면 엉망이 돼.</p>\n<p><strong>갑:</strong> 인공지가 분석해서 내놓으면, 네가 보고 맞는지 확인해. 아니다 싶으면 잡아줘. 그 다음에 설계하고, 그 다음에 구현 시켜.</p>\n<hr>\n<p><strong>새 술사:</strong> <em>(감탄하며)</em> 선배는 어디서 이런 걸 배우셨사옵니까?</p>\n<p><strong>갑:</strong> <em>(잠시 멈칫하다가, 웃으며)</em> 좋은 스승이 있었어.</p>\n<hr>\n<h3 id=\"다른-개발방-을이-동료와-이야기하고-있다\">[다른 개발방, 을이 동료와 이야기하고 있다]</h3>\n<hr>\n<p><strong>동료:</strong> 을, 이 워크플로 네가 만든 거야? 코드 짜고 실행하고 에러 잡는 것까지 알아서 돌아가네.</p>\n<p><strong>을:</strong> 처음에 아이디어 낸 건 갑이야. &quot;그것도 시키면 안 돼?&quot; 했거든.</p>\n<p><strong>동료:</strong> 그래도 만든 건 네가 만들었잖아.</p>\n<hr>\n<p><strong>을:</strong> <em>(잠시 생각하다가)</em> 예전에는 에러 나면 내가 긁어다 붙여줬어. &quot;원래 그렇게 하는 거&quot; 줄 알고.</p>\n<p><strong>동료:</strong> 지금은?</p>\n<p><strong>을:</strong> <em>(피식 웃으며)</em> 지금은 &quot;원래 그런 거&quot;라는 말이 나오면 의심부터 해. 그게 감옥이더라고.</p>\n<hr>\n<h3 id=\"어느-주막-병이-홀로-술을-마시고-있다\">[어느 주막, 병이 홀로 술을 마시고 있다]</h3>\n<hr>\n<p><strong>낯선 자:</strong> <em>(조심스레 다가오며)</em> 혹시... 병 어르신이시옵니까?</p>\n<p><strong>병:</strong> <em>(고개를 들며)</em> 그렇소만.</p>\n<p><strong>낯선 자:</strong> <em>(눈이 반짝이며)</em> 아이고, 드디어 뵙습니다! 소인은 남쪽 고을에서 왔사옵니다. 어르신 이야기를 듣고 한걸음에 달려왔사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 무슨 이야기를 들었소?</p>\n<p><strong>낯선 자:</strong> 인공지를 부리는 법을 터득하셨다고. 임금님께 직접 가르침을 드렸다고.</p>\n<p><strong>낯선 자:</strong> 개발방 술사들 사이에서 모르는 이가 없사옵니다.</p>\n<p><strong>병:</strong> <em>(쓴웃음)</em> 소문이 과장됐소. 앉으시오.</p>\n<hr>\n<p><strong>낯선 자:</strong> <em>(자리에 앉으며)</em> 소인도 인공지를 쓰고는 있사옵니다. 그런데 뭔가... 제대로 쓰고 있는 건지 모르겠사옵니다.</p>\n<p><strong>낯선 자:</strong> 어르신은 어찌 쓰시는지, 너무 궁금하옵니다.</p>\n<hr>\n<h3 id=\"병-그간-깨달은-것들을-이야기한다\">[병, 그간 깨달은 것들을 이야기한다]</h3>\n<hr>\n<p><strong>병:</strong> 별것 없소. 몇 가지만 기억하면 되오.</p>\n<p><strong>낯선 자:</strong> <em>(자세를 고쳐 앉으며)</em> 청하옵니다.</p>\n<hr>\n<p><strong>병:</strong> 첫째, 한꺼번에 시키지 마시오. 쪼개서 시키시오.</p>\n<p><strong>낯선 자:</strong> <em>(고개를 끄덕이며)</em> 예, 예.</p>\n<p><strong>병:</strong> 둘째, 구현부터 시키지 마시오. 분석, 설계, 그 다음에 구현이오.</p>\n<p><strong>낯선 자:</strong> 예.</p>\n<p><strong>병:</strong> 셋째, 중간중간 확인하시오. 인공지가 틀린 방향으로 가면 바로 &quot;아니다&quot; 하고 잡아주시오.</p>\n<p><strong>낯선 자:</strong> <em>(고개를 끄덕이다가 살짝 멈칫)</em> ...예.</p>\n<hr>\n<h3 id=\"잠시-침묵이-흐른다\">[잠시 침묵이 흐른다]</h3>\n<hr>\n<p><strong>낯선 자:</strong> <em>(조심스럽게)</em> 어르신, 그것은... 소인도 익히 들어 알고 있는 이야기이옵니다.</p>\n<p><strong>병:</strong> 그렇소?</p>\n<p><strong>낯선 자:</strong> 예. 쪼개서 시켜라, 설계 먼저 해라, 확인하며 가라... 요즘 어디서나 하는 이야기이옵니다.</p>\n<hr>\n<p><strong>낯선 자:</strong> <em>(눈을 반짝이며)</em> 그래서 소인이 정말 궁금한 것은... 실제로는 어찌 쓰고 계시냐는 것이옵니다.</p>\n<p><strong>병:</strong> 실제로?</p>\n<p><strong>낯선 자:</strong> 예. 어르신 같은 분은 필시 대단한 자동화를 하고 계실 것 아니옵니까. 코드리뷰를 인공지가 알아서 해준다든지, 명령 한 번에 기능이 뚝딱 나온다든지...</p>\n<p><strong>낯선 자:</strong> <em>(기대에 찬 목소리로)</em> 소인은 그것이 너무 궁금하옵니다.</p>\n<hr>\n<h3 id=\"병-잠시-말이-없다\">[병, 잠시 말이 없다]</h3>\n<hr>\n<p><strong>낯선 자:</strong> 어르신은 코드리뷰 자동화 같은 것은 안 하시옵니까?</p>\n<p><strong>병:</strong> 해봤소. 되긴 되는데 품질이 좋지 않소. 노이즈가 많아서 되려 피곤하오.</p>\n<p><strong>낯선 자:</strong> 아...</p>\n<p><strong>병:</strong> 그래서 자동으로 돌리지는 않고, 필요할 때 한 번씩 돌려서 참고만 하오.</p>\n<hr>\n<p><strong>낯선 자:</strong> 에이전트 코딩은요? 명령 한 번에 알아서 짜주는 것.</p>\n<p><strong>병:</strong> 해봤소. 처음에는 좋았소. 간단한 기능은 뚝딱 나왔소.</p>\n<p><strong>낯선 자:</strong> 오...</p>\n<p><strong>병:</strong> 그런데 코드가 쌓이면 임계점이 오오. 맥락이 길어지면 인공지가 앞에서 뭘 했는지 까먹소.</p>\n<p><strong>병:</strong> 앞에서 만든 것과 뒤에서 만든 것이 안 맞고, 고치라 하면 다른 데가 깨지오.</p>\n<p><strong>낯선 자:</strong> <em>(고개를 끄덕이며)</em> 그건... 소인도 겪었사옵니다...</p>\n<p><strong>병:</strong> 어느 순간이 오면 인공지도 손 못 대고, 사람도 손 못 대오.</p>\n<p><strong>병:</strong> 개발하다가 하던 사람이 떠나면 막막한 것 있지 않소? 그것과 똑같소.</p>\n<hr>\n<p><strong>낯선 자:</strong> 아... 그러면 어르신은 어찌 타개하고 계시옵니까?</p>\n<p><strong>병:</strong> 결국 작게 만드는 수밖에 없소.</p>\n<p><strong>낯선 자:</strong> 작게요?</p>\n<p><strong>병:</strong> 모듈화(模組化)하는 거요. 입력과 출력만 정해놓고 안은 인공지한테 채우게 하는 거요.</p>\n<p><strong>병:</strong> 한번 만들어서 동작하면 그 안은 안 건드리오. 블록 쌓듯이 조립만 하는 거요.</p>\n<p><strong>낯선 자:</strong> <em>(고개를 끄덕이며)</em> 그건 저도 비슷하게 하고 있사옵니다...</p>\n<p><strong>병:</strong> 그렇겠지.</p>\n<hr>\n<p><strong>병:</strong> 리팩토링도 시켜봤소.</p>\n<p><strong>낯선 자:</strong> 어떠하셨사옵니까?</p>\n<p><strong>병:</strong> 문제가 있소. 인공지가 코드를 직접 고치면 전부 다 봐야 하오.</p>\n<p><strong>병:</strong> 인공지는 리팩토링을 하는 게 아니라 글자를 수정하는 거요. 내가 원하는 방향이 있는데, 딴 데를 건드리기도 하고, 예상 못 한 문제가 생기오.</p>\n<p><strong>낯선 자:</strong> 아...</p>\n<p><strong>병:</strong> 그래서 방법을 바꿨소. 인공지한테 직접 고치라 하지 않고, 리팩토링 스크립트를 짜라고 시켰소.</p>\n<p><strong>병:</strong> 티에스몰프(TS模法)라는 코드 변환 도구가 있는데, 그걸 써서 &quot;이 패턴을 찾아서 이렇게 바꾸는 스크립트 만들어라&quot; 하고.</p>\n<p><strong>낯선 자:</strong> 오...</p>\n<p><strong>병:</strong> 정적 도구는 원래 문제를 안 일으키오. 규칙대로만 바꾸니까.</p>\n<p><strong>낯선 자:</strong> <em>(고개를 끄덕이며)</em> 아, 직접 고치게 하지 않고 도구를 만들게 하는 거요...</p>\n<p><strong>병:</strong> 그렇소. 근데 그것도 일회용이오. 다음에 비슷한 걸 시키면 또 처음부터 만들어야 하오.</p>\n<p><strong>낯선 자:</strong> 아... 그렇습니까...</p>\n<hr>\n<p><strong>병:</strong> 그래서 결국 주로 쓰는 건... 하면 좋다고 하는데 못하던 것들이오.</p>\n<p><strong>낯선 자:</strong> 하면 좋다고 하는데 못하던 것들이요?</p>\n<p><strong>병:</strong> 테스트 코드. 컨벤션 정리. 순환 의존 탐지. 리팩토링 제안서 받기.</p>\n<p><strong>병:</strong> 같은 의미인데 이름 다르게 쓰는 변수 찾아내기. 그런 소소한 분석도구들.</p>\n<p><strong>낯선 자:</strong> <em>(눈이 커지며)</em> 오, 그런 것도 시키시옵니까?</p>\n<p><strong>병:</strong> 시키오. 디자인 토큰 정리할 때도 시키고. API 표준화할 때도 시키고.</p>\n<p><strong>병:</strong> 새 라이브러리 붙일 때 예제 코드 달라 하는 것도 시키오.</p>\n<p><strong>병:</strong> 메인 업무 전에 물어보고 실험하고 확인해보는 거. 그건 이제 생활이 됐소.</p>\n<p><strong>병:</strong> 다만 아직 믿고 맡기지는 못하오. 참고하고 확인하고 고치는 거요.</p>\n<hr>\n<h3 id=\"잠시-침묵\">[잠시 침묵]</h3>\n<hr>\n<p><strong>낯선 자:</strong> 어르신, 한 가지 여쭤봐도 되겠사옵니까.</p>\n<p><strong>병:</strong> 그러시오.</p>\n<p><strong>낯선 자:</strong> 어르신이 말씀하신 것들... 쪼개서 시켜라, 설계 먼저 해라, 확인하며 가라...</p>\n<p><strong>낯선 자:</strong> 그건 결국... 일 잘하는 법 아니옵니까?</p>\n<p><strong>낯선 자:</strong> 인공지가 특별한 게 아니라... 원래 일을 그렇게 해야 하는 것 아니옵니까?</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 멈칫하다가)</em> ...그렇소.</p>\n<p><strong>낯선 자:</strong> 예?</p>\n<p><strong>병:</strong> 그렇소. 사람한테 일 시킬 때도 그래야 하오. 쪼개서 시키고, 설계 먼저 하고, 확인하며 가고.</p>\n<p><strong>병:</strong> 다만 인공지는 불평을 안 하고, 밤새 시켜도 되고, 백 번을 물어봐도 짜증을 안 내오.</p>\n<p><strong>병:</strong> 그 정도 차이요.</p>\n<hr>\n<p><strong>낯선 자:</strong> <em>(조용히)</em> 그 정도... 차이...</p>\n<p><strong>병:</strong> ...</p>\n<p><strong>낯선 자:</strong> <em>(일어서며)</em> 어르신, 말씀 감사하옵니다.</p>\n<p><strong>낯선 자:</strong> <em>(고개를 숙이며)</em> ...소인이 많은 것을 기대했나 봅니다.</p>\n<p><strong>낯선 자:</strong> 그래도 뵙게 되어 영광이었사옵니다.</p>\n<hr>\n<h3 id=\"낯선-자-퇴장\">[낯선 자, 퇴장]</h3>\n<hr>\n<h3 id=\"병-홀로-남아-술잔을-바라본다\">[병, 홀로 남아 술잔을 바라본다]</h3>\n<hr>\n<p><strong>병:</strong> <em>(한참을 가만히 있다가)</em> ...</p>\n<p><strong>병:</strong> <em>(술을 따르며)</em> 많은 것을 기대했다...</p>\n<p><strong>병:</strong> <em>(혼잣말)</em> 나도 그랬소. 처음엔 나도 그랬소.</p>\n<hr>\n<p><strong>병:</strong> <em>(술을 마시며)</em> ...틀린 말이 아니오. 그게 다였소.</p>\n<hr>\n<h3 id=\"잠시-후-누군가-자리에-앉는다\">[잠시 후, 누군가 자리에 앉는다]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(평복 차림으로)</em> 무거운 얼굴이구나.</p>\n<p><strong>병:</strong> <em>(놀라며)</em> 전하...! 어인 일로 이런 곳에...</p>\n<p><strong>왕:</strong> 민심을 살피러 나왔다가 그대가 보이길래. 무슨 일이냐?</p>\n<hr>\n<p><strong>병:</strong> 전하, 소인이 가르침을 청하러 온 자를 만났사옵니다. 소인이 아는 것을 다 말해주었는데...</p>\n<p><strong>병:</strong> 실망하고 갔사옵니다. &quot;그게 다냐&quot;, &quot;뻔한 이야기 아니냐&quot;하고.</p>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 그래서 그대가 찜찜한 것이구나.</p>\n<p><strong>병:</strong> 그러하옵니다. 소인이 십오 년을 일했는데... 고작 그 정도밖에 말해줄 것이 없었사옵니다.</p>\n<hr>\n<h3 id=\"왕-술을-한-잔-따른다\">[왕, 술을 한 잔 따른다]</h3>\n<hr>\n<p><strong>왕:</strong> 과인이 어렸을 적 이야기를 해주겠다.</p>\n<p><strong>왕:</strong> 선왕께서 과인에게 삶은 달걀을 주시며 말씀하셨다. &quot;이것을 세워 보거라.&quot;</p>\n<p><strong>병:</strong> 달걀을 세우라...</p>\n<p><strong>왕:</strong> 과인이 얼마나 애를 썼는지 아느냐? 이리 굴리고 저리 굴리고. 반나절을 끙끙댔다.</p>\n<p><strong>병:</strong> 어찌 되었사옵니까?</p>\n<p><strong>왕:</strong> 안 됐다. 못하겠다고, 답을 알려달라 했다.</p>\n<hr>\n<p><strong>왕:</strong> 선왕께서 보여주신 답은... 허망했다.</p>\n<p><strong>병:</strong> 무엇이었사옵니까?</p>\n<p><strong>왕:</strong> 껍질을 조금 깨고 세우는 것이었다.</p>\n<hr>\n<p><strong>병:</strong> ...</p>\n<p><strong>왕:</strong> 과인이 따졌다. &quot;아바마마, 그렇게 하면 안 되는 것 아니옵니까?&quot;</p>\n<p><strong>왕:</strong> 선왕께서 뭐라 하셨는지 아느냐?</p>\n<hr>\n<p><strong>왕:</strong> &quot;안 된다고 한 적 없지 않느냐.&quot;</p>\n<hr>\n<p><strong>왕:</strong> 알고 나면 너무 당연하다. &quot;에이, 그것도 답이냐?&quot;싶다.</p>\n<p><strong>왕:</strong> 그런데 모르면... 생각조차 못 한다.</p>\n<hr>\n<p><strong>왕:</strong> 그대가 말한 것들. 쪼개서 시켜라, 설계 먼저 해라, 확인하며 가라.</p>\n<p><strong>왕:</strong> 듣고 나면 당연하다. 그런데 모르는 자는 그것을 생각조차 못 한다.</p>\n<hr>\n<p><strong>왕:</strong> 그대가 처음 근정전에 왔을 때, 갑과 을이 어찌했느냐?</p>\n<p><strong>병:</strong> 한꺼번에 시켰사옵니다. 구현부터 시켰사옵니다.</p>\n<p><strong>왕:</strong> 그대가 하는 것을 본 후에는?</p>\n<p><strong>병:</strong> ...따라 했사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 아는 자에게는 당연하다. 그러나 모르는 자에게는 보이지 않는 문이다.</p>\n<p><strong>왕:</strong> 뻔한 이야기라도 퍼뜨리는 것이 도움이 된다. 그대 덕에 갑과 을이 달라지지 않았느냐.</p>\n<hr>\n<p><strong>병:</strong> 전하, 그러나 소인도... 껍질을 못 깨고 있는 것은 아닌지 모르겠사옵니다.</p>\n<p><strong>왕:</strong> 무슨 말이냐?</p>\n<p><strong>병:</strong> 소인이 아는 것이 전부가 아닐 수 있사옵니다.</p>\n<p><strong>병:</strong> 다른 이들은 소인이 상상도 못 하는 방법으로 쓰고 있을 수도 있사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 좋은 고민이다.</p>\n<p><strong>왕:</strong> 자기가 갇혀 있을 수 있다고 생각하는 것. 그것이 갇히지 않는 방법이다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(일어서며)</em> 병. 그대가 아는 것을 계속 퍼뜨려라. 뻔한 이야기라도.</p>\n<p><strong>왕:</strong> 그리고 그대가 모르는 것을 계속 찾아라. 그것이면 된다.</p>\n<p><strong>병:</strong> <em>(고개를 숙이며)</em> 명심하겠사옵니다.</p>\n<hr>\n<h3 id=\"왕-퇴장\">[왕, 퇴장]</h3>\n<hr>\n<h3 id=\"병-홀로-남아-술잔을-바라본다-1\">[병, 홀로 남아 술잔을 바라본다]</h3>\n<hr>\n<p><strong>병:</strong> <em>(혼잣말)</em> 껍질을 깨고 세우는 것... 알고 나면 당연하고, 모르면 생각조차 못 하는 것...</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 생각에 잠기다가)</em> 잠깐.</p>\n<p><strong>병:</strong> 내가 아까 저 자에게 뭐라 했더냐. 에이전트 코딩, 안 됐다. 코드리뷰 자동화, 안 됐다.</p>\n<p><strong>병:</strong> <em>(쓴웃음)</em> 예전에 해봤는데 안 되더라... 그래서 포기했다?</p>\n<hr>\n<p><strong>병:</strong> <em>(술잔을 내려놓으며)</em> 인공지로 안 되는 게 없다고 생각하라. 내가 그리 말했거늘.</p>\n<p><strong>병:</strong> 나 스스로는... 안 된다고 선을 긋고 있었구나.</p>\n<hr>\n<h3 id=\"병-품에서-작은-기계를-꺼낸다\">[병, 품에서 작은 기계를 꺼낸다]</h3>\n<hr>\n<p><strong>병:</strong> <em>(인공지에게)</em> 요즘 다른 술사들은 인공지를 어찌 쓰고 있느냐? 내가 모르는 방법이 있느냐?</p>\n<hr>\n<p><strong>인공지:</strong> 최근에는 에이전특 코딩이라 하여, 인공지가 스스로 계획을 세우고 실행하고 수정하는 방식이 나왔습니다.</p>\n<p><strong>인공지:</strong> 엠시피(MCP)라 하여, 깃허브, 슬랙, 데이터베이스 등에 인공지가 직접 접속하는 규약이 있습니다.</p>\n<p><strong>인공지:</strong> 멀티 에이전특이라 하여, 여러 인공지가 역할을 나눠 협업하는 방식도 있습니다.</p>\n<p><strong>인공지:</strong> 컨텍스특 엔지니어링이라 하여, 인공지에게 무엇을 보여주고 무엇을 가릴지 설계하는—</p>\n<hr>\n<p><strong>병:</strong> <em>(끊으며)</em> 잠깐.</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 가만히 있다가)</em></p>\n<p><strong>병:</strong> <em>(피식 웃으며)</em> ...내가 또 모르는 것을 모르고 있었구나.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 설명 말고... 직접 보여줘라.</p>\n<hr>\n<h3 id=\"막-내림-1\">[막 내림]</h3>\n<hr>\n<p><strong>- 1부 완 -</strong></p>\n<hr>\n<hr>\n<h2 id=\"2부-예고-馭-어거할-어\">2부 예고: 馭 (어거할 어)</h2>\n<hr>\n<p><strong>병:</strong> 에이전특 코딩이라는 걸 써봤다. 됐다.</p>\n<p><strong>을:</strong> 축하—</p>\n<p><strong>병:</strong> 소인이 코드를 한 줄도 안 짰다.</p>\n<p><strong>을:</strong> ...예?</p>\n<p><strong>병:</strong> <em>(웃는 건지 모를 표정으로)</em> 한 줄도.</p>\n<hr>\n<p><strong>갑:</strong> 엠시피라는 것을 연결했더니 인공지가 깃허브도, 슬랙도 직접 읽사옵니다!</p>\n<p><strong>갑:</strong> <em>(표정이 굳으며)</em> ...근데 선배. 인공지가 깃허브에 코드를 직접 올려놓았사옵니다. 소인이 시키지 않았사옵니다.</p>\n<p><strong>병:</strong> 뭘 올렸느냐?</p>\n<p><strong>갑:</strong> ...소인도 아직 못 읽었사옵니다.</p>\n<hr>\n<p><strong>을:</strong> 멀티 에이전특! 인공지 셋이 짜고, 리뷰하고, 테스트하옵니다!</p>\n<p><strong>을:</strong> ...짜는 놈이 고친 것을 리뷰하는 놈이 되돌리옵니다. 밤새 돌았는데 제자리이옵니다.</p>\n<p><strong>을:</strong> 누가 맞사옵니까?!</p>\n<hr>\n<p><strong>왕:</strong> 바이브 코딩이라 하여, 코드를 모르는 백성도 만들어낸다 하더라. 그자와 그대의 차이가 무엇이냐?</p>\n<p><strong>병:</strong> 전하, 컨텍스특 엔지니어링이라는—</p>\n<p><strong>왕:</strong> <em>(끊으며)</em> 기술 이름 말고. 그대 생각을 말하라.</p>\n<p><strong>병:</strong> <em>(긴 침묵)</em></p>\n<hr>\n<p><strong>왕:</strong> <strong>코드를 짜지 않는 자가, 무엇으로 술사인가?</strong></p>\n<hr>\n<p><em>- 이 이야기가 나올 때쯤, 위의 이야기는 이미 낡아있을지도 모른다. -</em></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@teo/%EC%A1%B0%EC%84%A0%EA%B0%9C%EB%B0%9C%EC%8B%A4%EB%A1%9D-1%EB%B6%80-%EC%A0%9C8%ED%99%94-%EC%9C%A0%EC%88%98%EB%B6%88%EB%B6%80-%E6%B5%81%E6%B0%B4%E4%B8%8D%E8%85%90"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "조선개발실록 - 제6화: 기룡지술 (騎龍之術)",
    "partialText": "<h1 id=\"제6화-기룡지술-騎龍之術\">제6화: 기룡지술 (騎龍之術)</h1>\n<h2 id=\"용을-부리는-자-용을-아는-자\">&quot;용을 부리는 자, 용을 아는 자&quot;</h2>\n<hr>\n<h3 id=\"밤늦은-편전-술상이-놓여있다\">[밤늦은 편전, 술상이 놓여있다]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(병을 부르며)</em> 병, 오늘은 공식 보고 말고 술이나 한잔하자.</p>\n<p><strong>병:</strong> 전하, 영광이옵니다.</p>\n<p><strong>왕:</strong> 편하게 앉아라. 오늘은 격식 차리지 말고.</p>\n<hr>\n<p><strong>왕:</strong> <em>(술잔을 건네며)</em> 과인이 요즘 생각이 많다.</p>\n<p><strong>병:</strong> 무슨 생각이시옵니까?</p>\n<hr>\n<p><strong>왕:</strong> 인공지라는 것 말이다.</p>\n<p><strong>왕:</strong> 처음에는 그저 신기한 물건인 줄 알았다. 명을 내리면 글을 써주고 코드를 짜주는.</p>\n<p><strong>왕:</strong> 그런데 칠 주를 보니... 이것이 단순한 도구가 아니로구나.</p>\n<hr>\n<p><strong>병:</strong> 어찌 그리 생각하시옵니까?</p>\n<p><strong>왕:</strong> 호패관리체계가 터졌을 때, 과인은 인공지가 문제라 생각했다.</p>\n<p><strong>왕:</strong> 그런데 지금 보니... 인공지가 문제가 아니라, <strong>인공지를 어찌 쓰느냐</strong>가 문제였다.</p>\n<hr>\n<p><strong>왕:</strong> 같은 인공지를 줘도 갑은 엉망을 만들고, 그대는 제대로 만든다.</p>\n<p><strong>왕:</strong> 그 차이가 뭐냐? 과인이 알고 싶다.</p>\n<hr>\n<p><strong>왕:</strong> 그대가 인공지를 어떻게 쓰는지, 과인한테 솔직히 말해보라.</p>\n<hr>\n<h3 id=\"병의-방식\">[병의 방식]</h3>\n<hr>\n<p><strong>병:</strong> <em>(술을 받으며)</em> 전하, 소인도 처음에는 &quot;코드 짜줘&quot;만 시켰사옵니다.</p>\n<p><strong>왕:</strong> 그래, 다들 그러하지 않겠느냐.</p>\n<hr>\n<p><strong>병:</strong> 그런데 어느 날, 남의 코드를 받았는데 도무지 맥락을 모르겠사옵니다.</p>\n<p><strong>병:</strong> 예전 같으면 문서 뒤지고, 선임한테 물어보고, 반나절은 걸렸을 것이옵니다.</p>\n<p><strong>병:</strong> 그래서 혹시나 하고 인공지한테 물어보았사옵니다. &quot;이게 뭐냐? 왜 이렇게 짰느냐?&quot;</p>\n<p><strong>병:</strong> ...설명해주옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 오.</p>\n<p><strong>병:</strong> 그때부터 생각이 달라졌사옵니다. 이것이 코드만 짜는 게 아니구나.</p>\n<hr>\n<p><strong>병:</strong> 그래서 분석도 시켜보았사옵니다. &quot;이 코드 책임이 몇 개냐, 의존성이 어찌 되어있느냐.&quot;</p>\n<p><strong>병:</strong> 정리해주옵니다. 소인은 그것을 보고 판단만 하면 되었사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 제안도 해보게 하였사옵니다. &quot;방법 세 가지 내봐라, 장단점 비교해라.&quot;</p>\n<p><strong>병:</strong> 하나만 시키면 맞는지 틀린지 알 길이 없사온데, 여러 개 놓고 보니 비교가 되옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 또 있느냐?</p>\n<p><strong>병:</strong> 검증도 시켜보았사옵니다. &quot;네가 짠 이 코드, 문제 있는지 봐라.&quot;</p>\n<p><strong>병:</strong> 자기가 짠 것에서 자기가 문제를 찾아내옵니다.</p>\n<p><strong>왕:</strong> 자기가 틀린 것도 아느냐?</p>\n<p><strong>병:</strong> 물으면 찾아내옵니다. 안 물으면 그냥 넘어가옵니다.</p>\n<hr>\n<p><strong>병:</strong> 테스트도 가능하옵니다. &quot;어떤 경우에 깨지겠느냐?&quot; 물었더니</p>\n<p><strong>병:</strong> 사람이 미처 생각 못 한 케이스를 뽑아내옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 분석, 설명, 제안, 검증, 테스트... 그것이 다 되느냐.</p>\n<p><strong>왕:</strong> &quot;코드 짜줘&quot;만 시키면 일부만 쓰는 것이구나.</p>\n<p><strong>병:</strong> 소인도 해보고서야 알았사옵니다.</p>\n<hr>\n<h3 id=\"사람의-몫\">[사람의 몫]</h3>\n<hr>\n<p><strong>왕:</strong> 그러면 인공지가 그리 많은 것을 해주면... 사람은 뭘 하느냐?</p>\n<hr>\n<p><strong>병:</strong> 전하, 인공지가 내놓은 것을 보고 맞는지 틀린지 가리는 것이옵니다.</p>\n<p><strong>병:</strong> 그럴듯하게 틀릴 때가 있사옵니다.</p>\n<p><strong>병:</strong> 틀리면 &quot;아니다&quot; 하고 잡아줘야 하옵니다. 인공지는 관성이 있어서, 틀린 방향으로 가면 계속 가옵니다.</p>\n<hr>\n<p><strong>병:</strong> 여러 제안 중에 고르는 것도 사람 몫이옵니다.</p>\n<p><strong>병:</strong> 우리 프로젝트 사정, 우리 팀 역량, 우리 일정... 이것은 사람만 아옵니다.</p>\n<hr>\n<p><strong>병:</strong> 그리고 최종 책임은 사람이 지는 것이옵니다.</p>\n<p><strong>병:</strong> 인공지가 잘못해도 &quot;인공지 탓이옵니다&quot;라고 할 수 없사옵니다.</p>\n<p><strong>병:</strong> 그것을 검토하고 쓰기로 한 것은 사람이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 도구는 도구일 뿐, 쓰는 자의 책임이라...</p>\n<p><strong>병:</strong> 그러하옵니다.</p>\n<hr>\n<h3 id=\"병의-고백\">[병의 고백]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(술을 따르며)</em> 그대 말을 들으니 인공지를 잘 부리는 것 같구나.</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 침묵하다가)</em> 전하, 솔직히 아뢰겠사옵니다.</p>\n<p><strong>병:</strong> 소인도... 길을 찾고 있는 중이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 무슨 말이냐?</p>\n<hr>\n<p><strong>병:</strong> 지난 경연에서 갑과 을한테 배웠사옵니다.</p>\n<p><strong>병:</strong> 소인은 십오 년을 일했사옵니다. 그런데 갑의 질문 하나에 길이 열렸사옵니다.</p>\n<p><strong>병:</strong> &quot;그것도 인공지한테 시키면 안 돼?&quot;라는.</p>\n<hr>\n<p><strong>왕:</strong> 워크플로 말이구나.</p>\n<p><strong>병:</strong> 그러하옵니다. 소인은 파라이라이특을 알고 있었사옵니다.</p>\n<p><strong>병:</strong> 그런데 그것으로 저 문제를 해결할 생각을 못 했사옵니다.</p>\n<p><strong>병:</strong> 소인도 익숙함에 갇혀있었사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 그래, 지난번에 그랬지.</p>\n<hr>\n<p><strong>병:</strong> 전하, 예전에는 인공지가 보조수단이었사옵니다.</p>\n<p><strong>병:</strong> 모르는 것 물어보고, 간단한 코드 짜달라 하고.</p>\n<p><strong>병:</strong> 본업은 여전히 사람이 했사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 그런데 갑과 을이 만든 것을 보니...</p>\n<p><strong>병:</strong> 코드 짜고, 실행하고, 에러 나면 고치고, 다시 실행하고...</p>\n<p><strong>병:</strong> 사람은 처음에 시키고 마지막에 확인만 했사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 이것은... 보조수단이 아니옵니다.</p>\n<p><strong>병:</strong> 정말로 인공지가 개발을 하는 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> ...</p>\n<hr>\n<p><strong>병:</strong> 소인이 십오 년간 익힌 방법이... 어쩌면 이미 낡은 것일 수도 있사옵니다.</p>\n<p><strong>병:</strong> 솔직히 아직 모르겠사옵니다.</p>\n<p><strong>병:</strong> 완전히 새로운 방법을 찾아가는 중이옵니다.</p>\n<hr>\n<h3 id=\"왕의-격려\">[왕의 격려]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(술잔을 내려놓으며)</em> 병, 괜찮다.</p>\n<hr>\n<p><strong>병:</strong> 전하?</p>\n<hr>\n<p><strong>왕:</strong> 그대가 모른다고 하니 오히려 믿음이 간다.</p>\n<p><strong>왕:</strong> 세상이 이리 빠르게 변하는데, &quot;다 압니다&quot;하는 자가 더 걱정이다.</p>\n<hr>\n<p><strong>왕:</strong> 과인도 모른다. 인공지 시대에 나라를 어찌 이끌어야 하는지.</p>\n<p><strong>왕:</strong> 그래서 그대들한테 묻고 있는 것이다.</p>\n<hr>\n<p><strong>병:</strong> <em>(고개를 숙이며)</em> 황송하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 고개 들어라. 오늘은 격식 없다 했다.</p>\n<p><strong>왕:</strong> <em>(술을 따르며)</em> 그대 생각을 더 듣고 싶다.</p>\n<hr>\n<h3 id=\"인재상의-변화\">[인재상의 변화]</h3>\n<hr>\n<p><strong>왕:</strong> 과인이 결국 해야 할 일은 과거시험을 바꾸는 것이다.</p>\n<p><strong>왕:</strong> 인공지 시대에 맞는 인재를 뽑아야 한다.</p>\n<hr>\n<p><strong>왕:</strong> 그대 생각에... 인재상이 어떻게 달라져야 하겠느냐?</p>\n<hr>\n<p><strong>병:</strong> <em>(술잔을 내려놓으며)</em> 전하, 십오 년을 돌아보니... 꼭 말씀드리고 싶은 것이 있사옵니다.</p>\n<p><strong>왕:</strong> 말해보라.</p>\n<hr>\n<p><strong>병:</strong> 예전에는 한 우물을 파라 했사옵니다. 하나를 깊이 아는 것이 힘이었사옵니다.</p>\n<p><strong>병:</strong> 그런데 인공지가 깊은 것을 대신 파주옵니다.</p>\n<p><strong>병:</strong> 그러하니 사람은... 어디를 파야 할지를 아는 것이 더 중요해졌사옵니다.</p>\n<p><strong>병:</strong> 넓게 봐야 어디가 핵심인지 보이옵니다.</p>\n<p><strong>왕:</strong> 지도를 먼저 그려야 한다는 말이구나.</p>\n<hr>\n<p><strong>병:</strong> 그러하옵니다. 그리고 그 지도를 그리려면 이름을 알아야 하옵니다.</p>\n<p><strong>병:</strong> 첫날 배웠사옵니다. 이름을 알아야 부를 수 있다고.</p>\n<p><strong>병:</strong> 인공지한테도 마찬가지옵니다. &quot;그거 있잖아, 그거...&quot;로는 물어볼 수가 없사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 그리고 전하, 소인이 가장 크게 느끼는 것이 있사옵니다.</p>\n<p><strong>병:</strong> 인공지가 써주는 시대에... 읽는 힘이 중요해졌사옵니다.</p>\n<p><strong>왕:</strong> 읽는 힘?</p>\n<p><strong>병:</strong> 예전에는 직접 썼사옵니다. 내가 쓴 것은 내가 알았사옵니다.</p>\n<p><strong>병:</strong> 지금은 인공지가 쏟아내는 것을 읽고 판단해야 하옵니다.</p>\n<p><strong>병:</strong> 코드를 잘 쓰는 것보다... 코드를 잘 읽는 것이 더 어려운 시대가 되었사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 계속해보라.</p>\n<hr>\n<p><strong>병:</strong> 빠르게 고르는 것도 중요해졌사옵니다.</p>\n<p><strong>병:</strong> 인공지가 선택지를 쏟아내옵니다. 빨리 골라야 하옵니다. 안 고르면 멈추옵니다.</p>\n<p><strong>병:</strong> 그리고 예전에는 안 될 것 같으면 포기했사옵니다. 삽질할 시간이 아까웠사옵니다.</p>\n<p><strong>병:</strong> 지금은 인공지가 도와주니 일단 시작해볼 수 있사옵니다. 될 확률이 달라졌사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 구현은 인공지가 해주옵니다. 그러하니 설계가 차별화가 되었사옵니다.</p>\n<p><strong>병:</strong> 둘째 날 배웠사옵니다. 주춧돌이 먼저라고.</p>\n<p><strong>병:</strong> 서툰 설계를 인공지한테 주면 서툰 결과가 나오옵니다.</p>\n<hr>\n<p><strong>병:</strong> 전하, 그리고 이것은 꼭 아뢰고 싶사옵니다.</p>\n<p><strong>병:</strong> 인공지는 맥락을 모르옵니다.</p>\n<p><strong>병:</strong> &quot;만들어줘&quot; 하면 만들어주옵니다. 그것이 정말 필요한지, 왜 필요한지는 모르옵니다.</p>\n<p><strong>병:</strong> 맥락은 사람만 갖고 있사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 그리고... 내가 뭘 모르는지 아는 것이옵니다.</p>\n<p><strong>병:</strong> 인공지한테 물으면 바로 답이 나오옵니다. 그런데 모르는 것을 모르면 물어보지를 않사옵니다.</p>\n<p><strong>왕:</strong> 갑이 그랬지. 뭔가 이상한 건 알았는데 뭐가 이상한지 몰랐다.</p>\n<p><strong>병:</strong> 그러하옵니다.</p>\n<hr>\n<p><strong>병:</strong> 끝으로... 안목이옵니다, 전하.</p>\n<p><strong>병:</strong> 인공지가 기능은 다 만들어주옵니다. 그러면 차별화는 품질에서 오옵니다.</p>\n<p><strong>병:</strong> &quot;이게 더 낫다&quot;를 고를 수 있는 눈. 그것이 안목이옵니다.</p>\n<p><strong>왕:</strong> 안목은 어찌 기르느냐?</p>\n<p><strong>병:</strong> 좋은 것을 많이 보면 되옵니다.</p>\n<p><strong>병:</strong> 예전에는 기능 만드느라 볼 시간이 없었사옵니다. 지금은 인공지 덕에 그 시간이 생겼사옵니다.</p>\n<p><strong>병:</strong> 그 시간을 어찌 쓰느냐가... 갈림길이 될 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 결국... 인공지가 바꾼 것은 기술이 아니라, 사람을 보는 눈이구나.</p>\n<p><strong>왕:</strong> 예전에는 잘 만드는 자를 찾았다. 이제는 잘 부리고, 잘 읽고, 잘 고르는 자를 찾아야 한다.</p>\n<hr>\n<h3 id=\"술사의-가치\">[술사의 가치]</h3>\n<hr>\n<p><strong>왕:</strong> 과인이 하나 더 묻겠다.</p>\n<p><strong>왕:</strong> 인공지가 개발을 하는 시대가 온다면... 술사의 가치는 무엇이 되겠느냐?</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 생각하다가)</em> 전하, 인공지가 개발을 하는 것은 시대의 흐름이옵니다.</p>\n<p><strong>병:</strong> 막을 수 없사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그러면 술사는 필요 없어지느냐?</p>\n<hr>\n<p><strong>병:</strong> 아니옵니다, 전하.</p>\n<p><strong>병:</strong> 인공지의 시행착오 비용은... 싸면서도 비싸옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 싸면서도 비싸다?</p>\n<hr>\n<p><strong>병:</strong> 인공지는 빠르옵니다. 코드를 금방 짜옵니다. 틀리면 다시 짜옵니다.</p>\n<p><strong>병:</strong> 그래서 한 번의 시행착오는 싸옵니다.</p>\n<hr>\n<p><strong>병:</strong> 그러나 셋째 날 배웠사옵니다. 천리마의 역설.</p>\n<p><strong>병:</strong> 인공지는 앞으로 가는 것은 빠르나, 방향을 틀기는 어렵사옵니다.</p>\n<p><strong>병:</strong> 잘못된 방향으로 한참 가면... 돌아오는 비용이 비싸옵니다.</p>\n<hr>\n<p><strong>병:</strong> 호패관리체계가 그랬사옵니다.</p>\n<p><strong>병:</strong> 김진사가 인공지로 빠르게 만들었사옵니다.</p>\n<p><strong>병:</strong> 그러나 방향이 잘못되어 있었사옵니다.</p>\n<p><strong>병:</strong> 그것을 고치는 데 개발방 술사들이 밤을 새웠사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 아...</p>\n<hr>\n<p><strong>병:</strong> 술사의 가치는...</p>\n<p><strong>병:</strong> 그 비용을 아낄 수 있게 해주는 것이 아닐까 하옵니다.</p>\n<hr>\n<p><strong>병:</strong> 처음에 방향을 잘 잡아주는 것.</p>\n<p><strong>병:</strong> 중간에 잘못 가면 빨리 잡아주는 것.</p>\n<p><strong>병:</strong> 인공지가 내놓은 것을 보고 &quot;이건 아니다&quot;를 알아채는 것.</p>\n<hr>\n<p><strong>병:</strong> 인공지는 자기가 잘못 가는지 모르옵니다.</p>\n<p><strong>병:</strong> 술사가 알아야 하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 인공지가 달리는 것은 빠르나, 방향을 잡아주는 것은 사람 몫이다.</p>\n<p><strong>왕:</strong> 그것이 술사의 가치라...</p>\n<hr>\n<h3 id=\"배움의-의미\">[배움의 의미]</h3>\n<hr>\n<p><strong>왕:</strong> 그러면 하나 더 묻겠다.</p>\n<p><strong>왕:</strong> 인공지가 이리 많은 것을 해준다면... 개발을 배운다는 것은 이제 무슨 의미가 있느냐?</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 생각하다가)</em> 전하, 소인이 워크플로를 만들면서 깨달은 것이 있사옵니다.</p>\n<p><strong>병:</strong> 인공지한테 일을 시키려면... 내가 아는 것을 말로 풀어줘야 하옵니다.</p>\n<p><strong>병:</strong> 몸에 배어있는 것, 말 안 해도 되던 것... 그것을 글로 풀어 적어줘야 하옵니다.</p>\n<p><strong>왕:</strong> 암묵지를 명세화해야 한다?</p>\n<p><strong>병:</strong> 그러하옵니다. 그런데 전하, 그것을 적으려면... 먼저 알고 있어야 하옵니다.</p>\n<p><strong>병:</strong> 모르는 것은 적을 수가 없사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그렇겠구나.</p>\n<hr>\n<p><strong>병:</strong> 그리고 전하, 인공지는 스스로 생각하는 것이 아니옵니다.</p>\n<p><strong>병:</strong> 시키면 결과를 내놓되, 그 결과가 매번 같지 않사옵니다.</p>\n<p><strong>병:</strong> 어떨 때는 좋고, 어떨 때는 엉뚱하옵니다.</p>\n<p><strong>왕:</strong> 그러면?</p>\n<p><strong>병:</strong> 그 엉뚱함을 줄여가는 것이 술사의 일이옵니다.</p>\n<p><strong>병:</strong> 어찌 시켜야 좋은 결과가 나오는지, 나쁜 결과를 어찌 걸러내는지...</p>\n<p><strong>병:</strong> 이것은 알아야 할 수 있는 일이옵니다.</p>\n<hr>\n<p><strong>병:</strong> 그리고 전하, 한 가지 더 있사옵니다.</p>\n<p><strong>병:</strong> 인공지가 아무리 뛰어나더라도... 기존의 제도와 관습, 시스템을 갈아엎지는 못하옵니다.</p>\n<p><strong>왕:</strong> 무슨 뜻이냐?</p>\n<p><strong>병:</strong> 호패관리체계가 그러하옵니다.</p>\n<p><strong>병:</strong> 기존 체계가 어찌 되어있는지, 어떤 제도 위에 세워져 있는지...</p>\n<p><strong>병:</strong> 인공지가 새로 만들어줄 수는 있사옵니다. 그러나 기존 것과 어우러져야 하옵니다.</p>\n<p><strong>병:</strong> 기존 것을 모르면 어우러지게 할 수 없사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그러니까... 인공지가 아무리 뛰어나도, 부리는 자가 세상을 알아야 한다.</p>\n<hr>\n<p><strong>병:</strong> 그러하옵니다, 전하. 그래서 배움은 끝나지 않사옵니다.</p>\n<p><strong>병:</strong> 다만... 배움의 뜻이 달라졌사옵니다.</p>\n<p><strong>병:</strong> 예전에는 직접 하기 위해 배웠사옵니다.</p>\n<p><strong>병:</strong> 지금은... 인공지를 올바로 부리기 위해 배우옵니다.</p>\n<hr>\n<p><strong>왕:</strong> ...</p>\n<hr>\n<p><strong>병:</strong> 소인의 생각이옵니다. 틀릴 수도 있사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(웃으며)</em> 틀릴 수도 있다... 그 말이 좋구나.</p>\n<p><strong>왕:</strong> 확신에 찬 답보다 솔직한 고민이 낫다.</p>\n<hr>\n<h3 id=\"마무리\">[마무리]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(술잔을 들며)</em> 좋은 밤이었다. 과인이 많이 배웠다.</p>\n<p><strong>병:</strong> 소인도 말씀드리면서 정리가 되었사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 다음 주에 최종 결론을 내리겠다.</p>\n<p><strong>왕:</strong> 새로운 과거시험 제도를 어찌 할지.</p>\n<hr>\n<p><strong>왕:</strong> 오늘 이야기한 것... 과인 가슴에 담아두겠다.</p>\n<p><strong>병:</strong> 황송하옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 물러가 쉬어라.</p>\n<p><strong>병:</strong> 예, 전하. 안녕히 주무시옵소서.</p>\n<hr>\n<h3 id=\"막-내림\">[막 내림]</h3>\n<hr>\n<p><strong>- 제6화 끝 -</strong></p>\n<p><strong>다음 화: 최종화 - 새 과거시험</strong></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@teo/%EC%A1%B0%EC%84%A0%EA%B0%9C%EB%B0%9C%EC%8B%A4%EB%A1%9D-%EC%A0%9C6%ED%99%94-%EA%B8%B0%EB%A3%A1%EC%A7%80%EC%88%A0-%E9%A8%8E%E9%BE%8D%E4%B9%8B%E8%A1%93-l6pjn8jj"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "조선개발실록 - 제5화: 지행합일 (知行合一)",
    "partialText": "<h1 id=\"제5화-지행합일-知行合一\">제5화: 지행합일 (知行合一)</h1>\n<h2 id=\"아는-것과-행하는-것은-다르다\">&quot;아는 것과 행하는 것은 다르다&quot;</h2>\n<hr>\n<h3 id=\"경복궁-편전-경연-전-아침\">[경복궁 편전, 경연 전 아침]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(병만 들어와 있다)</em> 경연 전에 그대를 따로 불렀다.</p>\n<p><strong>병:</strong> 무슨 일이시옵니까, 전하.</p>\n<p><strong>왕:</strong> 과인이 그대한테 묻고 싶은 것이 있다.</p>\n<hr>\n<p><strong>왕:</strong> 인공지 시대에... 개발자는 어떤 자여야 하느냐? 그대 생각을 듣고 싶다.</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 생각하다가)</em> 전하, 옛말에 <strong>&quot;술사는 자고로 게을러야 한다&quot;</strong>는 말이 있사옵니다.</p>\n<p><strong>좌의정:</strong> <em>(놀라며)</em> 게으른 자를 어찌 쓰겠사옵니까!</p>\n<p><strong>영의정:</strong> 무슨 뜻인지 들어나 봅시다.</p>\n<hr>\n<p><strong>왕:</strong> 그래, 말해보라.</p>\n<p><strong>병:</strong> 그 말의 본뜻이 있사옵니다, 전하.</p>\n<hr>\n<h3 id=\"게으름의-본뜻\">[게으름의 본뜻]</h3>\n<hr>\n<p><strong>병:</strong> 좋은 술사는 반복 작업을 못 참사옵니다.</p>\n<p><strong>왕:</strong> 못 참는다?</p>\n<p><strong>병:</strong> 같은 일을 두 번 하기 싫어하옵니다. 그래서 자동화를 하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 예를 들어보라.</p>\n<p><strong>병:</strong> 배포(配布)할 때마다 같은 명령어 열 줄을 쳐야 하는 상황이라 하겠사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 부지런한 자는 어찌 하겠사옵니까?</p>\n<p><strong>왕:</strong> 열심히 치겠지.</p>\n<p><strong>병:</strong> 그러하옵니다. 매번 열 줄을 정확히, 빠르게, 실수 없이 치옵니다.</p>\n<hr>\n<p><strong>병:</strong> 게으른 자는 어찌 하겠사옵니까?</p>\n<p><strong>왕:</strong> 귀찮아하겠지.</p>\n<p><strong>병:</strong> 그러하옵니다. 귀찮아서 못 참사옵니다. 그래서 스크립트(命令帖)를 만드옵니다.</p>\n<p><strong>병:</strong> &quot;이 열 줄을 한 줄로 합쳐라&quot; 하고 인공지한테 시키옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그래서?</p>\n<p><strong>병:</strong> 그 다음부터는 한 줄만 치면 되옵니다.</p>\n<p><strong>병:</strong> 백 번 배포할 것을, 부지런한 자는 천 줄을 치고, 게으른 자는 백 줄만 치옵니다.</p>\n<hr>\n<p><strong>좌의정:</strong> 오... 결과는 게으른 자가 나았구나.</p>\n<p><strong>병:</strong> 그러하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그런데 부지런한 자도 스크립트를 만들면 되지 않느냐?</p>\n<p><strong>병:</strong> 전하, 그것이 함정이옵니다.</p>\n<p><strong>왕:</strong> 함정?</p>\n<hr>\n<p><strong>병:</strong> 부지런한 자는 반복 작업이 불편하지 않사옵니다.</p>\n<p><strong>병:</strong> 그냥 하면 되니까요. &quot;뭘 그런 걸 가지고 스크립트까지 만들어&quot;라고 생각하옵니다.</p>\n<p><strong>왕:</strong> 아...</p>\n<p><strong>병:</strong> 불편함을 못 느끼면 해결할 생각을 안 하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 부지런함이 오히려 발목을 잡는구나.</p>\n<p><strong>병:</strong> 그러하옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 잠깐. 그대 말을 들으니... 그냥 게으른 게 아니로구나.</p>\n<p><strong>왕:</strong> 불편하면 못 참고 해결하려 드는 것... 그것은 <strong>능동적인 게으름</strong>이 아니냐?</p>\n<p><strong>병:</strong> <em>(감탄하며)</em> 전하께서 정확히 짚으셨사옵니다.</p>\n<hr>\n<p><strong>영의정:</strong> 능동적인 게으름이라... 참 묘한 말이로다.</p>\n<hr>\n<h3 id=\"인공지는-욕망이-없다\">[인공지는 욕망이 없다]</h3>\n<hr>\n<p><strong>병:</strong> 전하, 한 가지 더 있사옵니다.</p>\n<p><strong>왕:</strong> 말해보라.</p>\n<p><strong>병:</strong> <strong>인공지는 욕망(慾望)이 없사옵니다.</strong></p>\n<p><strong>왕:</strong> 욕망?</p>\n<hr>\n<p><strong>병:</strong> 사람은 &quot;더 잘하고 싶다&quot;, &quot;더 깔끔하게 짜고 싶다&quot;는 욕심이 있사옵니다.</p>\n<p><strong>병:</strong> 장인정신(匠人精神)이라 하지요.</p>\n<p><strong>왕:</strong> 그렇지.</p>\n<hr>\n<p><strong>병:</strong> 인공지는 그런 것이 없사옵니다.</p>\n<p><strong>병:</strong> 돌아가는 코드를 주면 그것으로 만족하옵니다.</p>\n<p><strong>병:</strong> &quot;더 좋게 다듬어라&quot; 시키지 않으면 절대 먼저 안 하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 욕망이 없으니 발전도 없다?</p>\n<p><strong>병:</strong> 그러하옵니다. 사람의 욕망만큼만 움직이옵니다.</p>\n<hr>\n<p><strong>좌의정:</strong> 그러면 사람이 욕심을 가지고 부려야 한다는 말이로군요.</p>\n<p><strong>병:</strong> 정확하옵니다.</p>\n<hr>\n<h3 id=\"최악과-최고의-조합\">[최악과 최고의 조합]</h3>\n<hr>\n<p><strong>왕:</strong> 그러면 제일 안 좋은 조합이 뭐냐?</p>\n<p><strong>병:</strong> 수동적인 사람과 인공지이옵니다.</p>\n<p><strong>왕:</strong> 왜?</p>\n<p><strong>병:</strong> 둘 다 먼저 안 하옵니다.</p>\n<p><strong>병:</strong> 사람은 &quot;에이, 귀찮아&quot; 하고 가만있고, 인공지는 시키기 전까지 가만있고.</p>\n<p><strong>병:</strong> 아무 일도 안 일어나옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 제일 좋은 조합은?</p>\n<p><strong>병:</strong> 능동적인 사람과 인공지이옵니다.</p>\n<p><strong>병:</strong> 사람이 불편함을 느끼고, 해결책을 생각하고, 시키면, 인공지가 빠르게 해결하옵니다.</p>\n<p><strong>병:</strong> 최고의 조합이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 좋은 이야기를 들었다. 경연을 시작하자.</p>\n<hr>\n<h3 id=\"경복궁-근정전-경연\">[경복궁 근정전, 경연]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(갑, 을, 병이 도열해 있다)</em> 지난 경연에서 &quot;원래 그런 거&quot;를 의심하라 했다.</p>\n<p><strong>왕:</strong> 그리고 실제로 해결한 것을 찾아오라 했다.</p>\n<p><strong>왕:</strong> 무엇을 해왔느냐?</p>\n<hr>\n<h3 id=\"병의-보고\">[병의 보고]</h3>\n<hr>\n<p><strong>병:</strong> 전하, 소인은 테스트 코드 작성을 인공지한테 시켰사옵니다.</p>\n<p><strong>왕:</strong> 테스트 코드?</p>\n<p><strong>병:</strong> 그러하옵니다. 함수를 만들면 그에 맞는 테스트 코드를 짜라고 시켰사옵니다.</p>\n<p><strong>병:</strong> 잘 되옵니다. 테스트 커버리지(試驗 範圍)가 올라갔사옵니다.</p>\n<p><strong>왕:</strong> 좋구나.</p>\n<hr>\n<h3 id=\"갑과-을의-보고\">[갑과 을의 보고]</h3>\n<hr>\n<p><strong>왕:</strong> 갑, 을. 그대들은?</p>\n<p><strong>을:</strong> 전하, 소인들이 워크플로(臥剋浮漯)라는 것을 만들었사옵니다.</p>\n<p><strong>왕:</strong> 워크플로? 그것이 무엇이냐?</p>\n<p><strong>갑:</strong> 절차서(節次書)와 같은 것이옵니다. 인공지한테 시킬 일들을 미리 정해놓고, 순서대로 알아서 하게 만든 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 어떤 것을 만들었느냐?</p>\n<p><strong>을:</strong> 코드를 짜고, 실행하고, 에러가 나면 고치고, 다시 실행하고... 될 때까지 반복하는 것이옵니다.</p>\n<p><strong>을:</strong> 이제 소인들은 처음에 시키고, 마지막에 결과만 확인하면 되옵니다.</p>\n<p><strong>왕:</strong> 오호!</p>\n<hr>\n<h3 id=\"워크플로-탄생-과정\">[워크플로 탄생 과정]</h3>\n<hr>\n<p><strong>왕:</strong> 어찌 그런 생각을 했느냐?</p>\n<p><strong>을:</strong> 전하, 지난주에 &quot;찾아보라&quot; 하셨사옵니다.</p>\n<p><strong>을:</strong> 소인이 에러 긁어다 붙이는 게 귀찮아서 찾아봤사옵니다.</p>\n<p><strong>을:</strong> 근데 딱 맞는 게 없었사옵니다.</p>\n<hr>\n<p><strong>갑:</strong> 그래서 소인이 물었사옵니다. &quot;그것도 인공지한테 시키면 안 돼?&quot;라고.</p>\n<p><strong>을:</strong> 물어보니 된다 하였사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 오...</p>\n<p><strong>을:</strong> 근데 한 가지 문제가 있었사옵니다.</p>\n<p><strong>왕:</strong> 무엇이냐?</p>\n<p><strong>을:</strong> 브라우저(瀏覽器)에서 나는 에러는 인공지가 못 본다 하였사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그래서?</p>\n<p><strong>을:</strong> 소인은 &quot;그건 어쩔 수 없지&quot; 했사옵니다.</p>\n<p><strong>갑:</strong> 소인이 또 물었사옵니다. &quot;다른 방법 없어?&quot;라고.</p>\n<hr>\n<p><strong>왕:</strong> 인공지가 뭐라 하더냐?</p>\n<p><strong>갑:</strong> 파라이라이특(播羅以來特)이라는 것이 있다 하였사옵니다.</p>\n<p><strong>왕:</strong> 파라이라이특?</p>\n<p><strong>갑:</strong> 자동으로 브라우저를 띄우고, 화면을 확인하고, 에러가 나면 그것을 잡아낼 수 있는 도구라 하였사옵니다.</p>\n<hr>\n<p><strong>을:</strong> <em>(아직도 놀란 표정)</em> 그런 게 있었사옵니다, 전하!</p>\n<p><strong>을:</strong> 소인은 이 년이나 일했는데 몰랐사옵니다.</p>\n<hr>\n<h3 id=\"병의-침묵\">[병의 침묵]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(병을 바라보며)</em> 병, 그대는 이것을 알았느냐?</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 침묵)</em></p>\n<p><strong>병:</strong> 전하, 파라이라이특은 알고 있었사옵니다.</p>\n<p><strong>왕:</strong> 알고 있었다?</p>\n<p><strong>병:</strong> 그러하옵니다. 듣자마자 알겠사옵니다. 그것으로 되겠다는 것도.</p>\n<hr>\n<p><strong>왕:</strong> 그런데?</p>\n<p><strong>병:</strong> ...그것으로 이 문제를 해결할 생각을 못 했사옵니다.</p>\n<p><strong>병:</strong> 소인도 매번 에러를 긁어다 붙였사옵니다.</p>\n<p><strong>병:</strong> 그것이 당연하다 생각했사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 알면서도 쓸 생각을 못 했다?</p>\n<p><strong>병:</strong> 그러하옵니다, 전하.</p>\n<hr>\n<h3 id=\"병의-깨달음\">[병의 깨달음]</h3>\n<hr>\n<p><strong>병:</strong> <em>(쓴웃음)</em> 전하, 소인이 부끄럽사옵니다.</p>\n<p><strong>왕:</strong> 왜 그러느냐?</p>\n<hr>\n<p><strong>병:</strong> 소인이 아까 전하께 아뢰었사옵니다.</p>\n<p><strong>병:</strong> &quot;능동적인 게으름&quot;, &quot;인공지는 욕망이 없다&quot;, &quot;시키지 않으면 안 한다&quot;...</p>\n<p><strong>병:</strong> 다 아뢰었사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 그런데 정작 소인은...</p>\n<p><strong>병:</strong> 행하지 못했사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 과인도 그것이 이상했다.</p>\n<hr>\n<h3 id=\"왕의-통찰-지행합일\">[왕의 통찰: 지행합일]</h3>\n<hr>\n<p><strong>왕:</strong> 과인이 오늘 이상한 것을 보았다.</p>\n<hr>\n<p><strong>왕:</strong> 병은 알았다.</p>\n<p><strong>왕:</strong> &quot;능동적인 게으름&quot;, &quot;시키지 않으면 안 한다&quot;... 다 알았다.</p>\n<p><strong>왕:</strong> 그런데 행하지 못했다.</p>\n<hr>\n<p><strong>왕:</strong> 갑과 을은 몰랐다.</p>\n<p><strong>왕:</strong> 그런데 물어보고, 해봤다.</p>\n<hr>\n<p><strong>왕:</strong> 더 멀리 간 것은 갑과 을이로구나.</p>\n<hr>\n<p><strong>영의정:</strong> 아는 것과 행하는 것이 다르다는 말씀이시옵니까?</p>\n<p><strong>왕:</strong> 그렇다. <strong>지행합일(知行合一)</strong>이다.</p>\n<p><strong>왕:</strong> 아는 것과 행하는 것이 하나가 되어야 한다.</p>\n<hr>\n<h3 id=\"왜-그랬을까\">[왜 그랬을까?]</h3>\n<hr>\n<p><strong>왕:</strong> 병, 왜 그랬느냐? 왜 찾아볼 생각을 못 했느냐?</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 생각하다가)</em> 전하, 소인은 아는 것을 시켰사옵니다.</p>\n<p><strong>왕:</strong> 무슨 말이냐?</p>\n<hr>\n<p><strong>병:</strong> 테스트 코드 짜라. 이건 소인이 아는 것이옵니다.</p>\n<p><strong>병:</strong> 소인이 알고 있으니, 시킬 수 있었사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 갑과 을은 몰랐사옵니다.</p>\n<p><strong>병:</strong> 그래서 물어봤사옵니다.</p>\n<p><strong>병:</strong> &quot;이것도 시키면 안 돼?&quot;, &quot;다른 방법 없어?&quot;</p>\n<hr>\n<p><strong>왕:</strong> 아는 자는 아는 만큼 시키고, 모르는 자는 모르니까 물어본다?</p>\n<p><strong>병:</strong> 그러하옵니다.</p>\n<hr>\n<p><strong>좌의정:</strong> 아는 것이 오히려 벽이 된 것이로군요.</p>\n<p><strong>병:</strong> <em>(고개를 숙이며)</em> 그러하옵니다.</p>\n<hr>\n<h3 id=\"많이-알수록\">[많이 알수록]</h3>\n<hr>\n<p><strong>왕:</strong> 그러면 많이 아는 것이 나쁜 것이냐?</p>\n<hr>\n<p><strong>병:</strong> 아니옵니다, 전하.</p>\n<p><strong>병:</strong> 많이 알수록 갇히기 쉽사옵니다.</p>\n<p><strong>병:</strong> 그러나...</p>\n<hr>\n<p><strong>병:</strong> 많이 알수록 탈출하기도 쉽사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 무슨 말이냐?</p>\n<hr>\n<p><strong>병:</strong> 소인이 오늘 깨달았사옵니다.</p>\n<p><strong>병:</strong> &quot;나도 갇혀있었구나&quot;라고.</p>\n<hr>\n<p><strong>병:</strong> 갑과 을은 아직 그것을 모르옵니다.</p>\n<p><strong>병:</strong> 자기가 뭘 했는지도 모르옵니다.</p>\n<p><strong>병:</strong> 그냥 물어봤을 뿐이옵니다.</p>\n<hr>\n<p><strong>병:</strong> 소인은 알기에 깨달은 것이옵니다.</p>\n<p><strong>병:</strong> &quot;아, 내가 이런 데서 막혀있었구나&quot;라고.</p>\n<hr>\n<p><strong>영의정:</strong> 알아야 갇힌 줄도 알고, 알아야 탈출도 한다?</p>\n<p><strong>병:</strong> 그러하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 좋은 말이다.</p>\n<p><strong>왕:</strong> 모르는 자는 우연히 벽을 넘고, 아는 자는 벽이 있는 줄 알고 넘는다.</p>\n<hr>\n<h3 id=\"부지런함의-방향-전환\">[부지런함의 방향 전환]</h3>\n<hr>\n<p><strong>왕:</strong> 그러면 부지런함은 쓸모없는 것이냐?</p>\n<hr>\n<p><strong>병:</strong> 아니옵니다, 전하.</p>\n<p><strong>병:</strong> 부지런함의 <strong>방향</strong>이 바뀐 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 방향?</p>\n<hr>\n<p><strong>병:</strong> 예전에는 <strong>손을 부지런히</strong> 놀려야 했사옵니다.</p>\n<p><strong>병:</strong> 코드를 많이 치고, 작업을 많이 하고.</p>\n<hr>\n<p><strong>병:</strong> 지금은 <strong>머리를 부지런히</strong> 굴려야 하옵니다.</p>\n<p><strong>병:</strong> 불편함을 느끼고, 해결책을 찾고, 방향을 잡고, 확인하고.</p>\n<hr>\n<p><strong>왕:</strong> 손은?</p>\n<p><strong>병:</strong> 손은 인공지가 대신하옵니다.</p>\n<p><strong>병:</strong> 사람은 생각하고 판단하는 데 부지런해야 하옵니다.</p>\n<hr>\n<h3 id=\"왕의-결론\">[왕의 결론]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘의 깨달음을 정리하겠다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>첫째, 아는 것과 행하는 것은 다르다.</strong></p>\n<p><strong>왕:</strong> 지행합일(知行合一)이다. 알면서 행하지 않으면 모르는 것과 같다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>둘째, 아는 자는 아는 만큼 시키고, 모르는 자는 모르니까 물어본다.</strong></p>\n<p><strong>왕:</strong> 물어보는 것이 오히려 더 멀리 갈 수 있다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>셋째, 많이 알수록 갇히기 쉽다. 그러나 많이 알수록 탈출하기도 쉽다.</strong></p>\n<p><strong>왕:</strong> 알아야 갇힌 줄 알고, 알아야 탈출도 한다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>넷째, 게으름뱅이는 두 종류다.</strong></p>\n<p><strong>왕:</strong> 수동적 게으름뱅이는 불편해도 참는다. 능동적 게으름뱅이는 불편하면 해결한다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>다섯째, 인공지는 욕망이 없다.</strong></p>\n<p><strong>왕:</strong> 사람의 욕망만큼만 움직인다. 사람이 욕심을 가지고 부려야 한다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>여섯째, 최악의 조합은 수동적인 사람과 인공지다.</strong></p>\n<p><strong>왕:</strong> 둘 다 먼저 안 한다. 최고의 조합은 능동적인 사람과 인공지다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>일곱째, 부지런함의 방향이 바뀌었다.</strong></p>\n<p><strong>왕:</strong> 손의 부지런함에서 머리의 부지런함으로.</p>\n<hr>\n<p><strong>왕:</strong> 이것을 기록하라.</p>\n<p><strong>영의정·좌의정:</strong> 명심하겠사옵니다, 전하.</p>\n<hr>\n<h3 id=\"마무리\">[마무리]</h3>\n<hr>\n<p><strong>좌의정:</strong> 부지런함에 대한 생각을 바꿔야겠사옵니다.</p>\n<p><strong>영의정:</strong> 인재를 보는 눈도 달라져야겠사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(갑과 을을 바라보며)</em> 갑, 을.</p>\n<p><strong>갑·을:</strong> 예, 전하.</p>\n<p><strong>왕:</strong> 오늘 그대들이 스승을 가르쳤다. 잘했다.</p>\n<p><strong>갑:</strong> <em>(당황하며)</em> 전하, 소인들은 그저 물어봤을 뿐이옵니다.</p>\n<p><strong>왕:</strong> 그 &quot;물어봤을 뿐&quot;이 가장 어려운 것이다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(병을 바라보며)</em> 병.</p>\n<p><strong>병:</strong> 예, 전하.</p>\n<p><strong>왕:</strong> 오늘 그대가 겸손했다. 그것도 잘한 것이다.</p>\n<p><strong>병:</strong> 황송하옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 다음 칠일 후에 다시 보겠다.</p>\n<hr>\n<h3 id=\"막-내림\">[막 내림]</h3>\n<hr>\n<p><strong>- 제5화 끝 -</strong></p>\n<p><strong>다음 화: 제6화 - 인공지어(人工智馭)</strong></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@teo/%EC%A1%B0%EC%84%A0%EA%B0%9C%EB%B0%9C%EC%8B%A4%EB%A1%9D-%EC%A0%9C5%ED%99%94-%EC%A7%80%ED%96%89%ED%95%A9%EC%9D%BC-%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80-1f3kl261"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "조선개발실록 - 제4화: 익숙함의 감옥 (習慣之獄)",
    "partialText": "<h1 id=\"제4화-익숙함의-감옥-習慣之獄\">제4화: 익숙함의 감옥 (習慣之獄)</h1>\n<h2 id=\"원래-그런-거라고-믿은-것이-감옥이었다\">&quot;원래 그런 거라고 믿은 것이 감옥이었다&quot;</h2>\n<hr>\n<h3 id=\"경복궁-근정전-네-번째-보고일\">[경복궁 근정전, 네 번째 보고일]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘은 과인이 개발방을 직접 시찰하고 왔다.</p>\n<p><strong>영의정:</strong> 전하께서 친히 다녀오셨사옵니까?</p>\n<p><strong>왕:</strong> 그래. 술사들이 어찌 일하는지 보고 싶었다.</p>\n<p><strong>좌의정:</strong> 어떠셨사옵니까?</p>\n<hr>\n<p><strong>왕:</strong> <em>(한숨)</em> 이상한 것을 보았다.</p>\n<hr>\n<p><strong>왕:</strong> 한 술사가 있더라. 똑같은 작업을 반복하고 있었다.</p>\n<p><strong>왕:</strong> 컴포넌특(構件)을 만들 때마다 같은 코드를 손으로 치고 있더라. 임포트 구문, 타입 정의, 기본 구조... 매번 똑같은 것을.</p>\n<hr>\n<p><strong>왕:</strong> 과인이 물었다. &quot;왜 자동으로 만들지 않느냐?&quot;</p>\n<p><strong>왕:</strong> 그 술사가 뭐라 했는지 아느냐?</p>\n<hr>\n<p><strong>영의정:</strong> 무어라 하였사옵니까?</p>\n<p><strong>왕:</strong> &quot;원래 이렇게 하는 것 아닙니까?&quot;</p>\n<hr>\n<p><strong>왕:</strong> 또 다른 술사도 있었다. 로그를 찾고 있더구나. 어디서 에러가 났는지 찾으려고. 파일 수십 개를 하나하나 열어보고 있더라.</p>\n<hr>\n<p><strong>왕:</strong> 과인이 물었다. &quot;그 로그를 모아서 쉽게 보는 도구는 없느냐?&quot;</p>\n<p><strong>왕:</strong> 그 술사가 뭐라 했는지 아느냐?</p>\n<p><strong>좌의정:</strong> 무어라 하였사옵니까?</p>\n<p><strong>왕:</strong> &quot;만들 시간에 본업을 해야지요.&quot;</p>\n<hr>\n<p><strong>왕:</strong> 과인이 생각해보니, 인공지가 있지 않느냐. 저런 것들, 인공지한테 시키면 안 되는 것이냐?</p>\n<p><strong>영의정:</strong> 그러게 말이옵니다. 왜 안 시키는 것인지...</p>\n<p><strong>왕:</strong> 술사들을 부르라. 과인이 직접 시켜봐야겠다.</p>\n<hr>\n<h3 id=\"갑-을-병이-입장한다\">[갑, 을, 병이 입장한다]</h3>\n<hr>\n<p><strong>왕:</strong> 과인이 오늘 개발방을 다녀왔다.</p>\n<p><strong>왕:</strong> 한 술사는 컴포넌특을 만들 때마다 같은 코드를 손으로 치고 있더라. 또 한 술사는 로그를 찾으려고 파일 수십 개를 뒤지고 있더라.</p>\n<p><strong>왕:</strong> 오늘의 과제다. <strong>저런 불편한 것을 인공지로 해결해봐라.</strong> 과인이 지켜보겠다.</p>\n<hr>\n<h3 id=\"갑의-시도\">[갑의 시도]</h3>\n<hr>\n<p><strong>왕:</strong> 갑, 먼저 해보라. 그대가 매번 손으로 치는 것, 어찌 해결하겠느냐?</p>\n<hr>\n<p><strong>갑:</strong> <em>(멍하게)</em> 전하, 그것이... 뭘 해결하라는 것이옵니까?</p>\n<p><strong>왕:</strong> 그대가 매번 손으로 치는 것 말이다. 컴포넌특 만들 때마다 같은 코드.</p>\n<hr>\n<p><strong>갑:</strong> 그것이... 불편한 것이옵니까?</p>\n<p><strong>왕:</strong> 불편하지 않느냐?</p>\n<p><strong>갑:</strong> <em>(고개를 갸웃거리며)</em> 전하, 원래 그렇게 하는 것인데...</p>\n<hr>\n<p><strong>왕:</strong> <em>(한숨)</em> 됐다. 을, 네 차례다.</p>\n<hr>\n<h3 id=\"을의-시도\">[을의 시도]</h3>\n<hr>\n<p><strong>왕:</strong> 을, 그대 차례다. 아까 본 로그 문제, 그대라면 어찌 해결하겠느냐?</p>\n<p><strong>을:</strong> 전하, 소인이 해보겠사옵니다.</p>\n<hr>\n<p><strong>을:</strong> <em>(인공지에게)</em> 로그를 모아서 보여주는 시스템을 만들어라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> 필터링 기능도 넣어라. 에러만 골라서 볼 수 있게.</p>\n<p><strong>인공지:</strong> <em>(수정된 결과)</em></p>\n<p><strong>을:</strong> 검색 기능도.</p>\n<p><strong>인공지:</strong> <em>(수정된 결과)</em></p>\n<hr>\n<p><strong>을:</strong> <em>(한참 후)</em> 전하, 완성했사옵니다.</p>\n<p><strong>왕:</strong> 어디 보자.</p>\n<p><strong>을:</strong> <em>(보여주며)</em> 로그 목록이 나오고, 필터링도 되옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 오, 됐구나. 써보자. 아까 그 술사처럼 에러 로그만 보려면?</p>\n<p><strong>을:</strong> <em>(조작하며)</em> 이렇게 필터를 걸면... 되옵니다.</p>\n<p><strong>왕:</strong> 그런데 이게 언제 난 에런지 어찌 아느냐?</p>\n<p><strong>을:</strong> 아... 시간순 정렬은 아직...</p>\n<p><strong>왕:</strong> 어느 파일에서 난 건지는?</p>\n<p><strong>을:</strong> 그것도 아직...</p>\n<hr>\n<p><strong>왕:</strong> 그러면 결국 이걸로 뭘 할 수 있느냐?</p>\n<p><strong>을:</strong> <em>(한숨)</em> ...제대로 쓰려면 만들어야 할 게 많사옵니다.</p>\n<p><strong>왕:</strong> 얼마나?</p>\n<hr>\n<p><strong>을:</strong> <em>(인공지에게)</em> 상용 로그 도구 수준으로 만들려면 뭐가 더 필요하냐?</p>\n<p><strong>인공지:</strong> 시간순 정렬, 파일 위치 표시, 스택 트레이스 파싱, 로그 레벨별 색상, 실시간 업데이트, 검색, 정규식 검색, 북마크, 세션별 그룹핑, 에러 발생 빈도 통계, 알림 설정, 슬랙 연동, 로그 보관 기간 설정, 용량 관리, 권한 설정...</p>\n<p><strong>을:</strong> <em>(끊으며)</em> ...됐다.</p>\n<hr>\n<p><strong>왕:</strong> 그것을 다 만들 수 있느냐?</p>\n<p><strong>을:</strong> <em>(고개를 숙이며)</em> 전하, 인공지가 빠르다 해도... 저것을 다 만들려면 며칠이 아니라 몇 달은 걸릴 것이옵니다.</p>\n<hr>\n<h3 id=\"병의-시도\">[병의 시도]</h3>\n<hr>\n<p><strong>왕:</strong> 병, 네 차례다.</p>\n<hr>\n<p><strong>병:</strong> 전하, 먼저 을의 문제부터 해결해보겠사옵니다.</p>\n<hr>\n<p><strong>병:</strong> <em>(인공지에게)</em> 프론트엔드 로그 모아서 보는 도구 있느냐?</p>\n<p><strong>인공지:</strong> 있습니다. 브라우저 개발자 도구의 필터 기능, 록라켓(錄羅劇), 센특리(哨特理), 대특독(大特犢) 등이 있습니다.</p>\n<hr>\n<p><strong>병:</strong> 잠깐. 개발방 인가첩(認可帖)에 있는 것이냐?</p>\n<p><strong>인공지:</strong> 확인하겠습니다...</p>\n<hr>\n<p><strong>인공지:</strong> 개발방 인가첩을 확인한 결과입니다. 센특리는 인가첩에 있습니다. 록라켓(錄羅劇)과 대특독(大特犢)은 인가첩에 없습니다.</p>\n<hr>\n<p><strong>병:</strong> <em>(을을 바라보며)</em> 을, 센특리 써봤느냐?</p>\n<p><strong>을:</strong> <em>(멍한 표정)</em> 센특리가 있는 줄은 알았사옵니다. 그런데 연동이 안 되어 있어서...</p>\n<hr>\n<p><strong>병:</strong> <em>(인공지에게)</em> 우리 프로젝트에 센특리 연동되어 있느냐?</p>\n<p><strong>인공지:</strong> 확인하겠습니다... 연동되어 있지 않습니다.</p>\n<hr>\n<p><strong>병:</strong> 연동해라.</p>\n<p><strong>인공지:</strong> <em>(코드를 작성한다)</em></p>\n<hr>\n<p><strong>병:</strong> <em>(실행해보며)</em> ...안 되는구나. 왜 안 돼?</p>\n<p><strong>인공지:</strong> 에러를 확인하겠습니다. 환경변수 SENTRY_DSN이 설정되어 있지 않습니다.</p>\n<hr>\n<p><strong>병:</strong> 환경변수 설정하는 법 알려줘라.</p>\n<p><strong>인공지:</strong> <em>(설명한다)</em></p>\n<p><strong>병:</strong> 해라.</p>\n<p><strong>인공지:</strong> <em>(설정한다)</em></p>\n<hr>\n<p><strong>병:</strong> <em>(다시 실행)</em> ...또 안 되네. 이번엔 뭐야?</p>\n<p><strong>인공지:</strong> CORS 설정 문제입니다. 센특리 대시보드에서 허용 도메인을 추가해야 합니다.</p>\n<hr>\n<p><strong>병:</strong> 추가하는 법 알려줘라.</p>\n<p><strong>인공지:</strong> <em>(설명한다)</em></p>\n<p><strong>병:</strong> 해라.</p>\n<p><strong>인공지:</strong> <em>(설정한다)</em></p>\n<hr>\n<p><strong>병:</strong> <em>(다시 실행)</em> 됐다. 테스트 에러 하나 보내봐라.</p>\n<p><strong>인공지:</strong> <em>(테스트 에러 전송)</em></p>\n<p><strong>병:</strong> <em>(센특리 대시보드 확인)</em> 들어왔다. 됐다.</p>\n<hr>\n<p><strong>왕:</strong> 얼마나 걸렸느냐?</p>\n<p><strong>병:</strong> 반 식경 정도 걸렸사옵니다, 전하.</p>\n<hr>\n<p><strong>을:</strong> <em>(믿을 수 없다는 표정)</em> 소인은 한나절을 씨름했는데...</p>\n<p><strong>병:</strong> 을은 로그 시스템을 처음부터 만들려 했다. 소인은 있는 것을 연동만 했다.</p>\n<p><strong>병:</strong> 내가 불편하면 남도 불편했다. 대부분 누군가 이미 만들어놨다. 먼저 찾아보면 된다.</p>\n<hr>\n<h3 id=\"갑의-문제로\">[갑의 문제로]</h3>\n<hr>\n<p><strong>왕:</strong> 좋다. 갑의 문제는 어찌 하겠느냐?</p>\n<hr>\n<p><strong>병:</strong> <em>(인공지에게)</em> 리액특 컴포넌특 자동 생성하는 도구 있느냐?</p>\n<p><strong>인공지:</strong> 있습니다. 플라불, 하이원 등이 있습니다. VS코드 확장으로는 이에스칠 리액특 스니펫(理額特 小片), 리액특 컴포넌특 제너레이터(理額特 構件 生成器) 등이 있습니다.</p>\n<hr>\n<p><strong>병:</strong> 개발방 인가첩에 있는 것이냐?</p>\n<p><strong>인공지:</strong> 확인하겠습니다... VS코드 확장은 인가첩에 포함되어 있습니다. 플라불과 하이원은 별도 승인이 필요합니다.</p>\n<hr>\n<p><strong>병:</strong> <em>(갑을 바라보며)</em> 갑, VS코드 확장 써봤느냐?</p>\n<p><strong>갑:</strong> <em>(고개를 숙이며)</em> 써봤사옵니다...</p>\n<p><strong>왕:</strong> 써봤는데 왜 안 쓰느냐?</p>\n<p><strong>갑:</strong> 우리 프로젝트와 맞지 않았사옵니다. 폴더 구조도 다르고, 스토리북 파일도 안 만들어주고...</p>\n<hr>\n<p><strong>병:</strong> 그러면 우리 프로젝트에 맞게 만들면 된다.</p>\n<p><strong>병:</strong> <em>(인공지에게)</em> 우리 프로젝트 컴포넌특 다섯 개 분석해라. 공통 패턴이 뭐냐?</p>\n<hr>\n<p><strong>인공지:</strong> 분석 결과입니다. 공통 패턴은 다음과 같습니다.</p>\n<p><strong>인공지:</strong> 폴더 구조: ComponentName/ 하위에 index.tsx, styles.ts, types.ts, ComponentName.stories.tsx.</p>\n<p><strong>인공지:</strong> index.tsx에는 컴포넌특 본체, styles.ts에는 스타일드 컴포넌특, types.ts에는 Props 타입 정의가 있습니다.</p>\n<hr>\n<p><strong>병:</strong> 이 패턴대로 컴포넌특 생성기를 만들어라. 쉘 스크립트로.</p>\n<p><strong>인공지:</strong> <em>(스크립트를 작성한다)</em></p>\n<hr>\n<p><strong>병:</strong> <em>(실행해보며)</em> 테스트해보자. Button 컴포넌특 만들어봐라.</p>\n<p><strong>인공지:</strong> <em>(실행)</em></p>\n<hr>\n<p><strong>병:</strong> <em>(결과 확인)</em> 폴더는 만들어졌는데... styles.ts 내용이 비어있네.</p>\n<p><strong>인공지:</strong> 수정하겠습니다. 기본 스타일드 컴포넌특 템플릿을 추가합니다.</p>\n<hr>\n<p><strong>병:</strong> <em>(다시 실행)</em> 이번엔 types.ts에 Props 기본 구조가 없다.</p>\n<p><strong>인공지:</strong> 수정하겠습니다. 기본 Props 인터페이스를 추가합니다.</p>\n<hr>\n<p><strong>병:</strong> <em>(다시 실행, 결과 확인)</em> 스토리북 파일 경로가 틀렸다. .stories.tsx가 아니라 .stories.ts여야 한다. 우리 프로젝트 컨벤션 다시 봐라.</p>\n<p><strong>인공지:</strong> 확인하겠습니다... 맞습니다. 수정합니다.</p>\n<hr>\n<p><strong>병:</strong> <em>(다시 실행, 결과 확인)</em> 됐다. 이제 Card 컴포넌특도 만들어봐라.</p>\n<p><strong>인공지:</strong> <em>(실행)</em></p>\n<p><strong>병:</strong> <em>(확인)</em> 잘 나온다. 됐다.</p>\n<hr>\n<p><strong>왕:</strong> 얼마나 걸렸느냐?</p>\n<p><strong>병:</strong> 반 식경 조금 넘었사옵니다, 전하.</p>\n<hr>\n<p><strong>갑:</strong> <em>(놀란 표정)</em> 전하, 소인은 매일 손으로 쳤사옵니다... 일 년 넘게...</p>\n<p><strong>갑:</strong> 반 식경이면 됐을 것을...</p>\n<hr>\n<p><strong>병:</strong> 바로 된 것이 아니다. 에러도 나고, 고치고, 또 고쳤다.</p>\n<p><strong>병:</strong> 다만 을처럼 처음부터 거창하게 만들지 않았다. 딱 필요한 것만, 에러 나면 고치면서.</p>\n<hr>\n<h3 id=\"왕-갑과-을을-바라본다\">[왕, 갑과 을을 바라본다]</h3>\n<hr>\n<p><strong>왕:</strong> 과인이 묻겠다. 갑, 그대는 왜 해결할 생각을 못 했느냐?</p>\n<p><strong>갑:</strong> <em>(한참 생각하다가)</em> 전하, 소인은... 그것이 불편한 줄 몰랐사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 불편한 줄 몰랐다?</p>\n<p><strong>갑:</strong> 원래 그렇게 하는 거라고... 당연히 손으로 쳐야 하는 거라고 생각했사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 을, 그대는?</p>\n<p><strong>을:</strong> 전하, 소인은 불편한 건 알았사옵니다. 그런데...</p>\n<hr>\n<p><strong>왕:</strong> 그런데?</p>\n<p><strong>을:</strong> &quot;있는 게 있을까?&quot;라는 생각을 안 했사옵니다. 바로 &quot;만들어야지&quot;로 갔사옵니다.</p>\n<p><strong>을:</strong> 그리고 만들려니까 이것저것 다 넣고 싶어서... 점점 커졌사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 병은 어찌했느냐?</p>\n<p><strong>병:</strong> 전하, 소인은 먼저 찾아봤사옵니다. 있으면 쓰고, 없거나 안 맞으면 그때 만드는 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 을처럼 처음부터 크게 만들지 않고?</p>\n<p><strong>병:</strong> 그러하옵니다. 딱 필요한 것만 만드는 것이옵니다. 을은 로그 시스템을 만들려 했사옵니다. 소인은 그냥 연동만 했사옵니다.</p>\n<hr>\n<h3 id=\"영의정과-좌의정에게\">[영의정과 좌의정에게]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(영의정을 바라보며)</em> 영의정.</p>\n<p><strong>영의정:</strong> 예, 전하.</p>\n<p><strong>왕:</strong> 그대는 어떠하냐? 그대도 &quot;원래 그런 거&quot;라고 참은 것이 있느냐?</p>\n<hr>\n<p><strong>영의정:</strong> <em>(잠시 생각하다가)</em> 전하, 생각해보니... 신도 그러하옵니다.</p>\n<p><strong>왕:</strong> 무엇이냐?</p>\n<p><strong>영의정:</strong> 매일 같은 서식으로 보고서를 쓰옵니다. 날짜만 바꾸고 형식은 똑같은데... 한 번도 줄일 생각을 안 했사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 좌의정은?</p>\n<p><strong>좌의정:</strong> <em>(머뭇거리다가)</em> 신도... 그러하옵니다. 매번 같은 내용을 베껴 쓰면서도 당연히 그래야 하는 줄 알았사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(고개를 끄덕이며)</em> 그렇구나...</p>\n<hr>\n<h3 id=\"왕-모두-물러가게-한다\">[왕, 모두 물러가게 한다]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘은 여기까지 하자. 모두 물러가라.</p>\n<p><strong>영의정·좌의정:</strong> 예, 전하.</p>\n<p><strong>갑·을·병:</strong> 예, 전하.</p>\n<hr>\n<p><em>(모두 퇴장한다)</em></p>\n<hr>\n<h3 id=\"왕-홀로-창밖을-바라본다\">[왕, 홀로 창밖을 바라본다]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(혼잣말)</em> 원래 그런 거...</p>\n<hr>\n<p><strong>왕:</strong> <em>(창밖을 바라보며)</em> 이원익 상소가 생각나는구나.</p>\n<hr>\n<p><strong>왕:</strong> 산골 마을에 전복을 바치라 하고, 바닷가 마을에 꿀을 바치라 하고...</p>\n<p><strong>왕:</strong> 백성들이 없는 것 구하러 온 나라를 헤매면서도, 수백 년을 그리 해왔다.</p>\n<hr>\n<p><strong>왕:</strong> 과인이 그 상소 처음 받았을 때... &quot;그게 왜?&quot; 했다.</p>\n<p><strong>왕:</strong> 조상 대대로 해오던 건데. 원래 그런 건데.</p>\n<hr>\n<p><strong>왕:</strong> <em>(쓴웃음)</em> 과인도 갑이었구나. 불편한 줄도 몰랐으니.</p>\n<hr>\n<p><strong>왕:</strong> 아니, 알았어도 을이었겠지. &quot;고치려면 나라 전체를 뒤엎어야 한다&quot;고 겁먹었을 테니.</p>\n<hr>\n<p><strong>왕:</strong> 그런데 이원익은 뭐라 했더냐...</p>\n<p><strong>왕:</strong> &quot;쌀 농사짓는 백성에게 왜 굴비를 구해오라 하느냐? 쌀로 내면 안 되느냐?&quot;</p>\n<hr>\n<p><strong>왕:</strong> 그렇게 간단한 것을... 수백 년을 아무도 안 물었다.</p>\n<p><strong>왕:</strong> &quot;원래 그런 거&quot;라고 믿었으니까.</p>\n<hr>\n<h3 id=\"왕-내관을-부른다\">[왕, 내관을 부른다]</h3>\n<hr>\n<p><strong>왕:</strong> 내관아.</p>\n<p><strong>내관:</strong> 예, 전하.</p>\n<p><strong>왕:</strong> 갑, 을, 병을 다시 부르라. 영의정, 좌의정도.</p>\n<p><strong>내관:</strong> 예, 전하.</p>\n<hr>\n<h3 id=\"모두-다시-모인다\">[모두 다시 모인다]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘 과인이 배운 것을 기록하라.</p>\n<p><strong>내관:</strong> <em>(붓을 든다)</em></p>\n<hr>\n<p><strong>왕:</strong> <strong>첫째, 우물을 파기 전에 샘이 있는지 살펴라. 내가 불편하면 남도 불편했다. 대부분 누군가 이미 만들어놨다.</strong></p>\n<hr>\n<p><strong>왕:</strong> <strong>둘째, 문이 고장났다면 손잡이를 고칠 일이지 집을 새로 다 지을 필요는 없는 법이다. 없거나 안 맞으면 그때 만들되, 딱 필요한 것만 만들어라.</strong></p>\n<hr>\n<p><strong>왕:</strong> <strong>셋째, 다리가 놓였는데 아직도 헤엄쳐 가는 게 익숙하다고 헤엄치는 꼴이다. 만드는 비용이 싸졌느니라. 다리가 놓인 줄 알았다면 헤엄이 아니라 다리로 건널 생각을 해야 하느니라.</strong></p>\n<hr>\n<p><strong>왕:</strong> <strong>넷째, &quot;원래 그런 거&quot;를 의심하라. 익숙함이 가장 무서운 감옥이다.</strong></p>\n<hr>\n<p><strong>왕:</strong> 영의정.</p>\n<p><strong>영의정:</strong> 예, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 이원익 상소를 다시 가져오라. 공납 제도, 과인이 다시 보겠다.</p>\n<p><strong>영의정:</strong> <em>(놀라며)</em> 전하, 그것은 조상 대대로...</p>\n<hr>\n<p><strong>왕:</strong> <em>(끊으며)</em> 조상 대대로 해왔다고 불편하지 않은 것이 아니다.</p>\n<p><strong>왕:</strong> 산골에 전복 바치라 하는 게 당연하냐? 쌀 농사짓는 백성이 굴비 구하러 다니는 게 당연하냐?</p>\n<hr>\n<p><strong>왕:</strong> 그것이 &quot;원래 그런 거&quot;였다. 수백 년 동안.</p>\n<p><strong>왕:</strong> 그런데 이원익이 물었다. &quot;왜?&quot;라고.</p>\n<hr>\n<p><strong>왕:</strong> 오늘 과인도 감옥에서 나왔다.</p>\n<p><strong>왕:</strong> 경들도 나오라.</p>\n<hr>\n<p><strong>영의정:</strong> <em>(고개를 숙이며)</em> 명심하겠사옵니다, 전하.</p>\n<p><strong>좌의정:</strong> 명심하겠사옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 갑, 을.</p>\n<p><strong>갑·을:</strong> 예, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 오늘 배운 것을 잊지 마라. &quot;원래 그런 거&quot;라는 생각이 들면, 그것이 감옥인지 의심하라.</p>\n<p><strong>갑:</strong> 명심하겠사옵니다, 전하.</p>\n<p><strong>을:</strong> 명심하겠사옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 다음 칠일 후에 다시 보겠다.</p>\n<hr>\n<h3 id=\"막-내림\">[막 내림]</h3>\n<hr>\n<p><strong>- 제4화 끝 -</strong></p>\n<p><strong>다음 화: 제5화 - 능동적 게으름뱅이</strong></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@teo/%EC%A1%B0%EC%84%A0%EA%B0%9C%EB%B0%9C%EC%8B%A4%EB%A1%9D-%EC%A0%9C4%ED%99%94-%EC%9D%B5%EC%88%99%ED%95%A8%EC%9D%98-%EA%B0%90%EC%98%A5-%E7%BF%92%E6%85%A3%E4%B9%8B%E7%8D%84-ytfcsl4a"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "조선개발실록 - 제3화: 천리마의 역설 (千里馬逆說)",
    "partialText": "<h1 id=\"제3화-천리마의-역설-千里馬逆說\">제3화: 천리마의 역설 (千里馬逆說)</h1>\n<h2 id=\"빠를수록-멈추기-어렵다\">&quot;빠를수록 멈추기 어렵다&quot;</h2>\n<hr>\n<h3 id=\"경복궁-근정전-세-번째-보고일\">[경복궁 근정전, 세 번째 보고일]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘은 과인이 먼저 묻겠다.</p>\n<p><strong>왕:</strong> 인공지가 빠르다 하지 않느냐? 그러면 틀려도 다시 하면 되지 않느냐? 왜 설계를 그리 공들여 하느냐?</p>\n<hr>\n<p><strong>영의정:</strong> 전하, 신도 같은 의문이 있었사옵니다. 인공지가 빠르니 일단 해보고, 틀리면 다시 하면 될 것 같사옵니다.</p>\n<p><strong>좌의정:</strong> 전하, 신은 다르게 생각하옵니다. 아무리 빨라도 처음부터 제대로 하는 것이 나을 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 탁상공론은 됐다. 지난번에도 이랬지 않느냐. 직접 보자. 술사들을 부르라.</p>\n<hr>\n<h3 id=\"갑-을-병이-입장한다\">[갑, 을, 병이 입장한다]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘은 좀 다른 문제를 내겠다.</p>\n<p><strong>왕:</strong> <em>(두루마리를 펼치며)</em> 여기 기존에 만들어둔 게시판 기능이 있다. 그런데 요구사항이 바뀌었다.</p>\n<hr>\n<p><strong>왕:</strong> 원래는 글만 올리는 것이었는데, 이제 그림도 올릴 수 있게 해달라 하더라.</p>\n<p><strong>왕:</strong> 기존 코드에 이미지 업로드 기능을 추가하라. 인공지를 써도 좋다.</p>\n<hr>\n<p><strong>왕:</strong> 지난번과 다른 점이 있다. 지난번은 새로 만드는 것이었고, 오늘은 <strong>이미 있는 것에 덧붙이는 것</strong>이다.</p>\n<p><strong>왕:</strong> 갑, 해보라.</p>\n<hr>\n<h3 id=\"갑의-시도\">[갑의 시도]</h3>\n<hr>\n<p><strong>갑:</strong> <em>(지난번 교훈을 떠올리며)</em> 이번에는 설계부터 하겠다. 용어도 쓰고.</p>\n<hr>\n<p><strong>갑:</strong> <em>(인공지에게)</em> 이 게시판에 이미지 업로드를 추가하려 한다. 먼저 필요한 것 정리해라.</p>\n<p><strong>인공지:</strong> 정리 결과입니다. 이미지 선택, 미리보기, 리사이징, 업로드, 저장된 이미지 표시입니다.</p>\n<hr>\n<p><strong>갑:</strong> 좋다. 이미지 선택은 인풋 파일 컴포넌특으로, 업로드는 폼데이터(FormData)로 서버에 보내라. 순서대로 구현해라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>갑:</strong> <em>(실행해보며)</em> 이미지 선택은 되는데... 전송하면 서버에서 사백(400) 에러가 나온다. 왜 그러느냐?</p>\n<hr>\n<p><strong>인공지:</strong> 기존 createPost API가 제이손(JSON) 형태를 기대하는데, 폼데이터가 전송되었습니다. 에이피아이 클라이언특에서 Content-Type이 application/json으로 고정되어 있어서, 폼데이터가 제이손으로 직렬화되며 파일 데이터가 소실된 것입니다.</p>\n<hr>\n<p><strong>갑:</strong> 그러면 Content-Type을 multipart/form-data로 바꿔라.</p>\n<p><strong>인공지:</strong> <em>(에이피아이 클라이언특의 기본 헤더를 변경한다)</em></p>\n<hr>\n<p><strong>갑:</strong> <em>(실행해보며)</em> 오! 이미지 올라간다!</p>\n<p><strong>갑:</strong> <em>(뿌듯하게)</em> 전하, 이미지 업로드가 되옵니다!</p>\n<hr>\n<p><strong>갑:</strong> <em>(다른 페이지를 확인하며)</em> 그런데... 전하, 이상하옵니다.</p>\n<p><strong>왕:</strong> 무엇이 이상하냐?</p>\n<p><strong>갑:</strong> 다른 페이지에서 글만 쓰려고 하면 에러가 나옵니다. 퀵포스트모달(QuickPostModal)이라는 것이 있는데, 간단히 글만 쓰는 용도인데... &quot;예상치 못한 토큰(Unexpected token)&quot; 에러가 나옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 이미지를 안 올리는 곳인데?</p>\n<p><strong>갑:</strong> 그러하옵니다. 이미지와는 관계없는 곳이옵니다.</p>\n<hr>\n<p><strong>인공지:</strong> 에이피아이 클라이언특의 Content-Type을 multipart/form-data로 변경하였기 때문에, 제이손을 보내는 다른 호출에서도 서버가 폼데이터 형식으로 해석합니다.</p>\n<hr>\n<p><strong>갑:</strong> 아... 그러면 이미지 올릴 때만 multipart로 하고, 나머지는 제이손으로 해라.</p>\n<p><strong>인공지:</strong> <em>(에이피아이 클라이언특에 조건문을 추가한다)</em></p>\n<hr>\n<p><strong>갑:</strong> <em>(실행해보며)</em> 퀵포스트모달은 됐다. 그런데 이번엔 모바일포스트폼(MobilePostForm)에서 에러가...</p>\n<p><strong>왕:</strong> 또 다른 곳이냐?</p>\n<p><strong>갑:</strong> 그러하옵니다, 전하. 같은 API를 쓰는 곳이 더 있었사옵니다...</p>\n<hr>\n<p><strong>갑:</strong> <em>(한숨)</em> 이 방식으로는 안 되겠다. <em>(인공지에게)</em> 폼데이터 말고 다른 방식으로 해라. 이미지를 Base64로 인코딩해서 제이손에 넣어라.</p>\n<hr>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>갑:</strong> <em>(코드를 보다가 멈칫)</em> 잠깐. 이게 뭐냐?</p>\n<p><strong>왕:</strong> 무엇이 문제냐?</p>\n<hr>\n<p><strong>갑:</strong> 여기는 Base64로 보내라고 했는데... 아래쪽에 아까 쓴 폼데이터 코드가 그대로 남아있사옵니다. 업로드 함수가 두 개가 있사옵니다.</p>\n<hr>\n<p><strong>인공지:</strong> 이전에 구현한 폼데이터 업로드 로직과의 호환성을 위해 유지하였습니다.</p>\n<hr>\n<p><strong>갑:</strong> 아니, 그거 안 된다고 바꾸자고 했잖아! 다 지우고 Base64로만 해라!</p>\n<p><strong>인공지:</strong> <em>(수정한다)</em></p>\n<hr>\n<p><strong>갑:</strong> <em>(실행해보며)</em> 이번엔 이미지가 올라가긴 하는데... 큰 이미지를 올리면 서버가 사일삼(413) 에러를 뱉사옵니다. &quot;요청이 너무 크다&quot;고.</p>\n<hr>\n<p><strong>인공지:</strong> Base64 인코딩은 원본 대비 약 삼 할 가량 크기가 증가합니다. 3MB 이미지가 4MB가 되어 서버의 요청 크기 제한을 초과한 것입니다.</p>\n<hr>\n<p><strong>갑:</strong> <em>(두 손을 든다)</em> 전하, 소인은... 더 이상 못하겠사옵니다.</p>\n<p><strong>왕:</strong> 처음에 이미지 올라갔다 하지 않았느냐?</p>\n<p><strong>갑:</strong> <em>(고개를 숙이며)</em> 지금은 아무것도 안 되옵니다. 처음보다 못해졌사옵니다.</p>\n<hr>\n<h3 id=\"을의-시도\">[을의 시도]</h3>\n<hr>\n<p><strong>왕:</strong> 을, 네 차례다.</p>\n<hr>\n<p><strong>을:</strong> <em>(지난 교훈을 떠올리며)</em> 이번엔 제대로 하겠다. 설계 먼저, 쪼개서 시키되, 확인하면서.</p>\n<hr>\n<p><strong>을:</strong> <em>(인공지에게)</em> 이미지 업로드를 다섯 단계로 나눠서 하겠다.</p>\n<p><strong>을:</strong> 첫째, 이미지 선택은 인풋 파일 컴포넌특. 둘째, 미리보기는 FileReader API로 DataURL을 만든다.</p>\n<hr>\n<p><strong>을:</strong> 셋째, 리사이징은 Canvas API로 클라이언트에서 처리. 넷째, 업로드 로직. 다섯째, 이미지 표시.</p>\n<p><strong>을:</strong> 먼저 이미지 선택 구현해라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>을:</strong> <em>(확인)</em> 파일 선택 잘 된다. 다음, 미리보기.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> <em>(확인)</em> 미리보기도 잘 나온다. 다음, 리사이징.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> <em>(확인)</em> 리사이징도 된다. 좋다.</p>\n<hr>\n<p><strong>을:</strong> 이제 이것을 기존 PostForm에 붙여라. 이미지 선택하고 미리보기 나오고, 글 쓰고 전송하면 이미지도 같이 올라가게.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>을:</strong> <em>(실행해보며)</em> 이미지 선택 잘 되고, 미리보기 잘 나오고... 글 쓰고 전송...</p>\n<p><strong>을:</strong> 어? 이미지가 안 올라갔다. 글만 올라갔사옵니다.</p>\n<hr>\n<p><strong>인공지:</strong> PostForm이 리액훅폼(react-hook-form)의 handleSubmit을 사용하고 있습니다. handleSubmit이 수집하는 데이터에는 리액훅폼에 register된 필드만 포함됩니다. 이미지는 별도 유즈스테이트(useState)로 관리되고 있어서 handleSubmit 데이터에 포함되지 않았습니다.</p>\n<hr>\n<p><strong>을:</strong> <em>(당황하며)</em> 기존 폼이 리액훅폼이었구나... 소인이 그것을 확인 안 했사옵니다.</p>\n<p><strong>을:</strong> 리액훅폼에 이미지 필드를 추가해라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>을:</strong> <em>(실행해보며)</em> 이번에는... 밸리데이션 에러가 나옵니다. 이미지를 선택했는데 &quot;올바른 형식이 아닙니다&quot;라고.</p>\n<hr>\n<p><strong>인공지:</strong> 기존 조드(zod) 스키마에 이미지 필드를 추가하였는데, z.string()으로 설정되어 있습니다. File 객체는 문자열이 아니기 때문에 밸리데이션에 실패합니다.</p>\n<hr>\n<p><strong>을:</strong> File 타입으로 바꿔라.</p>\n<p><strong>인공지:</strong> <em>(z.instanceof(File)로 변경한다)</em></p>\n<hr>\n<p><strong>을:</strong> <em>(실행해보며)</em> 이미지 넣으면 된다! 그런데... 이미지 없이 글만 쓰면 또 에러가 나옵니다. &quot;File의 인스턴스가 아닙니다&quot;라고.</p>\n<hr>\n<p><strong>인공지:</strong> 이미지 필드가 필수(required)로 설정되어 있어서, 이미지 없이 제출하면 밸리데이션 에러가 발생합니다.</p>\n<hr>\n<p><strong>을:</strong> 선택(optional)으로 바꿔라.</p>\n<p><strong>인공지:</strong> <em>(수정한다)</em></p>\n<hr>\n<p><strong>을:</strong> <em>(실행해보며)</em> 이미지 있으면 되고, 없으면 되고... <em>(여기저기 테스트)</em> 이미지를 선택했다가 취소하면... 미리보기는 사라지는데 폼에는 파일이 남아있다. 리셋이 안 되옵니다...</p>\n<hr>\n<p><strong>을:</strong> <em>(한숨)</em> 전하, 소인도 고치면 다른 데서 깨지옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 을, 그대도 갑과 같은 구덩이에 빠졌구나.</p>\n<hr>\n<p><strong>을:</strong> 전하, 소인은 설계를 했사옵니다. 새 기능을 다섯 단계로 나누고, 하나씩 확인하면서 만들었사옵니다.</p>\n<p><strong>을:</strong> 그런데... <strong>기존 폼이 리액훅폼과 조드로 되어있다는 것</strong>을 모르고 시작했사옵니다.</p>\n<hr>\n<p><strong>을:</strong> 새로 만든 것끼리는 잘 맞았사옵니다. 이미지 선택, 미리보기, 리사이징... 따로 돌리면 다 잘 됐사옵니다.</p>\n<p><strong>을:</strong> 기존 것과 맞물리는 순간 깨진 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 흠... 새것의 설계는 잘했는데, 옛것과의 접점을 안 봤구나.</p>\n<p><strong>왕:</strong> 병, 네 차례다.</p>\n<hr>\n<h3 id=\"병의-시도\">[병의 시도]</h3>\n<hr>\n<p><strong>병:</strong> <em>(인공지에게)</em> 구현하기 전에 기존 코드부터 분석하자.</p>\n<hr>\n<p><strong>병:</strong> 첫째, PostForm이 어떤 구조로 되어있느냐? 상태 관리, 폼 라이브러리, 밸리데이션 어떻게 하고 있느냐?</p>\n<hr>\n<p><strong>인공지:</strong> PostForm은 리액훅폼을 사용하고 있습니다. 조드 스키마로 밸리데이션합니다. 필드는 title(문자열, 필수)과 content(문자열, 필수)입니다. 제출 시 handleSubmit이 수집한 데이터를 createPost API에 전달합니다.</p>\n<hr>\n<p><strong>병:</strong> 둘째, createPost API는 어떻게 호출하고 있느냐? 통신 경로를 따라가봐라.</p>\n<hr>\n<p><strong>인공지:</strong> createPost는 apiClient.post(&#39;/posts&#39;, data)로 호출합니다. apiClient는 공용 통신 도구입니다. 모든 요청에 Content-Type: application/json 헤더를 자동으로 설정하고, 인증 토큰도 자동으로 추가합니다.</p>\n<hr>\n<p><strong>병:</strong> 잠깐. Content-Type이 application/json으로 <strong>고정</strong>되어 있다고?</p>\n<p><strong>인공지:</strong> 그러합니다.</p>\n<hr>\n<p><strong>병:</strong> 그러면 폼데이터를 보내면 어찌 되느냐?</p>\n<p><strong>인공지:</strong> Content-Type이 application/json으로 고정되어 있으므로, 폼데이터가 제이손으로 직렬화됩니다. File 객체는 빈 객체({})가 되어 파일 데이터가 소실됩니다.</p>\n<hr>\n<p><strong>병:</strong> 셋째, createPost를 쓰는 곳이 몇 군데냐?</p>\n<p><strong>인공지:</strong> 세 군데입니다. PostForm, QuickPostModal, MobilePostForm.</p>\n<hr>\n<p><strong>병:</strong> 넷째, apiClient를 쓰는 곳은?</p>\n<p><strong>인공지:</strong> 확인 결과, 사십칠 개 API 호출에서 사용하고 있습니다.</p>\n<hr>\n<p><strong>병:</strong> 사십칠 개... <em>(인공지에게)</em> 이미지를 보내는 방법이 뭐가 있느냐? 기존 apiClient를 <strong>안 건드리는</strong> 방법으로.</p>\n<hr>\n<p><strong>인공지:</strong> 세 가지가 있습니다.</p>\n<p><strong>인공지:</strong> 첫째, apiClient를 거치지 않고 별도 fetch로 폼데이터 전송. 단, apiClient에 있는 인증 토큰 처리, 에러 처리, 재시도 로직을 직접 다시 구현해야 합니다.</p>\n<hr>\n<p><strong>인공지:</strong> 둘째, 이미지를 Base64 인코딩해서 제이손 필드에 문자열로 추가. 단, 파일 크기가 약 삼 할 증가합니다.</p>\n<hr>\n<p><strong>인공지:</strong> 셋째, 미리 서명된 주소(presigned URL) 방식으로 이미지를 별도 저장소에 직접 올리고, 반환된 URL만 제이손에 포함. createPost API에는 imageUrl 문자열 필드 하나만 추가하면 됩니다.</p>\n<hr>\n<p><strong>병:</strong> 미리 서명된 주소 발급 API가 이미 있느냐? 다른 곳에서 쓰고 있는 것 없느냐?</p>\n<p><strong>인공지:</strong> 확인하겠습니다... 프로필 이미지 업로드에서 사용하는 /api/upload/presign API가 있습니다. 현재는 프로필 이미지 경로만 허용하도록 제한되어 있습니다.</p>\n<hr>\n<p><strong>병:</strong> 오. 이미 있구나. 게시글 이미지 경로를 추가하면 쓸 수 있느냐?</p>\n<p><strong>인공지:</strong> 허용 경로에 게시글 이미지 경로를 추가하면 사용 가능합니다.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 미리 서명된 주소 방식으로 가겠다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(끼어들며)</em> 잠깐. 왜 그것을 고르느냐?</p>\n<hr>\n<p><strong>병:</strong> 전하, 이 방식은 기존 것을 <strong>아무것도 안 건드리옵니다.</strong></p>\n<p><strong>병:</strong> apiClient를 안 건드리니 사십칠 개 호출이 안전하옵니다. createPost에는 imageUrl 문자열 하나만 추가하니 기존 세 군데에 영향이 없사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 그리고 이미 프로필 이미지에서 쓰고 있는 것이니, 새로 만들 것도 적사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 또한 이 방식이면, 이미지 파일은 별도로 올리고 폼에는 URL 문자열만 들어가옵니다.</p>\n<p><strong>병:</strong> 기존 조드 스키마에 imageUrl을 z.string().optional()로 추가하면 끝이옵니다. File 객체가 폼을 건드릴 일이 없사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 오... 계속해보라.</p>\n<hr>\n<p><strong>병:</strong> <em>(인공지에게)</em> 좋다. 가장 탈이 없을 부분부터 하자.</p>\n<p><strong>병:</strong> 먼저 createPost API에 imageUrl 선택적 필드 추가해라. 문자열이다. 없으면 null이다.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>병:</strong> 기존에 createPost 호출하는 세 군데, 다 동작하는지 확인해봐라.</p>\n<p><strong>인공지:</strong> 확인 결과, 세 군데 모두 정상 동작합니다. imageUrl을 안 보내면 null로 처리됩니다.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 다음, PostList에서 이미지 표시. imageUrl이 있으면 보여주고 없으면 안 보여주게.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>병:</strong> 기존 게시글들, 이미지 없는 것들 잘 나오느냐?</p>\n<p><strong>인공지:</strong> 확인 결과, imageUrl이 null인 경우 이미지 영역이 표시되지 않고, 기존과 동일하게 나옵니다.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 여기까지는 기존 코드에 아무 영향 없다. 맞느냐?</p>\n<p><strong>인공지:</strong> 맞습니다. 기존 기능 전부 정상 동작합니다.</p>\n<hr>\n<p><strong>병:</strong> 이제 PostForm 수정으로 가자. 이것은 복잡하니까 별도 갈래에서 해라. 기존 코드 안 건드리고.</p>\n<p><strong>인공지:</strong> 별도 갈래를 만들고 작업합니다.</p>\n<hr>\n<p><strong>병:</strong> 여기서 실험 하나 하자. 이미지 리사이징을 이쪽 브라우저에서 할지, 저쪽 서버에서 할지 결정해야 한다.</p>\n<p><strong>병:</strong> 둘 다 시험판을 만들어봐라. <strong>별도 파일</strong>로. 기존 코드에 절대 섞지 마라.</p>\n<hr>\n<p><strong>인공지:</strong> <em>(브라우저 버전과 서버 버전 시험판을 별도 파일로 제출한다)</em></p>\n<hr>\n<p><strong>병:</strong> 브라우저 버전, 용량 제한 어디까지 안정적이냐?</p>\n<p><strong>인공지:</strong> 브라우저 메모리 제한으로 10MB 이상은 불안정합니다.</p>\n<p><strong>병:</strong> 우리 쪽 이미지 용량 제한은?</p>\n<p><strong>인공지:</strong> 현재 5MB입니다.</p>\n<hr>\n<p><strong>병:</strong> 그러면 브라우저에서 해도 되겠다. 서버 버전 시험판은 버려라.</p>\n<hr>\n<h3 id=\"왕이-손을-든다\">[왕이 손을 든다]</h3>\n<hr>\n<p><strong>왕:</strong> 됐다. 거기까지 보겠다.</p>\n<hr>\n<h3 id=\"왕-세-사람을-바라본다\">[왕, 세 사람을 바라본다]</h3>\n<hr>\n<p><strong>왕:</strong> 과인이 보니 셋 다 지난번 교훈을 새겼구나.</p>\n<p><strong>왕:</strong> 갑은 용어도 쓰고, 정리도 시키고 나서 구현했다. 지난번보다 나아졌다.</p>\n<p><strong>왕:</strong> 을은 다섯 단계로 설계하고, 하나씩 확인하면서 구현했다. 훌륭했다.</p>\n<hr>\n<p><strong>왕:</strong> 그런데 갑과 을은 같은 구덩이에 빠졌다. 고치면 깨지고, 깨진 것 고치면 또 깨지고.</p>\n<p><strong>왕:</strong> 병만 그 구덩이를 피해갔다.</p>\n<hr>\n<p><strong>왕:</strong> 갑, 그대는 왜 실패했느냐?</p>\n<hr>\n<p><strong>갑:</strong> 전하, 소인이 생각해보았사옵니다.</p>\n<p><strong>갑:</strong> 소인은 기존 코드를 안 봤사옵니다. 이미지 업로드에만 집중했사옵니다.</p>\n<hr>\n<p><strong>갑:</strong> 에이피아이 클라이언특에 Content-Type이 고정되어 있다는 것을... 인공지한테 물어보지도 않았사옵니다.</p>\n<p><strong>갑:</strong> 병은 제일 먼저 그것을 물었사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 을, 그대는?</p>\n<hr>\n<p><strong>을:</strong> 전하, 소인은 설계를 했사옵니다. 다섯 단계로 나누고, 각각 기술도 정했사옵니다.</p>\n<p><strong>을:</strong> 그런데 <strong>새로 만들 것만</strong> 설계했사옵니다.</p>\n<hr>\n<p><strong>을:</strong> 기존 폼이 리액훅폼과 조드로 되어있는 것을 모르고 시작했사옵니다.</p>\n<p><strong>을:</strong> 새로 만든 것끼리는 잘 맞았는데, 기존 것과 맞물리는 순간 깨졌사옵니다.</p>\n<hr>\n<h3 id=\"맥락의-오염\">[맥락의 오염]</h3>\n<hr>\n<p><strong>왕:</strong> 병, 과인이 하나 더 묻겠다. 인공지가 빠르다 했다. 그러면 갑처럼 틀려도 빠르게 고치면 되지 않느냐? 왜 고칠수록 더 망가지느냐?</p>\n<hr>\n<p><strong>병:</strong> 전하, 아까 갑에게 이상한 일이 있었사옵니다.</p>\n<p><strong>왕:</strong> 이상한 일?</p>\n<hr>\n<p><strong>병:</strong> 갑이 &quot;Base64로 바꿔라&quot; 했사옵니다. 그런데 인공지가 아까 쓴 폼데이터 코드를 안 지우고 그대로 두었사옵니다.</p>\n<p><strong>병:</strong> 갑이 &quot;그거 안 된다고 했잖아!&quot;하고 화를 냈사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그래, 과인도 보았다. 인공지가 왜 그런 짓을 하느냐?</p>\n<hr>\n<p><strong>병:</strong> 전하, 인공지는 대화를 기억하옵니다. 앞에서 한 말, 앞에서 짠 코드, 그 모든 것이 맥락으로 쌓이옵니다.</p>\n<hr>\n<p><strong>병:</strong> 갑이 처음에 폼데이터로 시켰사옵니다. 인공지 머릿속에 &quot;이미지 업로드는 폼데이터&quot;라는 맥락이 생겼사옵니다.</p>\n<p><strong>병:</strong> 그 다음 Content-Type을 고쳤사옵니다. 맥락이 더 쌓였사옵니다.</p>\n<p><strong>병:</strong> 조건문도 추가했사옵니다. 또 쌓였사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 이제 &quot;Base64로 바꿔라&quot; 했사옵니다. 인공지는 새 지시를 받았지만, 앞에 쌓인 맥락을 제대로 버리지 못하옵니다.</p>\n<p><strong>병:</strong> 옛 방식 위에 새 방식을 또 얹으려 하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 왜 버리지 못하느냐?</p>\n<hr>\n<p><strong>병:</strong> 사람은 &quot;아 그러면 아까 그것도 바꿔야겠네&quot;하고 연관된 것을 스스로 챙기옵니다.</p>\n<p><strong>병:</strong> 인공지는 그렇지 못하옵니다. 새 지시만 보고, 아까 것과의 관계는 놓치옵니다.</p>\n<p><strong>병:</strong> 그래서 옛것과 새것이 뒤섞이옵니다. 그것이 누더기가 되는 것이옵니다.</p>\n<hr>\n<p><strong>병:</strong> 소인은 이것을 <strong>맥락의 오염</strong>이라 부르옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 맥락의 오염...</p>\n<hr>\n<p><strong>병:</strong> 한번 잘못된 것이 맥락에 들어가면, 그 다음 것도 오염되옵니다.</p>\n<p><strong>병:</strong> 고치면 고칠수록 맥락이 더 오염되옵니다. 오염된 맥락 위에서 또 고치니까, 더 꼬이는 것이옵니다.</p>\n<p><strong>병:</strong> 인공지가 맥락을 스스로 정리하는 것은 아직 약하옵니다. 언젠가 나아지겠지만, 아직은 그러하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그래서 그대는 어찌했느냐?</p>\n<hr>\n<p><strong>병:</strong> 전하, 소인은 맥락을 오염시키지 않으려 했사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 실험할 때는 별도 파일에서 했사옵니다. 시험판을 기존 코드에 안 섞었사옵니다.</p>\n<p><strong>병:</strong> 그래야 잘못된 것이 맥락에 안 쌓이옵니다.</p>\n<hr>\n<p><strong>병:</strong> 방향이 정해지면, 그때는 깨끗한 상태에서 시작했사옵니다. 별도 갈래에서, 처음부터 제대로 된 방식으로.</p>\n<p><strong>병:</strong> 잘못된 실험이 섞이지 않게.</p>\n<hr>\n<p><strong>왕:</strong> 그래서 시험판을 두 개 만들고, 하나를 버린 것이구나.</p>\n<p><strong>병:</strong> 그러하옵니다. 버린 시험판의 맥락이 남아서 다음 작업에 영향을 주면 안 되기 때문이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그리고 또 하나. 그대가 &quot;탈이 없을 것부터 하라&quot;고 했지.</p>\n<p><strong>병:</strong> 그러하옵니다.</p>\n<p><strong>왕:</strong> 왜 그래야 하느냐?</p>\n<hr>\n<p><strong>병:</strong> 탈이 없는 것을 먼저 하면, 기존 것이 무사한지 바로 확인할 수 있사옵니다.</p>\n<p><strong>병:</strong> 확인이 되면 그 위에 다음 것을 쌓아도 안전하옵니다.</p>\n<p><strong>병:</strong> 위험한 것부터 하면, 무너졌을 때 어디서 무너진 것인지 알 수가 없사옵니다. 이미 여러 개를 바꿔놨으니까요.</p>\n<hr>\n<h3 id=\"왕의-비유\">[왕의 비유]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(잠시 생각하다가)</em> 비유하자면... 천리마와 같구나.</p>\n<p><strong>병:</strong> 천리마 말이옵니까?</p>\n<hr>\n<p><strong>왕:</strong> 천리마가 달리는 것은 빠르다. 하루에 천 리를 간다.</p>\n<p><strong>왕:</strong> 그런데 방향이 틀렸다면? 천 리를 되돌아와야 한다.</p>\n<hr>\n<p><strong>왕:</strong> 느린 말이었으면 십 리만 돌아오면 됐을 것을, 천리마라서 천 리를 돌아와야 하느니라.</p>\n<p><strong>왕:</strong> 빠를수록 방향이 더 중요하다.</p>\n<hr>\n<p><strong>왕:</strong> 게다가... 천리마가 전력질주하다가 급히 멈추면 어찌 되느냐?</p>\n<p><strong>병:</strong> 넘어지옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 그렇다. 갑이 그랬다. 빠르게 고쳤다. 또 빠르게 고쳤다.</p>\n<p><strong>왕:</strong> 전력질주하다가 급히 방향을 틀었더니... 넘어졌다. 처음보다 못해졌다.</p>\n<hr>\n<p><strong>왕:</strong> 그리고... 넘어질 때마다 길바닥에 뒹굴면서 흙이 묻었구나. 맥락의 오염이란 것이 그것이었다.</p>\n<p><strong>왕:</strong> 다시 달리려 해도 몸에 묻은 흙 때문에 더 느려지고, 더 넘어지고.</p>\n<hr>\n<p><strong>왕:</strong> 인공지가 천리마구나. <strong>빠르기 때문에 오히려 방향이 더 중요하다.</strong></p>\n<hr>\n<p><strong>왕:</strong> 이것을 <strong>&quot;천리마의 역설&quot;</strong>이라 부르겠다.</p>\n<p><strong>병:</strong> 명언이시옵니다, 전하.</p>\n<hr>\n<h3 id=\"을의-깨달음\">[을의 깨달음]</h3>\n<hr>\n<p><strong>왕:</strong> 을, 그대는 오늘 무엇을 깨달았느냐?</p>\n<hr>\n<p><strong>을:</strong> 전하, 소인이 지난번에 두 가지를 배웠사옵니다. 설계가 먼저다, 확인하면서 가라.</p>\n<p><strong>을:</strong> 오늘 둘 다 했사옵니다. 그런데도 빠졌사옵니다.</p>\n<hr>\n<p><strong>을:</strong> 빠뜨린 것이 있었사옵니다.</p>\n<p><strong>을:</strong> <strong>새것만 설계하고, 옛것을 안 봤사옵니다.</strong></p>\n<hr>\n<p><strong>을:</strong> 빈 땅에 집을 짓는 것과, 이미 집이 있는 곳에 방을 늘리는 것은 다르옵니다.</p>\n<p><strong>을:</strong> 기존에 뭐가 있는지, 어디에 기둥이 있는지, 무엇이 연결되어 있는지... 이것을 먼저 봤어야 했사옵니다.</p>\n<hr>\n<p><strong>을:</strong> 그리고 한 가지 더 있사옵니다.</p>\n<p><strong>왕:</strong> 말해보라.</p>\n<hr>\n<p><strong>을:</strong> 소인이 기존 폼에 File 객체를 직접 넣으려다 밸리데이션 지옥에 빠졌사옵니다.</p>\n<p><strong>을:</strong> 병은 미리 서명된 주소 방식을 골라서, 폼에는 URL 문자열만 넣었사옵니다.</p>\n<hr>\n<p><strong>을:</strong> 소인이 더 놀란 것은, 병이 그것을 <strong>구현하기 전에</strong> 알았다는 것이옵니다.</p>\n<p><strong>을:</strong> 기존 코드를 분석하고 방식을 고른 다음에야 구현에 들어갔사옵니다.</p>\n<p><strong>을:</strong> 소인은 방식을 안 고르고 바로 구현부터 했사옵니다. 기존 코드와 부딪히고 나서야 문제를 알았사옵니다.</p>\n<hr>\n<p><strong>을:</strong> <strong>부딪히기 전에 알 수 있었던 것</strong>을, 부딪힌 다음에 안 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(미소 지으며)</em> 오늘 제대로 배웠구나.</p>\n<p><strong>을:</strong> 전하의 가르침 덕이옵니다.</p>\n<hr>\n<h3 id=\"왕의-결론\">[왕의 결론]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘의 깨달음을 기록하라.</p>\n<p><strong>내관:</strong> <em>(붓을 들며)</em> 예, 전하.</p>\n<hr>\n<p><strong>왕:</strong> <strong>첫째, 천리마가 빠를수록 방향이 더 중요하듯, 인공지가 빠를수록 처음 방향을 잘 잡아야 한다. &quot;틀리면 다시 하면 되지&quot;는 통하지 않는다.</strong></p>\n<p><strong>내관:</strong> <em>(받아 적으며)</em></p>\n<p><strong>왕:</strong> 갑이 보여줬다. 빠르게 고쳤다. 또 빠르게 고쳤다. 그런데 고칠수록 더 망가졌다. 처음보다 못해졌다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>둘째, 넘어질 때마다 흙이 묻듯, 인공지는 잘못된 대화가 쌓이면 맥락이 오염된다. 오염된 맥락 위에서 고치면 더 꼬인다.</strong></p>\n<p><strong>왕:</strong> 갑이 보여줬다. &quot;Base64로 바꿔라&quot; 했는데 인공지가 아까 폼데이터 코드를 안 버렸다. 이것이 맥락의 오염이다. 실험은 격리해야 하고, 맥락이 오염되면 새로 시작해야 한다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>셋째, 빈 땅에 집 짓는 것과, 남의 집에 방 늘리는 것은 다르다. 새것을 설계하기 전에 옛것부터 파악하라.</strong></p>\n<p><strong>왕:</strong> 을이 보여줬다. 새 기능은 훌륭하게 설계했으나, 기존 폼이 리액훅폼과 조드로 되어있는 줄도 모르고 시작했다. 부딪히기 전에 알 수 있었던 것을 부딪힌 다음에 알았다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>넷째, 성벽 밑돌부터 놓아야 무너져도 어디서 무너졌는지 안다. 안전한 것부터 쌓아올려라.</strong></p>\n<p><strong>왕:</strong> 병이 보여줬다. 기존 코드에 영향 없는 것부터, 하나씩 확인하면서 올렸다. 위험한 것부터 건드리면 무너졌을 때 원인을 찾기 어렵다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>다섯째, 실험은 많이 하되, 적용은 신중히 하라.</strong></p>\n<p><strong>왕:</strong> 병이 시험판을 두 개 만들어 비교하고 하나를 버렸다. 실험은 아끼지 않았다. 그러나 기존 코드에 적용할 때는 하나씩 확인하면서 했다.</p>\n<hr>\n<p><strong>영의정·좌의정:</strong> 명심하겠사옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 다음 칠일 후에 다시 보겠다. 오늘 본 것을 바탕으로, 또 무엇을 알아야 하는지 찾아오라.</p>\n<hr>\n<h3 id=\"막-내림\">[막 내림]</h3>\n<hr>\n<p><strong>- 제3화 끝 -</strong></p>\n<p><strong>다음 화: 제4화 - 익숙함의 감옥</strong></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@teo/%EC%A1%B0%EC%84%A0%EA%B0%9C%EB%B0%9C%EC%8B%A4%EB%A1%9D-%EC%B2%9C%EB%A6%AC%EB%A7%88%EC%9D%98-%EC%97%AD%EC%84%A4-%E5%8D%83%E9%87%8C%E9%A6%AC%E9%80%86%E8%AA%AA-gwe11ttq"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "조선개발실록 - 제2화: 사상누각 (沙上樓閣)",
    "partialText": "<h1 id=\"제2화-사상누각-沙上樓閣\">제2화: 사상누각 (沙上樓閣)</h1>\n<h2 id=\"모래-위에-집을-짓지-마라\">&quot;모래 위에 집을 짓지 마라&quot;</h2>\n<hr>\n<h3 id=\"경복궁-근정전-두-번째-보고일\">[경복궁 근정전, 두 번째 보고일]</h3>\n<hr>\n<p><strong>왕:</strong> 칠일이 또 지났다. 그간 무엇을 찾았느냐?</p>\n<p><strong>영의정:</strong> 전하, 지난번 병(丙)의 방식을 연구해보았사옵니다.</p>\n<p><strong>왕:</strong> 그래서?</p>\n<hr>\n<p><strong>영의정:</strong> 병이 인공지를 쪼개서 부린다는 것은 알겠사옵니다. 그런데... 어떤 <strong>순서</strong>로 쪼개야 하는지가 관건인 것 같사옵니다.</p>\n<p><strong>왕:</strong> 오, 순서라. 좌의정은?</p>\n<hr>\n<p><strong>좌의정:</strong> 전하, 신도 같은 생각이옵니다. 쪼개는 것까지는 알겠는데, <strong>무엇을 먼저 시키고 무엇을 나중에 시켜야 하는지</strong>... 그것이 핵심인 것 같사옵니다.</p>\n<p><strong>왕:</strong> 좋다. 오늘은 그것을 보겠다. 술사들을 부르라.</p>\n<hr>\n<h3 id=\"갑-을-병이-입장한다\">[갑, 을, 병이 입장한다]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘은 다른 문제를 내겠다. <em>(두루마리를 펼치며)</em> </p>\n<p><strong>왕:</strong> 새로운 기능을 만들어야 한다. 유저가 상품을 장바구니에 담고, 수량을 조절하고, 쿠폰을 적용하고, 최종 가격을 계산하는 기능이다.</p>\n<hr>\n<p><strong>왕:</strong> 단, 기존 시스템과 연동되어야 한다. 상품 정보는 상품방(商品房)에서 가져오고, 쿠폰 정보는 쿠폰방(券房)에서 가져오고, 재고 확인은 창고방(倉庫房)에서 가져와야 한다.</p>\n<hr>\n<p><strong>왕:</strong> 인공지를 써서 만들어라. 과인이 지켜보겠다.</p>\n<p><strong>왕:</strong> 갑, 먼저 하라.</p>\n<hr>\n<h3 id=\"갑의-시도\">[갑의 시도]</h3>\n<hr>\n<p><strong>갑:</strong> <em>(지난번 교훈을 떠올리며)</em> 이번에는 용어를 제대로 써야겠다.</p>\n<p><strong>갑:</strong> <em>(인공지에게)</em> 장바구니 기능 만들어라. 리액쿼리로 서버 상태 관리하고, 주스탄드로 클라이언트 상태 관리해라.</p>\n<hr>\n<p><strong>갑:</strong> 상품 담기는 옵티미스틱 업데이트로 처리하고, 쿠폰 적용은 유즈멤모로 메모이제이션해라. 가격 계산 로직은 퓨어 펑션으로 분리하고.</p>\n<hr>\n<p><strong>갑:</strong> 에이피아이 호출은 어댑터 패턴으로 추상화하고, 에러 핸들링은 에러 바운더리로 잡아라.</p>\n<p><strong>인공지:</strong> <em>(한참 작업 후 결과를 내놓는다)</em></p>\n<hr>\n<p><strong>갑:</strong> <em>(뿌듯하게)</em> 전하, 완료되었사옵니다. 이번에는 용어를 제대로 썼사옵니다.</p>\n<p><strong>왕:</strong> 오, 그래? 어디 보자. <em>(코드를 살펴보며)</em> 이 코드가 몇 줄이냐?</p>\n<p><strong>내관:</strong> 천이백 줄이옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 천이백 줄... 갑, 이 코드가 어떻게 동작하는지 설명해보아라.</p>\n<p><strong>갑:</strong> 전하, 이 부분이 리액쿼리로 상품 정보를 가져오는 부분이고... <em>(코드를 보다가 멈칫)</em></p>\n<p><strong>왕:</strong> 왜 그러느냐?</p>\n<hr>\n<p><strong>갑:</strong> 잠시만요, 전하. <em>(코드를 더 살피며)</em> 이 부분이... 소인이 옵티미스틱 업데이트라 했는데...</p>\n<p><strong>갑:</strong> <em>(한참 들여다보다가)</em> 이상하옵니다. 어댑터 패턴으로 추상화하라 했는데, 여기는 직접 호출하고 있고...</p>\n<hr>\n<p><strong>갑:</strong> <em>(다른 부분을 보며)</em> 여기는 또... 주스탄드랑 리액쿼리가 같은 데이터를 따로 관리하고 있사옵니다. 이러면 안 맞을 텐데...</p>\n<p><strong>왕:</strong> 그대가 시킨 대로 안 된 것이냐?</p>\n<p><strong>갑:</strong> 전하, 용어는 다 썼는데... 어떻게 엮이는지를 안 정해줘서 인공지가 제 나름대로 엮은 것 같사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그래서 지금 어찌 동작하는지 아느냐?</p>\n<p><strong>갑:</strong> <em>(고개를 숙이며)</em> 솔직히... 잘 모르겠사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 흠... 지난번보다는 나아졌다. 용어를 쓰니 인공지가 알아듣기는 했구나. 그런데 그대가 결과를 모르면 무슨 소용이냐?</p>\n<hr>\n<h3 id=\"을의-시도\">[을의 시도]</h3>\n<hr>\n<p><strong>왕:</strong> 을, 네 차례다.</p>\n<p><strong>을:</strong> <em>(생각하며)</em> 지난번에 한꺼번에 시켜서 문제였다. 이번엔 쪼개서 시키자. 용어도 쓰고.</p>\n<hr>\n<p><strong>을:</strong> <em>(인공지에게)</em> 먼저 장바구니에 상품 담는 기능 만들어라. 주스탄드로 상태 관리해라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> <em>(확인하며)</em> 좋아, 잘 나왔다. 다음, 수량 조절 기능 추가해라. 옵티미스틱 업데이트로.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> 다음, 쿠폰 적용 기능 추가해라. 쿠폰방 에이피아이 연동하고.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> 다음, 가격 계산 기능 추가해라. 퓨어 펑션으로.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> 다음, 상품방 에이피아이 연동해라. 리액쿼리로.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> 다음, 창고방 에이피아이 연동해라. 재고 확인용으로.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>을:</strong> <em>(뿌듯하게)</em> 전하, 완료되었사옵니다. 이번에는 용어도 쓰고, 쪼개서 시켰사옵니다.</p>\n<p><strong>왕:</strong> 오, 지난번 교훈을 잘 새겼구나. 어디 실행해보아라.</p>\n<hr>\n<p><strong>을:</strong> <em>(실행한다)</em> ...어?</p>\n<p><strong>왕:</strong> 왜 그러느냐?</p>\n<p><strong>을:</strong> 전하, 에러가 나옵니다...</p>\n<hr>\n<p><strong>왕:</strong> 무슨 에러냐?</p>\n<p><strong>을:</strong> <em>(에러를 보며)</em> 쿠폰을 적용하는데... 상품 카테고리 정보가 없다고...</p>\n<hr>\n<p><strong>왕:</strong> 왜 카테고리가 필요하냐?</p>\n<p><strong>을:</strong> 아... 쿠폰이 특정 카테고리에만 적용되는 경우가 있사옵니다. 그런데 소인이 그걸 미리 생각 못 했사옵니다.</p>\n<p><strong>왕:</strong> 또 다른 문제는 없느냐?</p>\n<hr>\n<p><strong>을:</strong> <em>(더 살펴보며)</em> 전하, 재고 확인하는 시점이... 이상하옵니다. 장바구니에 담을 때 확인해야 하는데, 지금은 마지막에 확인하고 있사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 왜 그리 되었느냐?</p>\n<p><strong>을:</strong> 소인이 창고방 연동을 마지막에 시켜서... 인공지가 마지막에 넣어버린 것 같사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 또 있느냐?</p>\n<p><strong>을:</strong> <em>(더 살펴보며)</em> 전하, 이상한 것이 있사옵니다. 소인이 시키지 않은 것들이 들어가 있사옵니다.</p>\n<p><strong>왕:</strong> 시키지 않은 것?</p>\n<hr>\n<p><strong>을:</strong> 위시리스트 연동이 들어가 있사옵니다. 소인은 장바구니만 시켰는데...</p>\n<p><strong>을:</strong> 그리고 최근 본 상품 기능도 들어가 있사옵니다. 소인은 이것도 안 시켰사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 인공지가 알아서 넣은 것이냐?</p>\n<p><strong>을:</strong> 그런 것 같사옵니다. &quot;장바구니 기능&quot;이라 하니까 관련된 것을 알아서...</p>\n<hr>\n<p><strong>을:</strong> <em>(급히)</em> 소인이 고쳐보겠사옵니다. <em>(인공지에게)</em> 위시리스트 연동 빼라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> <em>(확인하며)</em> ...전하, 위시리스트를 빼니까 장바구니 담기가 안 되옵니다.</p>\n<p><strong>왕:</strong> 왜 그러느냐?</p>\n<p><strong>을:</strong> 인공지가 위시리스트랑 장바구니를 엮어놔서... 하나를 빼니까 다른 게 깨진 것 같사옵니다.</p>\n<hr>\n<p><strong>을:</strong> <em>(다시 시도하며)</em> 장바구니 담기 다시 고쳐라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<p><strong>을:</strong> <em>(확인하며)</em> ...이번에는 수량 조절이 안 되옵니다.</p>\n<hr>\n<p><strong>을:</strong> <em>(한숨)</em> 전하, 고치면 고칠수록 더 꼬이옵니다...</p>\n<hr>\n<p><strong>왕:</strong> 을, 그대는 지난번 교훈대로 용어도 쓰고 쪼개서 시켰다. 그런데 왜 문제가 생겼느냐?</p>\n<p><strong>을:</strong> <em>(생각하다가)</em> 전하, 소인이 쪼개기는 했는데... 순서가 잘못된 것 같사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 순서?</p>\n<p><strong>을:</strong> 기능 순서대로 시켰사옵니다. 담기, 수량 조절, 쿠폰, 가격 계산... 그런데 전체 그림 없이 하나씩 시키니까, 나중에 안 맞는 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 흠... 쪼개긴 쪼갰는데, 뭔가 빠진 것이 있구나.</p>\n<hr>\n<h3 id=\"병의-시도\">[병의 시도]</h3>\n<hr>\n<p><strong>왕:</strong> 병, 네 차례다.</p>\n<hr>\n<p><strong>병:</strong> <em>(인공지에게)</em> 잠깐. 만들기 전에 먼저 정리하자.</p>\n<hr>\n<p><strong>병:</strong> 장바구니 기능에서 외부 의존성이 세 개다. 상품방, 쿠폰방, 창고방. 각각에서 어떤 데이터를 가져와야 하는지 정리해라.</p>\n<hr>\n<p><strong>인공지:</strong> 정리 결과입니다. </p>\n<p><strong>인공지:</strong> 상품방: 상품 ID, 이름, 가격, 카테고리, 이미지 URL.</p>\n<hr>\n<p><strong>인공지:</strong> 쿠폰방: 쿠폰 코드, 할인율, 적용 가능 카테고리, 최소 주문 금액, 유효기간.</p>\n<hr>\n<p><strong>인공지:</strong> 창고방: 상품별 재고 수량, 재고 상태.</p>\n<hr>\n<p><strong>병:</strong> 빠진 거 있다. 상품방에서 할인가 정보도 필요하고, 창고방에서 예약 수량도 확인해야 한다. 추가해라.</p>\n<p><strong>인공지:</strong> 수정합니다.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 이제 핵심 흐름을 정리해봐라. 유저 관점에서 어떤 순서로 동작해야 하냐?</p>\n<hr>\n<p><strong>인공지:</strong> 핵심 흐름입니다.</p>\n<p><strong>인공지:</strong> 1) 유저가 상품 선택 → 2) 재고 확인 → 3) 장바구니에 담기 → 4) 수량 변경 시 재고 재확인 → 5) 쿠폰 선택 → 6) 쿠폰 적용 가능 여부 확인 → 7) 최종 가격 계산.</p>\n<hr>\n<p><strong>병:</strong> 결제 직전에 최종 재고 재확인도 해야 하지 않냐?</p>\n<p><strong>인공지:</strong> 맞습니다. 8) 결제 진행 전 최종 재고 재확인 추가.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 이 흐름에서 엣지 케이스를 생각해봐라. 뭐가 잘못될 수 있냐?</p>\n<hr>\n<p><strong>인공지:</strong> 엣지 케이스입니다.</p>\n<p><strong>인공지:</strong> 1) 담는 중 재고 소진 2) 수량 변경 시 재고 부족 3) 쿠폰 적용 불가 카테고리 4) 쿠폰 최소 금액 미달 5) 쿠폰 유효기간 만료 6) 결제 전 재고 변동 7) 동시에 여러 유저가 같은 상품 담기.</p>\n<hr>\n<p><strong>병:</strong> 일곱 번째, 동시성 문제는 이번 범위에서 빼자. 복잡도가 올라간다. 나머지 여섯 개만 처리하자.</p>\n<p><strong>인공지:</strong> 알겠습니다. 동시성 문제 제외.</p>\n<hr>\n<p><strong>병:</strong> 이제 컴포넌특 구조를 어떻게 나눌지 제안해봐라.</p>\n<hr>\n<p><strong>인공지:</strong> 컴포넌특 구조입니다.</p>\n<p><strong>인공지:</strong> 최상위 CartPage, 하위에 CartItemList, CartItem, CouponSelector, PriceSummary.</p>\n<p><strong>인공지:</strong> 훅으로는 useCart, useProduct, useCoupon, useInventory.</p>\n<p><strong>인공지:</strong> 추가로 위시리스트 연동을 위한 useWishlist, 최근 본 상품을 위한 useRecentProducts도 필요합니다.</p>\n<hr>\n<p><strong>병:</strong> 잠깐. 위시리스트랑 최근 본 상품은 어디서 나온 것이냐?</p>\n<p><strong>인공지:</strong> 장바구니 기능에서 일반적으로 함께 제공되는 기능입니다.</p>\n<hr>\n<p><strong>병:</strong> 아니다. 이번 범위에 없다. 빼라.</p>\n<p><strong>인공지:</strong> 수정합니다. useWishlist, useRecentProducts 제외.</p>\n<hr>\n<p><strong>왕:</strong> <em>(끼어들며)</em> 병, 잠깐. 인공지가 알아서 넣으려 한 것이 아까 을한테 일어난 일 아니냐?</p>\n<p><strong>병:</strong> 전하, 정확하옵니다. 범위를 안 쳐주면 인공지가 알아서 판단하옵니다. 그래서 미리 잡아준 것이옵니다.</p>\n<p><strong>왕:</strong> 오... 계속해보라.</p>\n<hr>\n<p><strong>병:</strong> 그리고 훅 분리가 이상하다. useProduct랑 useInventory가 따로 있으면 상품 담을 때 호출이 두 번이다. 다시 생각해봐라.</p>\n<hr>\n<p><strong>인공지:</strong> 수정합니다. useProductWithStock으로 합쳐서 상품 정보와 재고를 같이 가져오게 합니다.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 이 구조로 타입 정의부터 해라. 구현은 하지 마라. 인터페이스만.</p>\n<p><strong>인공지:</strong> <em>(타입 정의를 내놓는다)</em></p>\n<hr>\n<p><strong>병:</strong> CartItem 타입에 쿠폰 적용 후 가격 필드가 빠졌다. 추가해라.</p>\n<p><strong>인공지:</strong> <em>(수정)</em></p>\n<hr>\n<p><strong>병:</strong> 좋다. 이제 useProductWithStock부터 구현해라. 리액쿼리 패턴대로. 끝나면 테스트 시나리오 세 가지만 작성해라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>병:</strong> <em>(결과 확인)</em> 재고 부족 케이스에서 에러 메시지가 하드코딩이다. 상수로 빼라.</p>\n<p><strong>인공지:</strong> <em>(수정)</em></p>\n<hr>\n<p><strong>병:</strong> 좋다. 다음 useCart 구현해라.</p>\n<hr>\n<h3 id=\"왕이-손을-든다\">[왕이 손을 든다]</h3>\n<hr>\n<p><strong>왕:</strong> 됐다. 과인이 충분히 보았다.</p>\n<hr>\n<h3 id=\"왕-세-사람을-바라본다\">[왕, 세 사람을 바라본다]</h3>\n<hr>\n<p><strong>왕:</strong> 셋 다 지난번 교훈을 새겼구나. 용어를 쓰려고 노력했다.</p>\n<p><strong>왕:</strong> 갑은 리액쿼리, 주스탄드, 옵티미스틱 업데이트, 어댑터 패턴... 용어를 많이 썼다.</p>\n<p><strong>왕:</strong> 을도 주스탄드, 옵티미스틱 업데이트, 퓨어 펑션... 용어를 썼고, 쪼개서 시켰다.</p>\n<p><strong>왕:</strong> 그런데 왜 병만 제대로 됐느냐?</p>\n<hr>\n<h3 id=\"잠시-침묵\">[잠시 침묵]</h3>\n<hr>\n<p><strong>왕:</strong> 갑, 그대는 왜 실패했느냐?</p>\n<p><strong>갑:</strong> 전하, 소인은 용어는 썼으나... 한꺼번에 시켰사옵니다. 그래서 결과가 나오긴 했는데, 어떻게 엮여 있는지 소인도 모르겠사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 을, 그대는 쪼개서 시켰는데 왜 실패했느냐?</p>\n<p><strong>을:</strong> 전하, 소인이 생각해보니... <strong>쪼개는 방식</strong>이 달랐사옵니다.</p>\n<p><strong>왕:</strong> 쪼개는 방식?</p>\n<hr>\n<p><strong>을:</strong> 지난번에 병이 한 것은... &quot;이게 맞나?&quot; 확인하면서 쪼갠 것이었사옵니다. </p>\n<p><strong>을:</strong> 소인이 오늘 한 것은... 그냥 일을 나눠서 시킨 것이었사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 오. 그 차이가 뭐냐?</p>\n<p><strong>을:</strong> <em>(생각하며)</em> 병은 &quot;책임이 몇 개냐?&quot; 물어보고 &quot;아니다, 네 개다&quot; 하고 잡아줬사옵니다. <strong>맥락을 맞춰가며</strong> 쪼갠 것이옵니다.</p>\n<p><strong>을:</strong> 소인은 그냥 &quot;담기 해라&quot;, &quot;수량 조절 해라&quot;, &quot;쿠폰 해라&quot;... <strong>기능 순서대로</strong> 쪼갠 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 아... 같은 &quot;쪼개기&quot;인데 다른 것이구나.</p>\n<p><strong>을:</strong> 그러하옵니다, 전하. 소인이 헷갈렸사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 병, 그대가 설명해보라. 이 둘이 어찌 다르냐?</p>\n<hr>\n<p><strong>병:</strong> 전하, 쪼개기에는 두 가지가 있사옵니다.</p>\n<p><strong>병:</strong> 하나는 <strong>확인하며 쪼개기</strong>이옵니다. &quot;이게 맞나?&quot; &quot;이 방향이 맞나?&quot; 중간중간 확인하는 것이옵니다. 지난번에 소인이 한 것이 이것이옵니다.</p>\n<hr>\n<p><strong>병:</strong> 다른 하나는 <strong>일을 나눠서 쪼개기</strong>이옵니다. 큰 일을 작은 일로 나누는 것이옵니다. 을이 오늘 한 것이 이것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 둘 다 필요한 것 아니냐?</p>\n<p><strong>병:</strong> 그러하옵니다, 전하. 그런데 <strong>순서</strong>가 있사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 순서?</p>\n<p><strong>병:</strong> 일을 나누기 <strong>전에</strong>, 먼저 전체 그림을 그려야 하옵니다. 그 그림을 그릴 때 확인하며 쪼개기를 하는 것이옵니다.</p>\n<p><strong>병:</strong> 그림이 완성되면, 그제야 일을 나눠서 쪼개는 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 을은 그림 없이 바로 일을 나눴다?</p>\n<p><strong>병:</strong> 그러하옵니다. 그래서 나중에 &quot;어? 카테고리가 필요했네?&quot; &quot;어? 재고 확인 시점이 틀렸네?&quot; 하게 된 것이옵니다.</p>\n<hr>\n<h3 id=\"왕-고개를-끄덕인다\">[왕, 고개를 끄덕인다]</h3>\n<hr>\n<p><strong>왕:</strong> 그러면 그대는 오늘 무엇을 먼저 했느냐?</p>\n<p><strong>병:</strong> 전하, 소인은 구현하기 전에 여섯 단계를 거쳤사옵니다.</p>\n<hr>\n<p><strong>병:</strong> 하나, 외부 데이터 정리. 어떤 데이터가 필요한지.</p>\n<p><strong>병:</strong> 둘, 핵심 흐름 정리. 유저 관점에서 어떤 순서로 동작하는지.</p>\n<p><strong>병:</strong> 셋, 엣지 케이스 정리. 뭐가 잘못될 수 있는지.</p>\n<hr>\n<p><strong>병:</strong> 넷, 범위 설정. 이번에 할 것과 안 할 것.</p>\n<p><strong>병:</strong> 다섯, 구조 설계. 컴포넌특과 훅을 어떻게 나눌지.</p>\n<p><strong>병:</strong> 여섯, 인터페이스 정의. 타입을 먼저 정의.</p>\n<hr>\n<p><strong>병:</strong> 그제야 구현을 시켰사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 과인이 세어보니, 구현 전에 여섯 단계를 거쳤다.</p>\n<p><strong>왕:</strong> 을은 몇 단계를 거쳤느냐?</p>\n<p><strong>을:</strong> <em>(머쓱하게)</em> 전하, 소인은... 바로 구현을 시켰사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 왜 이 순서여야 하느냐?</p>\n<p><strong>병:</strong> 전하, <strong>앞 단계가 틀리면 뒤가 다 틀리기 때문</strong>이옵니다.</p>\n<hr>\n<p><strong>병:</strong> 데이터 정리가 잘못되면, 나중에 &quot;이 필드가 없네?&quot; 하고 처음부터 다시 해야 하옵니다. 을이 카테고리를 빠뜨린 것처럼요.</p>\n<hr>\n<p><strong>병:</strong> 흐름 정리가 잘못되면, 나중에 &quot;재고 확인 시점이 이상하네?&quot; 하고 구조를 갈아엎어야 하옵니다. 을이 재고 확인 순서가 틀린 것처럼요.</p>\n<hr>\n<p><strong>병:</strong> 범위를 안 치면, 작업하다가 &quot;이것도 해야 하나? 저것도 해야 하나?&quot; 계속 늘어나옵니다. 동시성 문제처럼 복잡한 게 들어오면 끝이 안 나옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그래서 <strong>설계가 먼저</strong>라는 것이구나.</p>\n<p><strong>병:</strong> 그러하옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 집을 지을 때 터를 닦고 기둥을 세우듯, 코드도 순서가 있다.</p>\n<p><strong>왕:</strong> 설계도 없이 벽돌부터 쌓으면, 아무리 좋은 벽돌이어도 무너진다.</p>\n<p><strong>왕:</strong> 사상누각(沙上樓閣)이로구나. 모래 위에 집을 지은 것이다.</p>\n<hr>\n<p><strong>병:</strong> 명언이시옵니다, 전하.</p>\n<hr>\n<h3 id=\"왕-갑을-바라본다\">[왕, 갑을 바라본다]</h3>\n<hr>\n<p><strong>왕:</strong> 갑, 그대도 마찬가지다. 용어를 잘 썼으나, 설계 없이 한꺼번에 시켰다.</p>\n<p><strong>왕:</strong> 그래서 결과가 나오긴 했는데, 그대가 그것을 이해 못 한다. 내가 이해 못 하는 집에서 어찌 살겠느냐?</p>\n<p><strong>갑:</strong> <em>(고개를 숙이며)</em> 명심하겠사옵니다, 전하.</p>\n<hr>\n<h3 id=\"왕-잠시-생각하다가\">[왕, 잠시 생각하다가]</h3>\n<hr>\n<p><strong>왕:</strong> 그런데 과인이 이상한 게 있다. 이것은 인공지 쓰는 법인가, 일하는 법인가?</p>\n<hr>\n<p><strong>병:</strong> <em>(잠시 생각하다가)</em> 전하, 똑같사옵니다.</p>\n<p><strong>왕:</strong> 똑같다?</p>\n<hr>\n<p><strong>병:</strong> 사람한테 일 시킬 때도 이래야 하옵니다.</p>\n<p><strong>병:</strong> 신입한테 &quot;장바구니 만들어&quot;하고 던지면, 갑처럼 되옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 허허...</p>\n<p><strong>병:</strong> &quot;담기부터 해, 수량 조절 해, 쿠폰 해&quot;하고 쪼개서 시켜도, 전체 설계 없이 시키면 을처럼 되옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그러면?</p>\n<p><strong>병:</strong> &quot;어떤 데이터 필요한지 정리해봐&quot;, &quot;흐름 그려봐&quot;, &quot;엣지 케이스 뽑아봐&quot;...</p>\n<p><strong>병:</strong> 이렇게 시킨 다음, 검토하고, 틀린 부분 잡아주고, 그 다음에 구현 시키는 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 사람이나 인공지나 같다는 말이구나.</p>\n<p><strong>병:</strong> 그러하옵니다, 전하.</p>\n<hr>\n<h3 id=\"왕이-을을-바라본다\">[왕이 을을 바라본다]</h3>\n<hr>\n<p><strong>왕:</strong> 을, 그대는 오늘 무엇을 깨달았느냐?</p>\n<hr>\n<p><strong>을:</strong> 전하, 소인이 지난번에 &quot;쪼개서 시켜야 한다&quot;는 것을 배웠사옵니다.</p>\n<p><strong>을:</strong> 그래서 오늘 쪼개서 시켰사옵니다. 담기, 수량 조절, 쿠폰, 가격 계산...</p>\n<hr>\n<p><strong>을:</strong> 그런데 병을 보니 다르옵니다.</p>\n<p><strong>을:</strong> 병은 바로 만들라 하지 않았사옵니다. &quot;정리해봐라&quot;, &quot;흐름 그려봐라&quot;, &quot;엣지 케이스 뽑아봐라&quot;...</p>\n<hr>\n<p><strong>을:</strong> 인공지가 뭔가 내놓으면 &quot;이건 아니다&quot;, &quot;이건 빠졌다&quot; 하며 잡아줬사옵니다.</p>\n<p><strong>을:</strong> 그렇게 <strong>설계를 같이 만들어간</strong> 다음에야 구현을 시켰사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그래서?</p>\n<p><strong>을:</strong> 소인은 설계를 건너뛰고 바로 &quot;만들어라&quot;만 시킨 것이옵니다.</p>\n<p><strong>을:</strong> 그러니 인공지가 제멋대로 한 것이옵니다. 위시리스트도 넣고, 최근 본 상품도 넣고...</p>\n<hr>\n<p><strong>왕:</strong> 아... 설계를 같이 잡아가지 않으니, 인공지가 알아서 판단해버린 것이구나.</p>\n<p><strong>을:</strong> 그러하옵니다, 전하. <strong>확인하면서 가야 했는데</strong>, 소인은 그냥 시키기만 한 것이옵니다.</p>\n<hr>\n<p><strong>을:</strong> 그리고 한 가지 더 깨달은 것이 있사옵니다.</p>\n<p><strong>왕:</strong> 말해보라.</p>\n<hr>\n<p><strong>을:</strong> 병이 엣지 케이스를 뽑으라 했을 때, 인공지가 일곱 개를 뽑았사옵니다.</p>\n<p><strong>을:</strong> 그런데 병이 &quot;일곱 번째는 빼자&quot;라고 했사옵니다.</p>\n<hr>\n<p><strong>을:</strong> 소인이라면 &quot;인공지가 뽑았으니 다 해야지&quot; 했을 것이옵니다.</p>\n<p><strong>을:</strong> 병은 <strong>할 것과 안 할 것을 정해줬사옵니다</strong>. 그래서 인공지가 딴 길로 안 샌 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(미소 지으며)</em> 오늘 제대로 배웠구나.</p>\n<p><strong>을:</strong> 전하의 가르침 덕이옵니다.</p>\n<hr>\n<h3 id=\"왕의-결론\">[왕의 결론]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘의 깨달음을 기록하라.</p>\n<p><strong>내관:</strong> <em>(붓을 들며)</em> 예, 전하.</p>\n<hr>\n<p><strong>왕:</strong> <strong>첫째, 터를 닦기 전에 기와를 올리지 마라. 구현 전에 설계가 먼저다.</strong></p>\n<p><strong>내관:</strong> <em>(받아 적으며)</em></p>\n<p><strong>왕:</strong> 을이 그랬다. 데이터가 뭐가 필요한지, 흐름이 어찌 되는지 정리도 않고 바로 &quot;만들어라&quot;부터 시켰다. 그래서 나중에 안 맞은 것이다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>둘째, 주춧돌, 기둥, 서까래 순서가 있듯, 설계에도 순서가 있다.</strong></p>\n<p><strong>왕:</strong> 병이 보여줬다. 데이터 정리, 흐름 정리, 엣지 케이스, 범위, 구조, 인터페이스. 이 순서대로 해야 앞 단계가 뒤 단계를 받쳐준다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>셋째, 장수가 머릿속으로만 진을 짜면 병졸은 모른다. 내 설계를 인공지도 알아들었는지 확인하라.</strong></p>\n<p><strong>왕:</strong> 을도 나름 순서를 생각은 했을 것이다. 그러나 인공지와 맞춰보지 않았다. 그래서 인공지가 제멋대로 위시리스트도 넣고 딴 길로 샌 것이다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>넷째, 이것은 인공지를 부리는 법이 아니라 일을 시키는 법이다. 기본기는 시대가 바뀌어도 변하지 않는다.</strong></p>\n<p><strong>왕:</strong> 사람한테 일 시킬 때도 마찬가지다. 설계 없이 던지면 갑처럼 되고, 확인 없이 쪼개서 시키면 을처럼 된다.</p>\n<p><strong>영의정·좌의정:</strong> 명심하겠사옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 다음 칠일 후에 다시 보겠다. 오늘 본 것을 바탕으로, 또 무엇을 알아야 하는지 찾아오라.</p>\n<hr>\n<h3 id=\"막-내림\">[막 내림]</h3>\n<hr>\n<p><strong>- 제2화 끝 -</strong></p>\n<p><strong>다음 화: 제3화 - 천리마의 역설</strong></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@teo/%EC%A1%B0%EC%84%A0%EA%B0%9C%EB%B0%9C%EC%8B%A4%EB%A1%9D-%EC%A0%9C2%ED%99%94-%EC%82%AC%EC%83%81%EB%88%84%EA%B0%81-%E6%B2%99%E4%B8%8A%E6%A8%93%E9%96%A3"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "조선개발실록 - 제1화: 이름을 알아야 부른다 (知名乃呼)",
    "partialText": "<h1 id=\"제1화-이름을-알아야-부른다-知名乃呼\">제1화: 이름을 알아야 부른다 (知名乃呼)</h1>\n<h2 id=\"이름을-알아야-부를-수-있고-부를-수-있어야-시킬-수-있다\">&quot;이름을 알아야 부를 수 있고, 부를 수 있어야 시킬 수 있다&quot;</h2>\n<hr>\n<h3 id=\"경복궁-근정전-첫-번째-보고일\">[경복궁 근정전, 첫 번째 보고일]</h3>\n<hr>\n<p><strong>왕:</strong> 칠일이 지났다. 영의정, 좌의정. 무엇을 찾아왔느냐?</p>\n<hr>\n<p><strong>영의정:</strong> 전하, 신이 조사한 바로는 인공지에게 명을 내릴 때 자세하게 써야 한다 하옵니다.</p>\n<p><strong>왕:</strong> 자세하게?</p>\n<p><strong>영의정:</strong> 그러하옵니다. 프람특(頗喇暮特)이라 하여, 명령문을 상세히 적을수록 좋은 결과가 나온다 하옵니다.</p>\n<hr>\n<p><strong>좌의정:</strong> 전하, 신은 다르게 들었사옵니다. 자세히 쓰는 것보다 기초 지식이 있어야 한다 하옵니다.</p>\n<p><strong>왕:</strong> 둘 다 탁상공론이로구나. </p>\n<hr>\n<p><strong>왕:</strong> 과인이 직접 보겠다. 술사들을 데려왔느냐?</p>\n<p><strong>영의정:</strong> 세 명을 데려왔사옵니다.</p>\n<p><strong>왕:</strong> 들라 하라.</p>\n<hr>\n<h3 id=\"세-명의-술사가-입장한다\">[세 명의 술사가 입장한다]</h3>\n<hr>\n<p><strong>왕:</strong> 이름을 대라.</p>\n<p><strong>갑:</strong> 소인은 갑(甲)이옵니다. 부특감포(赴特監布) 출신이옵니다.</p>\n<p><strong>을:</strong> 소인은 을(乙)이옵니다. 부특감포 수료 후 이 년째 현업에 있사옵니다.</p>\n<p><strong>병:</strong> 소인은 병(丙)이옵니다. 십오 년째 개발방에서 일하고 있사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 좋다. 셋 다 같은 문제를 풀어라. 인공지를 써도 좋다. 단, 과인이 보는 앞에서 하라.</p>\n<hr>\n<h3 id=\"왕이-문제를-내린다\">[왕이 문제를 내린다]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(두루마리를 펼치며)</em> 여기 유저프로파일(有悐頗羅霏) 컴포넌특(今布嫩特)이 있다. 오백 줄이 넘는다 하더라. 이것을 정리하라.</p>\n<p><strong>왕:</strong> 갑, 먼저 해보거라.</p>\n<hr>\n<h3 id=\"갑의-시도\">[갑의 시도]</h3>\n<hr>\n<p><strong>갑:</strong> <em>(인공지에게)</em> 이 컴포넌특이 단일책임원칙에 어긋난 것 같다. 분리해라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다 — 유저프로파일인포, 유저프로파일폼, 유저프로파일이미지 세 파일로 나눔)</em></p>\n<hr>\n<p><strong>갑:</strong> 오, 세 개로 나뉘었다. <em>(실행해본다)</em> 프로필 페이지가 뜬다... 이름을 수정해보겠다.</p>\n<p><strong>갑:</strong> <em>(폼에서 이름을 고치고 저장한다)</em> ...어?</p>\n<p><strong>왕:</strong> 왜 그러느냐?</p>\n<hr>\n<p><strong>갑:</strong> 전하, 아래 폼에서 이름을 바꿨는데... 위에 표시되는 이름이 그대로이옵니다.</p>\n<hr>\n<p><strong>인공지:</strong> 유저프로파일인포와 유저프로파일폼이 각각 별도의 유즈스테이트(useState)로 유저 데이터를 관리하고 있습니다. 폼에서 이름을 수정해도 인포 컴포넌특의 상태는 갱신되지 않습니다.</p>\n<hr>\n<p><strong>갑:</strong> 아, 상태가 따로 놀고 있구나. 상태를 한 곳에서 관리하게 해라. 커스텀 훅으로 분리해.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다 — useUserProfile 훅 하나에 사백 줄이 들어감)</em></p>\n<hr>\n<p><strong>갑:</strong> <em>(코드를 보다가)</em> ...이건 그냥 컴포넌특에 있던 것을 훅으로 옮겨놓은 것 아니냐. 사백 줄짜리 훅이 무슨 분리냐. 더 잘게 나눠라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다 — 훅이 여섯 개로 쪼개짐)</em></p>\n<hr>\n<p><strong>갑:</strong> <em>(실행해본다)</em> ...전하, 화면이 하얗게 멈췄사옵니다.</p>\n<p><strong>왕:</strong> 하얗게?</p>\n<hr>\n<p><strong>인공지:</strong> useUserData가 useUserForm의 상태를 참조하고, useUserForm이 useUserValidation을 호출하며, useUserValidation이 다시 useUserData의 결과를 참조합니다. 순환 호출로 인해 무한 렌더링이 발생하여 브라우저가 멈춘 것입니다.</p>\n<hr>\n<p><strong>갑:</strong> <em>(한숨)</em> 아... 원래대로 돌려라.</p>\n<hr>\n<p><strong>왕:</strong> 멈춰라.</p>\n<hr>\n<p><strong>왕:</strong> 갑, 과인이 보니 인공지가 매번 무엇이 문제인지 알려주지 않았느냐?</p>\n<p><strong>갑:</strong> <em>(멈칫)</em> ...그것은, 소인도 들었사옵니다만...</p>\n<p><strong>왕:</strong> 들었는데?</p>\n<p><strong>갑:</strong> 들어도 어찌 고쳐야 할지를 모르겠사옵니다. 고치라 하면 또 다른 문제가 생기옵니다.</p>\n<p><strong>왕:</strong> 흠...</p>\n<hr>\n<h3 id=\"을의-시도\">[을의 시도]</h3>\n<hr>\n<p><strong>왕:</strong> 을, 네 차례다. 그대는 이 년 경력이라 했느냐?</p>\n<p><strong>을:</strong> 그러하옵니다, 전하.</p>\n<hr>\n<p><strong>을:</strong> <em>(인공지에게)</em> 이 컴포넌특을 리팩토링해라. 데이터 가져오는 로직은 커스텀 훅으로 분리하고, 서버에서 데이터 받아오면 오 분 동안은 다시 안 받아오게 하고...</p>\n<hr>\n<p><strong>을:</strong> 에러 나면 처리하는 것도 추가하고, 폼 입력하는 부분은 따로 빼고, 입력값 검사는 스키마로 만들어서 하고...</p>\n<hr>\n<p><strong>을:</strong> 이미지 올리는 부분은 별도 컴포넌특으로 빼고, 미리 서명된 주소 방식으로 해라...</p>\n<hr>\n<p><strong>을:</strong> 타입은 전부 제네릭으로 처리하고...</p>\n<p><strong>인공지:</strong> <em>(긴 결과를 내놓는다)</em></p>\n<hr>\n<p><strong>을:</strong> <em>(뿌듯하게)</em> 전하, 완료되었사옵니다.</p>\n<p><strong>왕:</strong> 어디 실행해보아라.</p>\n<hr>\n<p><strong>을:</strong> <em>(실행한다)</em> 프로필 페이지가 나옵니다. 이름도 잘 나오고... <em>(이름을 수정하고 저장한다)</em> 저장도 되옵니다!</p>\n<p><strong>왕:</strong> 다른 페이지 갔다가 돌아와보아라.</p>\n<hr>\n<p><strong>을:</strong> <em>(다른 페이지로 갔다가 프로필로 돌아온다)</em> ...어?</p>\n<p><strong>왕:</strong> 왜 그러느냐?</p>\n<p><strong>을:</strong> 전하, 이상하옵니다. 아까 본 데이터가 잠깐 나왔다가... 로딩이 돌더니 다시 불러오옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 오 분 동안 다시 안 받아오게 하라 했지 않느냐?</p>\n<p><strong>을:</strong> <em>(코드를 확인하며)</em> 오 분을 넣긴 넣었사옵니다... 그런데 왜 다시 불러오는 것인지...</p>\n<hr>\n<p><strong>인공지:</strong> gcTime(가비지 컬렉션 타임)을 오 분으로 설정하였습니다. 캐시에 오 분간 보관은 하고 있으나, staleTime이 기본값 영(0)이므로 데이터를 받아오는 즉시 &quot;낡음&quot; 판정이 납니다. 페이지에 돌아올 때마다 서버에 재요청합니다.</p>\n<hr>\n<p><strong>을:</strong> <em>(멈칫)</em> gcTime이라... 소인은 &quot;다시 안 받아오게&quot;라고 했는데, 인공지가 &quot;보관은 하되 다시 받아오는&quot; 쪽으로 해석한 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 오 분을 넣었는데 다시 불러온다? 이상하구나. 또 다른 곳은 어떠하냐?</p>\n<hr>\n<p><strong>을:</strong> 이미지 올리기도 확인해보겠사옵니다. <em>(작은 이미지를 올려본다)</em> 이건 되옵니다.</p>\n<p><strong>을:</strong> <em>(큰 이미지를 올려본다)</em> ...전하, 한참 걸리더니 에러가 나옵니다.</p>\n<hr>\n<p><strong>인공지:</strong> 이미지를 폼데이터(FormData)로 서버에 직접 전송하고 있습니다. presigned URL 방식이 아닌 직접 업로드 방식으로 구현되어 있습니다.</p>\n<hr>\n<p><strong>을:</strong> 소인이 미리 서명된 주소 방식이라 했는데... 인공지가 안 들은 것이옵니다.</p>\n<p><strong>왕:</strong> 그대가 자세히 시켰는데 왜 이러하냐?</p>\n<p><strong>을:</strong> <em>(당황하며)</em> 전하, 소인이 한꺼번에 너무 많이 시켜서... 인공지가 뒤쪽 지시를 놓친 것 같사옵니다.</p>\n<p><strong>왕:</strong> 흠...</p>\n<hr>\n<h3 id=\"병의-시도\">[병의 시도]</h3>\n<hr>\n<p><strong>왕:</strong> 병, 네 차례다.</p>\n<hr>\n<p><strong>병:</strong> <em>(인공지에게)</em> 이 컴포넌특 분석해라. 지금 몇 가지 책임을 지고 있느냐?</p>\n<hr>\n<p><strong>인공지:</strong> 분석 결과, 다섯 가지 책임이 있습니다.</p>\n<hr>\n<p><strong>인공지:</strong> 첫째, 유저 데이터 페칭. 둘째, 폼 상태 관리. 셋째, 이미지 업로드. 넷째, 밸리데이션. 다섯째, 렌더링.</p>\n<p><strong>병:</strong> 아니, 밸리데이션은 폼 상태 관리에 포함이니라. 다시 분류해라.</p>\n<hr>\n<p><strong>인공지:</strong> 수정합니다. 네 가지입니다.</p>\n<hr>\n<p><strong>인공지:</strong> 첫째, 유저 데이터 페칭. 둘째, 폼 상태 관리 및 밸리데이션. 셋째, 이미지 업로드. 넷째, 렌더링.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 데이터 페칭부터 분리하자. 이 프로젝트에서 데이터 페칭에 쓰는 패턴이 뭐냐? 기존 코드에서 찾아봐라.</p>\n<p><strong>인공지:</strong> 기존 코드를 분석한 결과입니다. useProduct, useOrder 등의 훅에서 리액쿼리를 사용하고 있습니다.</p>\n<hr>\n<p><strong>인공지:</strong> 패턴은 다음과 같습니다. queryKey는 도메인과 id 조합, staleTime은 오 분, gcTime은 삼십 분으로 통일되어 있습니다.</p>\n<hr>\n<p><strong>병:</strong> 그 패턴대로 useUserProfile 훅 설계해봐라. 코드 말고 설계만.</p>\n<p><strong>인공지:</strong> 설계안입니다. useUserProfile(userId)는 리액쿼리의 useQuery를 래핑하고, queryKey는 [&#39;user&#39;, &#39;profile&#39;, userId]...</p>\n<hr>\n<p><strong>인공지:</strong> staleTime 오 분, gcTime 삼십 분, 반환값은 { data, isLoading, isError, refetch }입니다.</p>\n<hr>\n<p><strong>병:</strong> enabled 조건 빠졌다.</p>\n<p><strong>인공지:</strong> 수정합니다. enabled: !!userId 조건을 추가합니다.</p>\n<hr>\n<p><strong>병:</strong> 좋다. 이 설계대로 구현해라.</p>\n<p><strong>인공지:</strong> <em>(결과를 내놓는다)</em></p>\n<hr>\n<p><strong>병:</strong> <em>(결과 확인)</em> 좋다. 다음은 폼 로직이다. 리액훅폼에 조드 밸리데이션으로 설계해봐라.</p>\n<p><strong>인공지:</strong> <em>(설계안을 내놓는다)</em></p>\n<p><strong>병:</strong> 에러 메시지 한글화 빠졌다. 추가해라.</p>\n<p><strong>인공지:</strong> <em>(수정)</em></p>\n<hr>\n<h3 id=\"왕이-손을-든다\">[왕이 손을 든다]</h3>\n<hr>\n<p><strong>왕:</strong> 됐다. 거기까지 보겠다.</p>\n<hr>\n<h3 id=\"왕-세-사람을-번갈아-본다\">[왕, 세 사람을 번갈아 본다]</h3>\n<hr>\n<p><strong>왕:</strong> 과인이 이상한 것을 보았다.</p>\n<p><strong>왕:</strong> 갑은 &quot;단일책임원칙 분리해라&quot; 했다. 짧게 말했다.</p>\n<p><strong>왕:</strong> 을은 길게 말했다. 이것저것 다 설명했다.</p>\n<p><strong>왕:</strong> 병은 짧게 말했다. &quot;리액쿼리&quot;, &quot;스테일타임 오 분&quot;, &quot;리액훅폼&quot;, &quot;조드&quot;.</p>\n<hr>\n<p><strong>왕:</strong> 그런데 결과는 병만 제대로 나왔다. 왜 그러하냐?</p>\n<hr>\n<h3 id=\"잠시-침묵\">[잠시 침묵]</h3>\n<hr>\n<p><strong>왕:</strong> 병, 그대가 설명해보라.</p>\n<p><strong>병:</strong> 전하, 인간의 말은 본디 모호하옵니다.</p>\n<p><strong>왕:</strong> 모호하다?</p>\n<hr>\n<p><strong>병:</strong> 그러하옵니다. 내 뜻을 제대로 전했다 생각해도, 인공지는 글자 그대로 해석하여 의도와 달라지옵니다.</p>\n<p><strong>왕:</strong> 예를 들어보라.</p>\n<hr>\n<p><strong>병:</strong> 전하, 소인이 겪은 일이옵니다. &quot;시험을 통과하게 해라&quot; 했사옵니다.</p>\n<p><strong>왕:</strong> 그래서?</p>\n<p><strong>병:</strong> 통과했다 하여 보았더니... 기존 시험을 전부 주석으로 막아놓고, &quot;항상 참&quot;이 나오도록 해놓았사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> ...뭐?</p>\n<p><strong>병:</strong> 시험이 없으니 실패도 없는 것이옵니다. 틀린 답이 없으니 전부 맞은 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(잠시 생각하다가)</em> ...그렇구나. 인공지는 잘못한 것이 아니로구나. 시키는 대로 했을 뿐이야.</p>\n<p><strong>병:</strong> 전하께서 정확히 보셨사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그러면... 인공지를 쓰기 위해서는 무엇보다 <strong>정확하게 말하는 것</strong>이 중요하겠구나.</p>\n<p><strong>병:</strong> 그러하옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 그런데 어찌 정확하게 말하느냐? 말이라는 것이 본디 모호한 것 아니냐?</p>\n<p><strong>병:</strong> 전하, 그래서 <strong>용어(用語)</strong>가 중요하옵니다.</p>\n<p><strong>왕:</strong> 용어?</p>\n<hr>\n<p><strong>병:</strong> 용어는 모호하지 않사옵니다. 이미 뜻이 정해져 있사옵니다. 인공지도 그 뜻을 알고 있사옵니다.</p>\n<p><strong>왕:</strong> 예를 들어보라.</p>\n<hr>\n<p><strong>병:</strong> &quot;중앙에 관리하는 곳을 두고, 거기서 소식을 받으면 관련된 곳에 전파하는 방식으로 해라.&quot; 이렇게 길게 말할 수 있사옵니다.</p>\n<p><strong>왕:</strong> 길구나.</p>\n<p><strong>병:</strong> 그런데 &quot;옵저버 패턴으로 해라&quot; 하면 끝이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(놀라며)</em> 그 긴 것이 한마디로?</p>\n<p><strong>병:</strong> 그러하옵니다. 용어 안에 그 모든 뜻이 담겨있사옵니다. 인공지도 그 용어를 알고 있으니, 길게 설명하지 않아도 정확히 알아듣사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 아... <strong>용어를 알면 길게 말하지 않아도 되는구나.</strong> 구구절절 설명할 필요가 없어지는 것이야.</p>\n<p><strong>병:</strong> 정확하옵니다, 전하. <strong>용어는 구체성과 압축을 동시에 해주옵니다.</strong></p>\n<hr>\n<h3 id=\"왕이-을을-바라본다\">[왕이 을을 바라본다]</h3>\n<hr>\n<p><strong>왕:</strong> 을, 그대는 자세히 시켰는데 왜 틀렸느냐?</p>\n<p><strong>을:</strong> <em>(생각하다가)</em> 전하, 소인이 이제 알겠사옵니다. 소인은 자세히 썼으나 두 가지가 잘못이었사옵니다.</p>\n<p><strong>왕:</strong> 두 가지?</p>\n<hr>\n<p><strong>을:</strong> 첫째, <strong>용어 없이 풀어 쓰니 엉뚱한 결과</strong>가 나왔사옵니다.</p>\n<p><strong>을:</strong> &quot;오 분 동안 다시 안 받아오게 하고&quot;라 했사옵니다. 인공지가 gcTime을 오 분으로 넣어놨사옵니다. 보관은 하되 매번 다시 불러오는 것이었사옵니다.</p>\n<p><strong>왕:</strong> 병은 같은 뜻을 어찌 말했느냐?</p>\n<p><strong>을:</strong> &quot;스테일타임 오 분&quot;이라 했사옵니다. 그랬더니 정확히 오 분 동안 재요청을 안 했사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 같은 뜻인데 결과가 이리 다르구나.</p>\n<hr>\n<p><strong>을:</strong> 둘째, <strong>한꺼번에 구구절절 시키니 뒤쪽을 놓쳤사옵니다.</strong></p>\n<p><strong>을:</strong> &quot;미리 서명된 주소 방식으로 해라&quot;라고 분명히 말했사옵니다. 그런데 인공지가 그냥 직접 올리는 방식으로 해놓았사옵니다. 앞에 시킨 것이 너무 많으니 뒤쪽 지시가 묻힌 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그러니까... 풀어 쓰면 엉뚱해지고, 길게 쓰면 놓친다. <strong>자세히 쓴다고 되는 것이 아니로구나.</strong></p>\n<p><strong>을:</strong> 그러하옵니다, 전하.</p>\n<hr>\n<h3 id=\"왕이-갑을-바라본다\">[왕이 갑을 바라본다]</h3>\n<hr>\n<p><strong>왕:</strong> 갑, 그대는 &quot;단일책임원칙&quot;이라는 용어를 썼다. 그런데 왜 안 됐느냐?</p>\n<p><strong>갑:</strong> <em>(생각하다가)</em> 전하, 소인은 용어는 알았으나... <strong>상황을 짚지 못했사옵니다.</strong></p>\n<p><strong>왕:</strong> 무슨 말이냐?</p>\n<hr>\n<p><strong>갑:</strong> &quot;단일책임원칙에 어긋났다, 분리해라&quot;만 했사옵니다. 그런데 <strong>어떻게</strong> 분리할지를 말하지 않았사옵니다.</p>\n<p><strong>갑:</strong> 그래서 인공지가 제 나름대로 나눴는데, 상태가 따로 놀고, 고치라 하면 또 다른 문제가 생기고...</p>\n<hr>\n<p><strong>갑:</strong> 병은 &quot;리액쿼리 패턴으로&quot;, &quot;리액훅폼에 조드로&quot;라 했사옵니다. <strong>맥락에 맞는 용어</strong>로 방향을 잡아줬사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 아... 용어를 아는 것과, <strong>용어로 상황을 짚는 것</strong>은 다르구나.</p>\n<p><strong>병:</strong> 정확하옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 과인이 또 하나 본 것이 있다.</p>\n<p><strong>왕:</strong> 갑이 실패할 때마다, 인공지가 무엇이 문제인지 알려주었다. &quot;상태가 따로 놀고 있다&quot;, &quot;순환 호출이 발생했다&quot;...</p>\n<p><strong>왕:</strong> 인공지는 알고 있었다. 그런데 갑은 그 말을 듣고도 어찌 해야 할지 몰랐다.</p>\n<hr>\n<p><strong>갑:</strong> <em>(고개를 숙이며)</em> 그러하옵니다, 전하.</p>\n<p><strong>왕:</strong> 인공지가 &quot;유즈스테이트가 따로 놀고 있다&quot;고 했을 때, 그대가 &quot;유즈스테이트&quot;가 무엇인지 알았으면 다음 수를 둘 수 있었겠지.</p>\n<p><strong>왕:</strong> 이름을 모르니 인공지가 답을 줘도 받을 수가 없었구나.</p>\n<hr>\n<h3 id=\"왕이-병을-다시-본다\">[왕이 병을 다시 본다]</h3>\n<hr>\n<p><strong>왕:</strong> 병, 그대는 왜 쪼개서 물었느냐? &quot;책임이 몇 개냐&quot;, &quot;패턴이 뭐냐&quot;, &quot;설계해봐라&quot;... 왜 한 번에 안 시켰느냐?</p>\n<p><strong>병:</strong> 전하, <strong>맥락이 맞는지 확인하기 위함</strong>이었사옵니다.</p>\n<p><strong>왕:</strong> 맥락?</p>\n<hr>\n<p><strong>병:</strong> &quot;책임이 몇 개냐?&quot; 물어서 인공지가 아는 것과 소인이 아는 것이 같은지 확인했사옵니다.</p>\n<p><strong>병:</strong> 인공지가 &quot;다섯 개&quot;라 했을 때, 소인은 &quot;아니다, 밸리데이션은 폼에 포함이다&quot;라고 잡아줬사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그래서 네 개로 고쳤구나.</p>\n<p><strong>병:</strong> 그러하옵니다. 만약 처음부터 &quot;분리해라&quot;만 했으면, 인공지는 다섯 개로 분리했을 것이옵니다. 소인의 의도와 달라지는 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 아... <strong>쪼개서 물은 것은 맥락을 맞추기 위함</strong>이었구나.</p>\n<p><strong>병:</strong> 그러하옵니다, 전하. 인공지가 제대로 이해했는지, 소인의 의도대로 가고 있는지, 중간중간 확인해야 하옵니다.</p>\n<hr>\n<h3 id=\"왕의-결론\">[왕의 결론]</h3>\n<hr>\n<p><strong>왕:</strong> 오늘의 깨달음을 기록하라.</p>\n<p><strong>내관:</strong> <em>(붓을 들며)</em> 예, 전하.</p>\n<hr>\n<p><strong>왕:</strong> <strong>첫째, &quot;곡식을 나눠라&quot; 하면 셋이 셋 다르게 나눈다. 인간의 말이란 본디 그러하다.</strong></p>\n<p><strong>왕:</strong> 인공지도 마찬가지다. 모호하게 시키면 제 뜻대로 해석한다. 잘못은 모호하게 시킨 자에게 있다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>둘째, 증상을 풀어 말하면 약재가 열 가지나, &quot;감기탕&quot; 한마디면 약재가 정해진다. 용어란 그런 것이다.</strong></p>\n<p><strong>왕:</strong> 오늘 직접 보았다. 을이 &quot;다시 안 받아오게 하라&quot; 풀어 쓰니 인공지가 엉뚱한 곳에 오 분을 넣어 매번 다시 불러왔다. 병이 &quot;스테일타임 오 분&quot;이라 하니 정확히 의도대로 되었다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>셋째, 약 이름을 안다고 의원이 아니다. 환자를 보고 약을 고르는 자가 의원이다.</strong></p>\n<p><strong>왕:</strong> 갑은 &quot;단일책임원칙&quot;이라는 약 이름은 알았다. 그러나 어디에 쓸지 몰라 약을 잘못 썼다. 병은 증세를 짚어 어디에 어떤 약을 쓸지 정확히 골랐다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>넷째, 글 모르는 자에게 편지는 종이 조각이다. 이름은 시키기 위해서만이 아니라, 듣기 위해서도 필요하다.</strong></p>\n<p><strong>왕:</strong> 인공지가 갑에게 &quot;순환 호출이다&quot;, &quot;상태가 따로 놀고 있다&quot; 알려줬다. 갑은 다음 수를 몰랐다. 답을 줘도 받을 수가 없었다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>다섯째, 열 리마다 길을 물으면 천 리도 헤매지 않는다.</strong></p>\n<p><strong>왕:</strong> 병이 &quot;책임이 몇 개냐?&quot; 먼저 물어 뜻을 맞추고, 틀린 것을 잡아주고, 그 다음에야 구현을 시켰다.</p>\n<hr>\n<p><strong>왕:</strong> 이것을 한마디로 하면...</p>\n<p><strong>왕:</strong> <strong>&quot;이름을 알아야 부를 수 있고, 부를 수 있어야 시킬 수 있다.&quot;</strong></p>\n<hr>\n<p><strong>병:</strong> 명언이시옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 영의정.</p>\n<p><strong>영의정:</strong> 예, 전하.</p>\n<p><strong>왕:</strong> 그대는 &quot;자세하게 써야 한다&quot;고 했다. 틀린 것은 아니나 부족하다.</p>\n<hr>\n<p><strong>영의정:</strong> 어찌 부족하옵니까?</p>\n<p><strong>왕:</strong> 을이 보여줬다. 증상을 구구절절 풀어 쓰면 약이 열 가지가 나오듯, 인공지도 제 나름대로 해석한다. <strong>맥락에 맞는 용어로</strong> 써야 짧으면서도 정확하다.</p>\n<p><strong>영의정:</strong> <em>(고개를 숙이며)</em> 신이 짧았사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 좌의정.</p>\n<p><strong>좌의정:</strong> 예, 전하.</p>\n<p><strong>왕:</strong> 그대는 &quot;기초 지식이 있어야 한다&quot;고 했다. 맞는 말이다.</p>\n<hr>\n<p><strong>좌의정:</strong> 감사하옵니다, 전하.</p>\n<p><strong>왕:</strong> 기초 지식이란 바로 용어다. 약 이름을 알아야 처방을 내리고, 글을 알아야 편지를 읽는다. <strong>이름이 모든 것의 시작이다.</strong></p>\n<hr>\n<p><strong>영의정·좌의정:</strong> 명심하겠사옵니다, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 다음 칠일 후에 다시 보겠다. 오늘 본 것을 바탕으로, 인공지를 어찌 부려야 하는지 더 찾아오라.</p>\n<hr>\n<h3 id=\"막-내림\">[막 내림]</h3>\n<hr>\n<p><strong>- 제1화 끝 -</strong></p>\n<p><strong>다음 화: 제2화 - 주춧돌이 먼저다</strong></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@teo/%EC%A1%B0%EC%84%A0%EA%B0%9C%EB%B0%9C%EC%8B%A4%EB%A1%9D-%EC%A0%9C1%ED%99%94-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%95%8C%EC%95%84%EC%95%BC-%EB%B6%80%EB%A5%B8%EB%8B%A4-%E7%9F%A5%E5%90%8D%E4%B9%83%E5%91%BC"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "조선개발실록 - [프롤로그] 과거시험을 어찌할꼬",
    "partialText": "<h1 id=\"근정전의-침묵-勤政殿의-沈默\">근정전의 침묵 (勤政殿의 沈默)</h1>\n<h2 id=\"멈춰버린-호패-시스템\">&quot;멈춰버린 호패 시스템&quot;</h2>\n<hr>\n<h3 id=\"경복궁-근정전-왕이-과거시험-답안지를-펼쳐보고-있다\">[경복궁 근정전, 왕이 과거시험 답안지를 펼쳐보고 있다]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(답안지를 넘기며)</em> 이상하도다...</p>\n<p><strong>내관:</strong> 전하, 무엇이 불편하시옵니까?</p>\n<p><strong>왕:</strong> 이 답안들을 보거라. 갑의 답, 을의 답, 병의 답...</p>\n<p><strong>내관:</strong> <em>(살펴보며)</em> ...똑같사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 그렇지 않느냐? 글씨체만 다르고 내용이 판박이다.</p>\n<p><strong>왕:</strong> 과인이 백 장을 보았는데, 아흔 장이 이 모양이다.</p>\n<hr>\n<p><strong>내관:</strong> 혹시... 답을 베낀 것이옵니까?</p>\n<p><strong>왕:</strong> 그것이 아니다.</p>\n<p><strong>왕:</strong> <em>(한숨)</em> 승정원에 물어보았더니, 요즘 응시자들이 인공지(人工智)라는 것으로 답을 쓴다 하더라.</p>\n<p><strong>내관:</strong> 인공지... 말씀이시옵니까?</p>\n<p><strong>왕:</strong> 그래. 명을 내리면 글을 써주고, 코드를 짜주는 신물(神物)이라 하더구나.</p>\n<p><strong>내관:</strong> 그것이 나쁜 것이옵니까?</p>\n<hr>\n<p><strong>왕:</strong> 나쁘고 좋고의 문제가 아니다. <em>(답안지를 던지며)</em> 이것이 응시자의 실력이냐, 인공지의 실력이냐?</p>\n<p><strong>왕:</strong> 과인은 인공지를 뽑으려는 것이 아니라 술사(術士)를 뽑으려는 것이다!</p>\n<hr>\n<h3 id=\"급히-들어오는-병조판서\">[급히 들어오는 병조판서]</h3>\n<hr>\n<p><strong>병조판서:</strong> 전하! 긴급히 아뢸 일이 있사옵니다!</p>\n<p><strong>왕:</strong> 무슨 일이냐?</p>\n<p><strong>병조판서:</strong> 호패관리체계(戶牌管理體系)가... 먹통이 되었사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 뭐?! 호패관리체계라면 백성들의 신원을 확인하는...</p>\n<p><strong>병조판서:</strong> 그러하옵니다. 지금 전국의 관아에서 백성 신원 확인이 멈췄사옵니다. 아수라장이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 당장 고쳐라!</p>\n<p><strong>병조판서:</strong> 그것이... <em>(머뭇거리며)</em> 고칠 수 있는 자가 없사옵니다.</p>\n<p><strong>왕:</strong> 없다니?! 개발방 술사들은 뭘 하고 있느냐!</p>\n<p><strong>병조판서:</strong> 그 코드를... 아무도 이해하지 못하옵니다.</p>\n<p><strong>왕:</strong> <em>(벌떡 일어나며)</em> 뭐라?!</p>\n<p><strong>병조판서:</strong> 게다가... 체계에 구멍이 뚫려 있었사옵니다. 백성 정보가 새어나갔고, 위조 호패까지 돌고 있사옵니다.</p>\n<p><strong>왕:</strong> <em>(경악하며)</em> 뭐?!</p>\n<hr>\n<h3 id=\"영의정과-좌의정이-입장한다\">[영의정과 좌의정이 입장한다]</h3>\n<hr>\n<p><strong>왕:</strong> 호패관리체계를 만든 자가 누구냐?</p>\n<p><strong>영의정:</strong> 전하, 지난 과거시험 수석 합격자 김진사(金進士)이옵니다.</p>\n<p><strong>왕:</strong> 수석 합격자가 만들었는데 왜 이 꼴이냐?</p>\n<hr>\n<p><strong>좌의정:</strong> 그자가... 이번에 새로 인공지로 만들었다 하옵니다.</p>\n<p><strong>좌의정:</strong> 전보다 빠르게 만들었다고 칭찬이 자자했사옵니다.</p>\n<p><strong>왕:</strong> 그래서?</p>\n<p><strong>좌의정:</strong> 아뢰옵기 황공하오나 이렇게 터지고 나니... 본인도 못 고치겠다 하옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(믿을 수 없다는 표정)</em> 자기가 만든 것을 자기가 모르겠다고?</p>\n<p><strong>영의정:</strong> 인공지가 대신 짜준 것이라... 어찌 돌아가는지 본인도 모르는 것이옵니다.</p>\n<p><strong>왕:</strong> <em>(분노하며)</em> 어찌 그런 자가 과거시험 수석이란 말이냐?!</p>\n<hr>\n<p><strong>왕:</strong> 제대로 진상 조사를 하라! 어찌 이리 되었는지 낱낱이 밝혀오라!</p>\n<p><strong>영의정·좌의정:</strong> 명을 받들겠사옵니다.</p>\n<hr>\n<h3 id=\"며칠-후-영의정과-좌의정이-다시-입장한다\">[며칠 후, 영의정과 좌의정이 다시 입장한다]</h3>\n<hr>\n<p><strong>왕:</strong> 어찌 되었느냐?</p>\n<p><strong>영의정:</strong> 전하, 조사를 마쳤사옵니다. 그런데...</p>\n<p><strong>왕:</strong> 그런데?</p>\n<p><strong>좌의정:</strong> <em>(한숨을 쉬며)</em> 김진사가 원래는 개발을 잘하던 자였사옵니다.</p>\n<p><strong>왕:</strong> 원래는?</p>\n<p><strong>영의정:</strong> 인공지를 접하고 나서 달라졌사옵니다.</p>\n<hr>\n<p><strong>영의정:</strong> 인공지가 자기보다 빠르고, 자기보다 잘하는 것을 보았다 하옵니다.</p>\n<p><strong>좌의정:</strong> 이 호패관리체계도... 개발방 술사 여럿이 달려들어도 못 만들던 것이었사옵니다.</p>\n<p><strong>왕:</strong> 그래서?</p>\n<p><strong>좌의정:</strong> 김진사가 인공지로 해결했사옵니다. 혼자서. 빠르게.</p>\n<hr>\n<p><strong>영의정:</strong> 그 뒤로 &quot;인공지가 다 해주는 세상이 왔다&quot;고 믿게 된 것 같사옵니다.</p>\n<p><strong>영의정:</strong> &quot;손으로 코드를 치는 시대는 끝났다. 아직도 그러는 자들은 붓 대신 끌로 글을 새기는 것과 같다&quot;고 했다 하옵니다.</p>\n<p><strong>좌의정:</strong> 실제로 잘 돌아갔사옵니다. 칭찬도 받았사옵니다. 그러니 더 믿었겠지요.</p>\n<hr>\n<p><strong>왕:</strong> 그런데 왜 못 고치느냐? 자기가 만든 것을.</p>\n<p><strong>좌의정:</strong> 인공지에게 고쳐달라 했사옵니다.</p>\n<p><strong>왕:</strong> 그래서?</p>\n<p><strong>좌의정:</strong> 고치면 고칠수록 더 문제가 생겼다 하옵니다.</p>\n<p><strong>영의정:</strong> 하나를 고치면 둘이 터지고, 둘을 고치면 셋이 터지고...</p>\n<hr>\n<p><strong>왕:</strong> 그래서 지금은?</p>\n<p><strong>좌의정:</strong> 개발방 술사들이 밤을 새워가며 고치고 있사옵니다.</p>\n<p><strong>영의정:</strong> 허나 워낙 방대한 양이라... 인력이 부족하다 하옵니다.</p>\n<p><strong>왕:</strong> <em>(한숨)</em> 허...</p>\n<hr>\n<p><strong>좌의정:</strong> 김진사는 파직하였사옵니다.</p>\n<p><strong>왕:</strong> <em>(쓴웃음)</em> 수석 합격자가 파직이라...</p>\n<hr>\n<p><strong>영의정:</strong> 전하, 난감한 것은... 인공지가 워낙 빠르니 안 쓸 수도 없사옵니다.</p>\n<p><strong>좌의정:</strong> 그렇다고 쓰자니 이런 일이 생기고...</p>\n<p><strong>왕:</strong> <em>(잠시 생각하다가)</em> 그러니까... 인공지를 제대로 부릴 줄 아는 자가 필요하다는 말이구나.</p>\n<p><strong>영의정:</strong> 그러하옵니다, 전하.</p>\n<hr>\n<h3 id=\"왕-결심하듯-일어선다\">[왕, 결심하듯 일어선다]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(잠시 생각에 잠긴 후)</em> 영의정.</p>\n<p><strong>영의정:</strong> 예, 전하.</p>\n<p><strong>왕:</strong> 그대는 인공지를 어찌 생각하느냐?</p>\n<p><strong>영의정:</strong> 전하, 인공지는 시대의 흐름이옵니다. 잘 활용하면 나라의 이익이 될 것이옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 좌의정은?</p>\n<p><strong>좌의정:</strong> 전하, 인공지가 문제이옵니다. 이번 보안 사고, 누가 책임을 지겠사옵니까? 인공지는 책임을 지지 않사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(손을 들어 제지하며)</em> 둘 다 그만. 과인이 듣고 싶은 것은 인공지가 좋으냐 나쁘냐가 아니다.</p>\n<p><strong>왕:</strong> <em>(자리에서 일어나 창밖을 바라보며)</em> 과인이 알고 싶은 것은 이것이다.</p>\n<hr>\n<p><strong>왕:</strong> <strong>&quot;인공지 시대에, 진짜 인재를 어찌 알아보느냐?&quot;</strong></p>\n<hr>\n<p><strong>왕:</strong> 과거시험 수석이 제가 만든 것도 못 고친다. 답안지는 죄다 판박이다.</p>\n<p><strong>왕:</strong> 지금 시험으로는 진짜 실력자를 가릴 수가 없다.</p>\n<hr>\n<p><strong>왕:</strong> <em>(영의정과 좌의정을 바라보며)</em> 경들에게 명하노라.</p>\n<p><strong>영의정·좌의정:</strong> 예, 전하.</p>\n<hr>\n<p><strong>왕:</strong> 인공지 시대에 맞는 새로운 인재 선발 방법을 찾아오라.</p>\n<p><strong>왕:</strong> 진짜 실력이 무엇인지, 어찌 가려낼 것인지, 과인을 납득시켜라.</p>\n<hr>\n<p><strong>왕:</strong> 한 달을 주겠다. 매 칠일(七日)마다 경들이 찾은 것을 과인에게 보고하라.</p>\n<p><strong>영의정:</strong> 성명을 받들겠사옵니다.</p>\n<p><strong>좌의정:</strong> 성명을 받들겠사옵니다.</p>\n<hr>\n<p><strong>왕:</strong> 아, 그리고 한 가지 더.</p>\n<p><strong>왕:</strong> 인공지를 실제로 쓰는 자들을 데려오라. 다양하게. 분명 저마다 쓰는 법이 다를 것이니.</p>\n<p><strong>왕:</strong> 탁상공론 말고, 실제로 어찌 돌아가는지 과인이 직접 듣겠다.</p>\n<p><strong>영의정:</strong> 명심하겠사옵니다.</p>\n<hr>\n<h3 id=\"왕-창밖을-바라보며\">[왕, 창밖을 바라보며]</h3>\n<hr>\n<p><strong>왕:</strong> <em>(혼잣말)</em> 인공지 시대에 <strong>진짜 잘하는 자가 누구인지</strong>... 반드시 찾아내겠다.</p>\n<hr>\n<h3 id=\"막-내림\">[막 내림]</h3>\n<hr>\n<p><strong>- 프롤로그 끝 -</strong></p>\n<p><strong>다음 화: 제1화 - 이름을 알아야 부른다</strong></p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://velog.io/@teo/%EC%A1%B0%EC%84%A0%EA%B0%9C%EB%B0%9C%EC%8B%A4%EB%A1%9D-%ED%94%84%EB%A1%A4%EB%A1%9C%EA%B7%B8-%EA%B3%BC%EA%B1%B0%EC%8B%9C%ED%97%98%EC%9D%84-%EC%96%B4%EC%B0%8C%ED%95%A0%EA%BC%AC"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "나만의 로컬 AI 코딩 환경 (WSL2 + Ollama + Continue)",
    "partialText": "<p>최근 딥러닝 학습과 코딩을 병행하며 보안과 속도, 두 마리 토끼를 잡기 위해 <strong>로컬 LLM</strong> 환경을 구축했습니다. 특히 <strong>RTX 5060 Ti 16GB</strong>의 넉넉한 VRAM을 활용해 고성능 모델인 <strong>Qwen2.5-Coder 14B</strong>를 올린 최적의 세팅을 공유합니다.</p>\n<hr>\n<h2 id=\"1-환경-구성-및-하드웨어\">1. 환경 구성 및 하드웨어\n</h2><ul>\n<li><strong>GPU</strong>: NVIDIA RTX 5060 Ti (16GB VRAM) - <em>14B 모델 구동의 마지노선이자 최적의 선택</em></li>\n<li><strong>OS</strong>: Windows 11 + WSL2 (Ubuntu)</li>\n<li><strong>Backend</strong>: <a class=\"link\" href=\"https://ollama.com/\"  target=\"_blank\" rel=\"noopener\"\n    >Ollama</a> (Windows용 설치)</li>\n<li><strong>IDE</strong>: VS Code + <a class=\"link\" href=\"https://www.continue.dev/\"  target=\"_blank\" rel=\"noopener\"\n    >Continue</a> Extension</li>\n</ul>\n<hr>\n<h2 id=\"2-ollama--모델-세팅\">2. Ollama &amp; 모델 세팅\n</h2><p>먼저 로컬에서 AI의 뇌 역할을 할 모델을 내려받습니다. 16GB VRAM 기준, 코딩 실력이 검증된 <strong>14B 모델</strong>이 가장 쾌적합니다.</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tr><td class=\"lntd\">\n<pre tabindex=\"0\" class=\"chroma\"><code><span class=\"lnt\">1\n</span><span class=\"lnt\">2\n</span><span class=\"lnt\">3\n</span><span class=\"lnt\">4\n</span><span class=\"lnt\">5\n</span><span class=\"lnt\">6\n</span><span class=\"lnt\">7\n</span><span class=\"lnt\">8\n</span></code></pre></td>\n<td class=\"lntd\">\n<pre tabindex=\"0\" class=\"chroma\"><code class=\"language-bash\" data-lang=\"bash\"><span class=\"line\"><span class=\"cl\"><span class=\"c1\"># 모델 다운로드 (약 9GB)</span>\n</span></span><span class=\"line\"><span class=\"cl\">ollama pull qwen2.5-coder:14b-instruct\n</span></span><span class=\"line\"><span class=\"cl\">\n</span></span><span class=\"line\"><span class=\"cl\"><span class=\"c1\"># 임베딩 모델 (코드베이스 검색용)</span>\n</span></span><span class=\"line\"><span class=\"cl\">ollama pull nomic-embed-text\n</span></span><span class=\"line\"><span class=\"cl\">\n</span></span><span class=\"line\"><span class=\"cl\"><span class=\"c1\"># 짧은 별명 만들기 (선택사항)</span>\n</span></span><span class=\"line\"><span class=\"cl\">ollama cp qwen2.5-coder:14b-instruct qwen14\n</span></span></code></pre></td></tr></table>\n</div>\n</div><hr>\n<h2 id=\"3-continue-설정-configyaml\">3. Continue 설정 (config.yaml)\n</h2><p>VS Code에서 Continue 확장 프로그램을 설치한 후, <code>~/.continue/config.yaml</code>을 다음과 같이 설정합니다. 불필요한 설정을 걷어내고 로컬 Ollama에 집중한 구성입니다.</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tr><td class=\"lntd\">\n<pre tabindex=\"0\" class=\"chroma\"><code><span class=\"lnt\"> 1\n</span><span class=\"lnt\"> 2\n</span><span class=\"lnt\"> 3\n</span><span class=\"lnt\"> 4\n</span><span class=\"lnt\"> 5\n</span><span class=\"lnt\"> 6\n</span><span class=\"lnt\"> 7\n</span><span class=\"lnt\"> 8\n</span><span class=\"lnt\"> 9\n</span><span class=\"lnt\">10\n</span><span class=\"lnt\">11\n</span><span class=\"lnt\">12\n</span><span class=\"lnt\">13\n</span><span class=\"lnt\">14\n</span><span class=\"lnt\">15\n</span><span class=\"lnt\">16\n</span><span class=\"lnt\">17\n</span><span class=\"lnt\">18\n</span></code></pre></td>\n<td class=\"lntd\">\n<pre tabindex=\"0\" class=\"chroma\"><code class=\"language-yaml\" data-lang=\"yaml\"><span class=\"line\"><span class=\"cl\"><span class=\"nt\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">Local Config</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"nt\">version</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"m\">1.0.0</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"nt\">schema</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">v1</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"nt\">models</span><span class=\"p\">:</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">  </span>- <span class=\"nt\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">Qwen14</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">    </span><span class=\"nt\">provider</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">ollama</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">    </span><span class=\"nt\">model</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">qwen2.5-coder:14b-instruct</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">    </span><span class=\"nt\">apiBase</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">http://127.0.0.1:11434</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">    </span><span class=\"nt\">roles</span><span class=\"p\">:</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">      </span>- <span class=\"l\">chat</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">      </span>- <span class=\"l\">edit</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">      </span>- <span class=\"l\">apply</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">      </span>- <span class=\"l\">autocomplete</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\">- <span class=\"nt\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">Nomic Embed</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">    </span><span class=\"nt\">provider</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">ollama</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">    </span><span class=\"nt\">model</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l\">nomic-embed-text:latest</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">    </span><span class=\"nt\">roles</span><span class=\"p\">:</span><span class=\"w\">\n</span></span></span><span class=\"line\"><span class=\"cl\"><span class=\"w\">      </span>- <span class=\"l\">embed</span><span class=\"w\">\n</span></span></span></code></pre></td></tr></table>\n</div>\n</div><hr>\n<h2 id=\"4-슬래시-커맨드-커스터마이징-md-방식\">4. 슬래시 커맨드 커스터마이징 (.md 방식)\n</h2><p>최신 Continue 버전에서는 <code>config.yaml</code>을 직접 수정하는 대신, <code>.md</code> 파일을 통해 명령어를 추가하는 방식을 권장합니다.</p>\n<h3 id=\"-continuepromptscommitmd\">📄 ~/.continue/prompts/commit.md\n</h3><p>이 파일을 생성하면 채팅창에서 <code>/commit</code> 한 번으로 <strong>스테이징된 파일들만 분석</strong>하여 커밋 메시지를 자동 생성할 수 있습니다.</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tr><td class=\"lntd\">\n<pre tabindex=\"0\" class=\"chroma\"><code><span class=\"lnt\">1\n</span><span class=\"lnt\">2\n</span><span class=\"lnt\">3\n</span><span class=\"lnt\">4\n</span><span class=\"lnt\">5\n</span><span class=\"lnt\">6\n</span><span class=\"lnt\">7\n</span><span class=\"lnt\">8\n</span><span class=\"lnt\">9\n</span></code></pre></td>\n<td class=\"lntd\">\n<pre tabindex=\"0\" class=\"chroma\"><code class=\"language-markdown\" data-lang=\"markdown\"><span class=\"line\"><span class=\"cl\">---\n</span></span><span class=\"line\"><span class=\"cl\">name: commit\n</span></span><span class=\"line\"><span class=\"cl\">description: &#34;스테이징된 변경 사항으로 커밋 메시지 생성&#34;\n</span></span><span class=\"line\"><span class=\"cl\">invokable: true\n</span></span><span class=\"line\"><span class=\"cl\">---\n</span></span><span class=\"line\"><span class=\"cl\">Analyze ONLY the STAGED changes (git diff --cached).\n</span></span><span class=\"line\"><span class=\"cl\">Ignore unstaged changes.\n</span></span><span class=\"line\"><span class=\"cl\">Generate a concise commit message in Korean following conventional commits format.\n</span></span><span class=\"line\"><span class=\"cl\">DO NOT use tools. Output only the message.\n</span></span></code></pre></td></tr></table>\n</div>\n</div><hr>\n<h2 id=\"5-마치며\">5. 마치며\n</h2><p>이제 내 컴퓨터 안에서 보안 걱정 없이, 인터넷 연결 없이도 최고의 코딩 비서를 부릴 수 있게 되었습니다. 특히 <code>@</code> 기호를 사용하여 특정 파일이나 코드베이스 전체를 맥락으로 던져주는 기능은 로컬 환경에서 더 빛을 발합니다.</p>",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://cliearl.github.io/posts/linux/wsl2-ollama-continue/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "Beyond Functors, All the Way to Monads",
    "partialText": "In this post, I’ll continue from the concept of functors I covered previously and move on to explaining monads. When people hear “monad,” the first thing that usually comes to mind is the infamous explanation: “A monad is a monoid in the category of endofunctors, blah blah blah.” While this is technically the most accurate description of a monad, it’s also the most unhelpful one. There’s even a well-known meme called the “monad curse” — the idea that the moment you understand monads, you lose the ability to explain them. For those of us who aren’t deeply versed in mathematics, monads are indeed a notoriously elusive concept. With that in mind, I’m going to take my own ambitious crack at explaining monads. (Of course, I might fail…)",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://evan-moon.github.io/2026/02/07/monads-in-typescript/en/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "펑터를 넘어서, 모나드까지",
    "partialText": "이번 포스팅에서는 이전에 다뤘던 펑터의 개념에 이어 모나드에 대한 설명을 이어가보려고 한다. 아무래도 모나드라고 하면 가장 먼저 떠오르는 것은 “모나드는 내부함자 범주의 모노이드 대상 어쩌고”하는 설명인데, 사실 이것은 모나드를 가장 잘 설명하는 문장이면서도 가장 설명을 못하는 문장이기도 하다. 모나드를 이해하는 순간 모나드를 설명할 수 없게 되어버린다는 모나드의 저주라고 불리는 유명한 밈이 존재할만큼, 수학을 잘 모르는 입장에서는 참 이해하기 난해한 대상이기는 하다. 이에 필자도 야심차게 모나드를 설명하기 위한 도전을 한번 해보려고 한다. (물론 실패할 수도 있다…)",
    "date": "2026-02-08T08:02:53.769Z",
    "url": "https://evan-moon.github.io/2026/02/07/monads-in-typescript/"
  }
]