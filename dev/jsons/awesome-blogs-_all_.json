[
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "무한의 덧셈",
    "partialText": "딸이 덧셈 뺄셈을 배우며 힘들어 하는 걸 보며 도와줄 수 있는 방법이 없을까 생각들었습니다. 간단한 게임을 만들어 보면 어떨까?",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://jeho.page/essay/2026/02/14/infinite-addition.html"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "AI 코딩이 오히려 개발자의 생산성을 떨어뜨린다? - Anthropic 논문",
    "partialText": "Anthropic에서 개발자 생산성에 AI가 미치는 영향을 탐구한 매우 흥미로운 논문(https://arxiv.org/pdf/2601.20245)을을) 발표했다.\n놀랍게도, AI 기반 코딩이 실제로는 생산성을 높이지 않을 수도 있다는 결과가 나왔는데,&nbsp; 프롬프트를 작성하고 다듬는 과정, 그리고 생성된 결과를 해석하는 데 상당한 시간이 소요되기 때문이다. 게다가 엔지니어가 핵심 개념을 이해하거나 코드 구조를 파악하고, 직접 디버깅해 볼 기회를 뺏..",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://bcho.tistory.com/1500"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "AI 코딩 플랫폼 트렌드 비교(Claude Code, Codex,Gemini)",
    "partialText": "조대협 (http://bcho.tistory.com)\n&nbsp;\n작년이 Cursor, Winsurf등 AI 코딩 도구와 Lovable, Replit 등의 바이브 코딩으로 시작되는 한해였다면, 금년은 Claude Code와 같은 CLI 기반의 에이전트 코딩으로 넘어가는 한해이다.\n&nbsp;\n2026년 트랜드 변화\n2025년에는 개발자들이 전체 코드가 아니라 일부 모듈이나 코딩 부분을 Cursor 와 같은 IDE에서 개발하는 정도로, AI의 도움을 받아..",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://bcho.tistory.com/1499"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "AI 시대의 Fail Fast: 실패의 수준이 달라졌다",
    "partialText": "<p>&ldquo;빠르게 실패하라(Fail Fast).&rdquo;</p>\n<p>스타트업과 프로덕트 세계에서 가장 많이 들리는 조언 중 하나다. 아이디어를 빠르게 시장에 내놓고, 피드백을 받고, 방향을 수정하라. 틀린 말이 아니다. 하지만 현실은 종종 이랬다. 빠르게 만드느라 수준이 떨어지고, 수준이 떨어지니 피드백 자체가 왜곡되고, 왜곡된 피드백으로 잘못된 결론을 내린다.</p>\n<p>AI가 이 공식을 근본적으로 바꾸고 있다.</p>\n<h2 id=\"과거의-fail-fast-속도와-수준의-트레이드오프\">과거의 Fail Fast: 속도와 수준의 트레이드오프</h2>\n<p>전통적인 Fail Fast에는 구조적 한계가 있었다. 빠르게 만들려면 수준을 타협해야 했다. MVP(Minimum Viable Product)라는 이름 아래, &ldquo;최소한으로 동작하는&rdquo; 수준의 프로덕트를 만들어 시장에 내놓았다. 문제는 이 &ldquo;최소한&quot;의 수준이 너무 낮았다는 점이다.</p>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://novemberde.github.io/post/2026/02/10/AI-Fail-Fast-Product-Quality-ko/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "Amazon Redshift의 내부 Architecture: ParAccel에서 Serverless까지",
    "partialText": "<h2 id=\"용어-사전\">용어 사전</h2>\n<p>이 글에서 자주 등장하는 핵심 용어를 먼저 정리한다.</p>\n<table>\n  <thead>\n      <tr>\n          <th>용어</th>\n          <th>설명</th>\n      </tr>\n  </thead>\n  <tbody>\n      <tr>\n          <td><strong>MPP</strong> (Massively Parallel Processing)</td>\n          <td>다수의 Node가 Query를 분할하여 동시에 처리하는 Architecture</td>\n      </tr>\n      <tr>\n          <td><strong>Leader Node</strong></td>\n          <td>Client 요청을 받아 SQL Parsing, Query Planning, Code Generation을 수행하고 결과를 집계하는 Coordinator</td>\n      </tr>\n      <tr>\n          <td><strong>Compute Node</strong></td>\n          <td>실제 데이터를 저장하고 Query Segment를 병렬 실행하는 Worker Node</td>\n      </tr>\n      <tr>\n          <td><strong>Slice</strong></td>\n          <td>Compute Node 내부의 병렬 처리 단위. 독립적인 CPU, Memory, Disk Partition을 가짐</td>\n      </tr>\n      <tr>\n          <td><strong>RMS</strong> (Redshift Managed Storage)</td>\n          <td>S3 기반 Tiered Storage. Local SSD Cache + S3 Cold Storage로 구성</td>\n      </tr>\n      <tr>\n          <td><strong>AQUA</strong> (Advanced Query Accelerator)</td>\n          <td>Storage Layer에서 FPGA/Nitro Processor로 Filtering과 Aggregation을 사전 수행하는 가속기</td>\n      </tr>\n      <tr>\n          <td><strong>Zone Map</strong></td>\n          <td>각 1MB Block의 Min/Max 값을 Memory에 보관하는 Metadata. Block Skipping에 사용</td>\n      </tr>\n      <tr>\n          <td><strong>AZ64</strong></td>\n          <td>Amazon이 자체 개발한 SIMD 기반 Compression Algorithm. Numeric/Date Type에 특화</td>\n      </tr>\n      <tr>\n          <td><strong>WLM</strong> (Workload Management)</td>\n          <td>Query Queue별 Memory, Concurrency Slot을 배분하는 Resource Management 시스템</td>\n      </tr>\n      <tr>\n          <td><strong>ATO</strong> (Automatic Table Optimization)</td>\n          <td>Query Pattern을 분석하여 Distribution Key/Sort Key를 자동 최적화하는 AI 기반 기능</td>\n      </tr>\n      <tr>\n          <td><strong>RPU</strong> (Redshift Processing Unit)</td>\n          <td>Redshift Serverless의 Compute 단위. 1 RPU = 16GB Memory</td>\n      </tr>\n      <tr>\n          <td><strong>Concurrency Scaling</strong></td>\n          <td>Workload 급증 시 Transient Cluster를 자동 추가하여 Throughput을 확장하는 기능</td>\n      </tr>\n      <tr>\n          <td><strong>SQA</strong> (Short Query Acceleration)</td>\n          <td>짧은 Query를 전용 Queue(Service Class 14)에서 우선 실행하여 긴 Query에 Block되지 않게 하는 기능</td>\n      </tr>\n      <tr>\n          <td><strong>MVCC</strong> (Multi-Version Concurrency Control)</td>\n          <td>각 Transaction이 데이터의 Snapshot을 기반으로 동작하여 Read/Write Blocking을 최소화하는 동시성 제어</td>\n      </tr>\n  </tbody>\n</table>\n<hr>\n<h2 id=\"들어가며\">들어가며</h2>\n<p>Amazon Redshift는 2012년 re:Invent에서 발표되어 2013년 2월 15일 GA(General Availability)된 이후, Cloud Data Warehouse 시장의 판도를 바꾸어 놓았다. 2025년 기준 수만 개의 조직이 Petabyte 규모의 데이터를 Redshift 위에서 분석하고 있다.</p>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://novemberde.github.io/post/2026/02/09/Redshift-Internals-Architecture-ko/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "Colossus와 Capacitor: BigQuery를 지탱하는 Storage의 구조",
    "partialText": "<h2 id=\"들어가며\">들어가며</h2>\n<p>BigQuery의 Performance는 단순히 좋은 Query Engine 하나로 만들어지지 않았다. 그 아래에는 Google이 20년 넘게 진화시켜 온 Infrastructure Stack이 있다.</p>\n<ul>\n<li><strong>Colossus</strong>: Exabyte 규모의 Distributed File System</li>\n<li><strong>Capacitor</strong>: Compressed 상태에서 직접 Query할 수 있는 Columnar Format</li>\n<li><strong>Jupiter</strong>: 13 Petabits/sec Bandwidth의 Data Center Network</li>\n<li><strong>Dremel</strong>: Tree 구조 병렬 Execution Engine</li>\n<li><strong>Borg</strong>: 수만 대 Machine의 Cluster Management System</li>\n</ul>\n<p>이 글에서는 이 중 <strong>Colossus와 Capacitor</strong>에 집중한다. BigQuery에서 Query를 실행하면, 실제 데이터는 어디에 어떻게 저장되어 있고, 어떤 원리로 읽히는지 구조적으로 살펴본다.</p>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://novemberde.github.io/post/2026/02/09/Colossus-Capacitor-BigQuery-Internals-ko/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "BigQuery vs Redshift: Cloud Data Warehouse 선택을 위한 비교",
    "partialText": "<h2 id=\"용어-사전\">용어 사전</h2>\n<p>이 글에서 자주 등장하는 핵심 용어를 먼저 정리한다.</p>\n<table>\n  <thead>\n      <tr>\n          <th>용어</th>\n          <th>설명</th>\n      </tr>\n  </thead>\n  <tbody>\n      <tr>\n          <td><strong>MPP</strong> (Massively Parallel Processing)</td>\n          <td>다수의 Node가 Query를 분할하여 동시에 처리하는 Architecture</td>\n      </tr>\n      <tr>\n          <td><strong>Slot</strong></td>\n          <td>BigQuery의 Compute 단위. 가상 CPU + Memory + I/O를 추상화한 Resource Unit</td>\n      </tr>\n      <tr>\n          <td><strong>RPU</strong> (Redshift Processing Unit)</td>\n          <td>Redshift Serverless의 Compute 단위. 1 RPU = 16GB Memory</td>\n      </tr>\n      <tr>\n          <td><strong>Columnar Storage</strong></td>\n          <td>데이터를 Row가 아닌 Column 단위로 저장하는 방식. 분석 Query에서 필요한 Column만 읽어 I/O 절감</td>\n      </tr>\n      <tr>\n          <td><strong>Distribution Key</strong></td>\n          <td>Redshift에서 데이터를 Node 간에 분산하는 기준 Column. JOIN Performance에 직접 영향</td>\n      </tr>\n      <tr>\n          <td><strong>Sort Key</strong></td>\n          <td>Redshift에서 데이터를 디스크에 물리적으로 정렬하는 기준 Column. Filter Performance에 직접 영향</td>\n      </tr>\n      <tr>\n          <td><strong>Partitioning</strong></td>\n          <td>BigQuery에서 Table을 날짜/정수 범위 등으로 논리 분할. Scan 범위를 제한하여 비용과 속도 모두 개선</td>\n      </tr>\n      <tr>\n          <td><strong>Clustering</strong></td>\n          <td>BigQuery에서 Partition 내 데이터를 특정 Column 기준으로 정렬. 최대 4개 Column 지정 가능</td>\n      </tr>\n      <tr>\n          <td><strong>WLM</strong> (Workload Management)</td>\n          <td>Redshift의 Query Queue 관리 시스템. Query 종류별 Memory/Concurrency 배분</td>\n      </tr>\n      <tr>\n          <td><strong>ATO</strong> (Automatic Table Optimization)</td>\n          <td>Redshift가 Query Pattern을 분석하여 Distribution Key/Sort Key를 자동 최적화하는 기능</td>\n      </tr>\n      <tr>\n          <td><strong>Zero-ETL</strong></td>\n          <td>Source Database → Data Warehouse로 데이터를 ETL Pipeline 없이 자동 복제하는 기능</td>\n      </tr>\n      <tr>\n          <td><strong>Dry Run</strong></td>\n          <td>BigQuery에서 Query를 실행하지 않고 Scan량과 예상 비용만 미리 확인하는 기능. 무료</td>\n      </tr>\n      <tr>\n          <td><strong>AQUA</strong> (Advanced Query Accelerator)</td>\n          <td>Redshift RA3 Node에서 Storage Layer의 AWS 전용 Processor/FPGA로 사전 Filtering/Aggregation을 수행하는 가속기</td>\n      </tr>\n      <tr>\n          <td><strong>Materialized View</strong></td>\n          <td>Query 결과를 사전 계산하여 저장한 View. 반복 Query의 속도를 크게 개선</td>\n      </tr>\n      <tr>\n          <td><strong>BI Engine</strong></td>\n          <td>BigQuery의 In-memory Analysis Layer. Sub-second Response로 Dashboard를 가속</td>\n      </tr>\n  </tbody>\n</table>\n<hr>\n<h2 id=\"들어가며\">들어가며</h2>\n<p>Cloud Data Warehouse를 선택하는 일은 단순한 기술 비교가 아니다. 조직의 데이터 전략, 운영 문화, 그리고 장기적인 Cloud Roadmap에 깊이 관여하는 의사결정이다.</p>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://novemberde.github.io/post/2026/02/08/BigQuery-vs-Redshift-Deep-Dive-ko/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "블랙베리",
    "partialText": "<blockquote data-ke-style=\"style2\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p><a href=\"https://www.ctvnews.ca/business/article/jim-balsillie-sets-the-record-straight-on-blackberry-movie/\">짐 발실리가 영화 블랙베리에 대해 자신의 입장을 밝힌 인터뷰 기사</a>도 함께 보면 더 재밌다.</p>\n</span></p></blockquote><p>박소령 대표님의 실패를 통과하는 일을 다 보고, 이어서 넷플릭스에서 <a href=\"https://www.netflix.com/kr/title/81725542\">블랙베리</a>를 봤다.<br>2시간이 너무 짧았다.<br>더 깊게 이야기를 보고 싶었는데, 2시간 동안 십수 년의 기록을 담아두려니 생략된 이야기가 많아서 아쉬웠다.  </p>\n<p>아쉬움과는 별개로 마음에 확 와닿는 대화 내용들이 몇 개 있었다.  </p>\n<hr>\n<p>더그 프레긴은 블랙베리 특유의 분위기를 계속해서 유지하려고 하며, 그와 같은 생각을 했던 마이크는 점점 기업의 CEO로 변해갔다.</p>\n<p>베스트 프렌드이자 공동 창업자였던 더그 프레긴과 마이크 라자리디스의 대화다.  </p>\n<blockquote data-ke-style=\"style2\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>더그: &quot;저거 봤어?&quot;<br>마이크: &quot;아니&quot;<br>더그: &quot;짐이 영화의 밤을 없앴어.<br>직접 할 배짱도 없어서 140kg 덩치를 불러서는 소리 지르고 다니게 했잖아.<br>앨런을 해고하겠다고 했대&quot;<br>마이크: &quot;... 일을 하긴 해야 해&quot;<br>더그: &quot;이 친구들이 일주일에 80시간을 기꺼이 일하는 이유를 알긴 해? 가족도 못 만나고, 인정도 못 받는데?&quot;<br>마이크: &quot;알지, 세계 최고의 휴대폰을 만들고 있으니까&quot;<br>더그: &quot;그래. 그런가 보다&quot;</p>\n</span></p></blockquote><p>스타트업에서는 일을 일처럼 보지 않는 문화가 많다.<br>그런 문화가 성과를 최적화하는 데는 방해가 된다.<br>그래서 조직이 커지다 보면 그런 문화가 점점 옅어지게 된다.  </p>\n<p>반면에, 새로운 시도는 그런 문화 속에서 더 쉽게 시작할 수 있는 것 같다.<br>만약에 블랙베리가 일반적인 대기업으로 변해가지 않고, 위 문화를 유지했다면 아이폰의 등장을 어떻게 봤을까?<br>분해하고, 해체하고, 모방하고, 시도하고 그러면서 자연스레 블랙베리만의 스마트폰을 만들어가지 않았을까? 생각이 들었다.  </p>\n<hr>\n<p>아이폰의 발표 이후 투자자들의 기대를 충족시키기 위해 마이크는 공수표를 남발한다.</p>\n<blockquote data-ke-style=\"style2\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>마이크: &quot;짐은 지금 워터루에 있어요.<br>다른 얘기는 하지 않기로 약속했는데, 아직 완성 단계는 아니지만 극비에 개발 중인 기술이 있거든요.<br>시제품이 나오려면 몇 주가 더 필요하지만.<br>큰 틀은 우리 블랙베리에요.<br>다만 여기 있는 키보드가 화면이에요.<br>전체가 다 스크린이죠.<br>대신 우리 제품은 이걸 누르면 그대로 경험할 수 있어요.<br>달칵하는 블랙베리의 키감을 느낄 수 있죠.<br>스크린, 키보드, 전화.<br>감이 오시나요?&quot;  </p>\n</span></p></blockquote><p>이 발표로 마이크는 <strong>버라이즌에 100만대를 판매</strong>한다.  </p>\n<p>그리고 몇 주 내 시제품을 보여줘야 하기 때문에 엔지니어링 팀에게 갑작스러운 요구 사항을 전달한다.</p>\n<blockquote data-ke-style=\"style2\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>마이크: &quot;아니, 아니야 잘 들어.<br>스크린이긴 한데 내가 여기 쓴 대로 경첩이든 액추에이터든 다는 거야.<br>화면이랑 몸체 사이에.<br>그러면 화면을 누를 때마다 달칵거리겠지.&quot;  </p>\n<p>폴 스태노스: &quot;이걸 왜 하는지 궁금해요&quot;  </p>\n<p>마이크: &quot;지금 여기에서 그런 질문은 하면 안되지.<br>&#39;왜&#39; 는 몰라도 돼! 알겠어?<br>내가 하라잖아.<br>내가 이걸 팔았다고, 알겠어?<br>근데 누구야?&quot;  </p>\n</span></p></blockquote><p>&quot;&#39;왜&#39;는 몰라도 돼&quot; 라는 말을 나는 몇 번을 했을까? 란 생각이 들었다.<br>스스로는 하지 않았다고 생각하지만, 막상 또 팀원들이 보기엔 표현 방식만 다를 뿐이지 같은 뜻으로 전달받기도 했겠지?  </p>\n<p>해야 할 일을 당장 시작하기 위해서 설명을 하다가 나 스스로 설명을 포기하고 &quot;일단 해&quot;라고 얘기한 적은 없을까 기억을 많이 뒤적이게 된다.  </p>\n<p>마이크는 점점 거대기업의 CEO가 되어간다.<br>블랙베리 초반, 팀이 풀지 못했던 엔지니어링 문제를 풀기 위해 데려왔던 구글 엔지니어링 팀장인 폴 스태노스를 더 이상 기억하지 못하기도 하는 장면이기도 했다.    </p>\n<p>이 장면이 특히나 기억에 남았던 것은 영화 초반에 마이크는 짐에게 핸드폰을 더 판매하지 말아달라는 부탁을 했기 때문이다.  </p>\n<p>현재 블랙베리의 완성도와 안정성을 위해 더 이상 판매하지 말고 물량을 조절해야 한다는 의견을 계속 피력한다.  </p>\n<p>그랬던 마이크가 이제는 공수표를 남발하면서까지 세일즈를 한다.<br>납득할 수 없는 납기일과 사전에 얘기되지 않은 기능까지 요구하면서 결국은 고객이 등을 돌리게 만드는 제품을 출시하게 된다.  </p>\n<p>마이크는 자신이 만든 제품에 대한 자부심이 강했기에 후발주자이자 블랙베리와 완전히 대척점에 선 제품인 아이폰을 용납할 수 없다.<br>그래서 같은 터치폰을 만드는 과정에서도 결코 &#39;아이폰 같은&#39; 이란 표현은 쓰지 않는다.<br>병적으로.</p>\n<blockquote data-ke-style=\"style2\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>더그: &quot;정리하면 블랙베리만의 키감을 유지하면서 아이폰의 화면을 접목하면 돼.<br>그게 다야.&quot;<br>마이크: &quot;아니야, 그게 아니지!<br>애플의 무언가를 접목하는 게 아니야.<br>여러분 어려운 일이 아니야.<br>돈을 많이 받았잖아.<br>어렵지 않아.<br>결국 키보드야.<br>화면 위에 키보드.<br>어떻게 생각하든 상관 없어&quot;</p>\n</span></p></blockquote><hr>\n<p>조화로워보였던 짐과 마이크의 협업도 점점 서로간의 방임으로 가기 시작했다.  </p>\n<blockquote data-ke-style=\"style2\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>팀원: &quot;아이폰에 대한 소비자 기대치가 사상 최고를 기록했어요.<br>세계 1위 휴대폰에서 아이폰 이전 휴대폰이 되게 생겼다고요.&quot;<br>짐: &quot;괜찮아. 마이크가 해결할 거야&quot;</p>\n</span></p></blockquote><blockquote data-ke-style=\"style2\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>마이크: &quot;증권 거래 위원회가 왜 우릴 조사해요? 스톡옵션 일이라던데&quot;<br>짐: &quot;별일 아닐 거예요&quot;<br>마이크: &quot;별일 아니에요?&quot;<br>짐: &quot;그럼요. 애플 일은 어때요? 우리 위험해요?&quot;<br>마이크: &quot;아뇨.&quot;<br>짐: &quot;어째서요?&quot;<br>마이크: &quot;기기당 데이터 사용량이 블랙베리 5,000대고 키보드도 없고 그냥 말이 안 되니까요.&quot;<br>짐: &quot;다들 우리가 끝났다고 떠들어 대는데요?&quot;<br>마이크: &quot;다들 멍청이거든요.&quot;</p>\n</span></p></blockquote><p>서로가 서로의 영역을 모니터링하지 않았다.<br>제품이 뒤처지고 있어도 &quot;마이크가 알아서 하겠지&quot;라고 생각했고,<br>세일즈가 무리한 약속을 해도 &quot;짐이 알아서 하겠지&quot;라고 넘겼다.</p>\n<p><strong>공동 CEO 체제의 장점은 전문성의 분담이지만, 단점은 책임의 분산</strong>이다.<br>블랙베리에서는 그 단점이 극대화되었다.<br>서로의 영역에 간섭하지 않는 것이 <strong>신뢰</strong>가 아니라 <strong>무관심</strong>이 되어버린 것이다.  </p>\n<p>만약 단일 CEO였다면 어땠을까?<br>영업과 제품 둘 다 문제가 있을 경우 둘 다 CEO가 강력하게 개입했을 것이다.  </p>\n<p>각 분야별 C레벨이 있더라도 결국은 CEO가 최종적으로 결정을 내리는 구조로 갈 수밖에 없는 이유를 영화로 본 것 같았다.</p>\n<hr>\n<p>레딧에서 흥미로운 질문을 봤다.</p>\n<ul>\n<li><a href=\"https://www.reddit.com/r/blackberry/comments/193rgt2/is_mike_or_jim_more_at_fault_for_the_fall_of/?tl=ko\">마이크와 짐 중에 블랙베리 몰락에 더 책임이 있는 사람은 누구일까?</a></li>\n</ul>\n<p>같은 회사를 이끌면서도 서로 다른 꿈을 꾸고 있었다.</p>\n<p>실제로 짐 발실리는 NHL 하키팀 인수에 집착하느라 회사 일에 소홀했다는 비판을 받는다.<br>피츠버그 펭귄스, 내슈빌 프레데터스, 피닉스 코요테스까지 세 번이나 팀 인수를 시도했고, 모두 실패했다.<br>2008~2010년 RIM에서 일했던 한 직원은 레딧에 이렇게 썼다.</p>\n<blockquote data-ke-style=\"style2\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>&quot;짐은 하키팀 사는 데 너무 몰두해서 시장에서 눈을 떼버렸다.<br>나는 실리콘밸리에 살았는데, 아이폰에 대한 열광이 진짜라는 걸 봤다.<br>하지만 RIM 임원들은 그걸 믿지 않았다.&quot;</p>\n</span></p></blockquote><p>한편 마이크 라자리디스는 물리 키보드에 대한 자부심에 갇혀 터치스크린으로의 전환을 거부했다.<br>아이폰이 2007년 6월에 나왔는데, 블랙베리가 터치스크린 폰을 내놓은 건 짐 발실리가 경영에서 물러난 이후였다.  </p>\n<hr>\n<p>상호 보완적인 상위 레벨의 구조는 &quot;역할 분담&quot;만 있어서는 안 되고 &quot;상호 이해&quot;도 있어야 한다는 걸 새삼 느끼게 됐다.  </p>\n<p>나와 대표님도 역할이 나뉘어 있다.<br>대표님은 비즈니스와 전략을, 나는 기술과 제품을 담당한다.<br>하지만 그것이 <strong>상호보완</strong>이 되려면, 서로의 영역에 대한 관심과 이해가 필요하다.<br>&quot;저건 대표님 영역이니까&quot;, &quot;저건 CTO 영역이니까&quot;라고 선을 긋는 순간, 우리도 블랙베리처럼 동상이몽에 빠질 수 있다.  </p>\n<p>역할만 나누고 이해가 없으면, 그건 그냥 <strong>분리</strong>일 뿐이다.<br>블랙베리의 두 CEO는 역할은 완벽히 나눴지만, 상호 이해는 없었다.<br>그래서 위기가 왔을 때 서로를 도울 수 없었다.</p>\n<p>기술 리더로서 비즈니스를 이해하려는 노력,<br>비즈니스 리더로서 기술을 이해하려는 노력,<br>이 양방향의 노력이 있어야 진정한 파트너십이 된다.<br>그렇지 않으면 &quot;저 사람이 알아서 하겠지&quot;라는 방치로 이어지고, 결국 조직 전체가 무너진다.  </p>\n<p>요즘 회계 공부를 시작한 것도 그런 맥락이다.<br>기술만 잘하면 된다고 생각했던 때가 있었다.<br>하지만 대표님이 보는 숫자를 나도 읽을 수 있어야, 같은 그림을 보고 대화할 수 있다.<br>서로의 언어를 이해하려는 노력 없이는 결국 &quot;마이크가 알아서 하겠지&quot;, &quot;짐이 알아서 하겠지&quot;가 되어버린다.</p>\n<p><strong>역할을 나누되, 관심은 나누지 말아야 한다</strong>.</p>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://jojoldu.tistory.com/863"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[SE-0508] Array expression trailing closures",
    "partialText": "<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">안녕하세요.&nbsp;<span style=\"color: #409d00;\"><b>그린</b></span>입니다  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이번 포스팅에서는&nbsp;<span style=\"background-color: #9feec3;\"><b>SE-0508 Array expression trailing closures</b></span>에 대해 정리해보겠습니다  </span><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"></span></p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"123123.001.jpeg\" data-origin-width=\"400\" data-origin-height=\"400\"><span data-url=\"https://blog.kakaocdn.net/dn/lVn5h/dJMcaaxtxgV/YOvOdlsqXs5DWM4QP2WLO1/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/lVn5h/dJMcaaxtxgV/YOvOdlsqXs5DWM4QP2WLO1/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/lVn5h/dJMcaaxtxgV/YOvOdlsqXs5DWM4QP2WLO1/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlVn5h%2FdJMcaaxtxgV%2FYOvOdlsqXs5DWM4QP2WLO1%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"400\" height=\"400\" data-filename=\"123123.001.jpeg\" data-origin-width=\"400\" data-origin-height=\"400\"/></span></figure>\n</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Intro</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift에서 trailing closure는 정말 자주 쓰는 문법이죠.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">그런데 array나 dictionary 타입 뒤에는 trailing closure를 쓸 수 없다는 걸 아셨나요?<br /><br /></span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">[String]&nbsp;같은 타입 뒤에 중괄호를 쓰면 파서가 제대로 인식하지 못해서 에러가 발생합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이번 SE-0508은 바로 이 제약을 풀어주는 제안입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이미&nbsp;<b>Accepted</b>&nbsp;상태이고 구현도 완료되었으니, 곧 실제로 활용할 수 있을거에요  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>왜 필요한가?</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array에 trailing closure를 받는&nbsp;init을 정의하는 건 꽤 합리적인 디자인입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">예를 들어&nbsp;@ArrayBuilder&nbsp;result builder가 있다면</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension Array {\n    init(@ArrayBuilder build: () -&gt; [Element]) {\n        self = build()\n    }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">또는 nil을 반환할 때까지 element를 생성하는 init</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension Array {\n    init(generate: () -&gt; Element?) {\n        self = []\n        while let element = generate() {\n            append(element)\n        }\n    }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>하지만 이렇게 쓸 수 없습니다</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">대부분의 경우 closure를 받는&nbsp;init은 trailing closure 문법으로 호출할 수 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">그런데&nbsp;Array나&nbsp;Dictionary&nbsp;타입에서는 파서가 이를 허용하지 않아요.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>// error: 'let' declarations cannot be computed properties\nlet value = [String] {\n  \"a\"\n}\n\n// error: variable with getter/setter cannot have an initial value\nvar value = [String] {\n  \"a\"\n}\n\n// error: closure expression is unused\nlet value = [String]\n{\n  \"a\"\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">대신 이렇게 써야 합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let value = [String].init {\n  \"a\"\n}\n\nlet value = [String]() {\n  \"a\"\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>InlineArray는 된다?</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">흥미롭게도&nbsp;InlineArray에서는 trailing closure가&nbsp;<b>이미 지원됩니다</b>:</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let powersOfTwo = [4 of Int] { index in\n  1 &lt;&lt; index\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p data-ke-size=\"size16\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array와&nbsp;Dictionary에서만 안 되는 건 불필요한 제약이고,&nbsp;InlineArray와도 일관성이 없습니다.</span></p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>제안된 해결책</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array 타입과 dictionary 타입 뒤에 trailing closure를 쓸 수 있게 합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let value = [String] {\n  \"a\"\n}\n\nlet value = [String: Int] {\n  (key: \"a\", value: 42)\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">이제 이런 코드가 정상적으로 파싱되고 컴파일됩니다!</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>어떻게 동작하나?</b></span></h2>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">현재 파싱 동작을 이해하려면 두 가지를 알아야 합니다.</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>1.&nbsp;[...]는 항상 literal로 파싱됨</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">표현식을 파싱할 때&nbsp;[...]&nbsp;토큰은 항상 array나 dictionary&nbsp;<b>literal</b>로 파싱됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">[String]이나&nbsp;[String: Int]&nbsp;같은 경우, 필요하면 타입 체크 단계에서 array/dictionary&nbsp;<b>타입</b>으로 변환됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">[String]이 실제로는&nbsp;let String = \"a\"&nbsp;프로퍼티를 사용하는 단일 요소 array literal일 수도 있으니까요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>2. 중괄호는 trailing closure... 단 literal 뒤는 제외</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">표현식 뒤에&nbsp;{&nbsp;토큰이 오면 trailing closure로 해석됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>단, 이전 표현식이 literal인 경우는 제외</b>입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift 5.2에서&nbsp;callAsFunction이 도입되기 전(SE-0253)까지는 이게 합리적이었습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">literal 뒤에 trailing closure가 올 valid한 케이스가 없었거든요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>솔루션</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><b><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array와 dictionary literal 뒤에 trailing closure를 허용하도록 변경합니다.</span></b></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이렇게 하면 이런 init(_:) trailing closure 예시가 제대로 파싱되고 컴파일됩니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let value = [String] {\n  \"a\"\n}\n\nlet value = [String: Int] {\n  (key: \"a\", value: 42)\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>추가 효과: callAsFunction도 지원</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">결과적으로 callAsFunction trailing closure도 지원됩니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension Array {\n    func callAsFunction&lt;T&gt;(mapElement: (Element) -&gt; T) -&gt; [T] {\n        map(mapElement)\n    }\n}\n\nlet value = [\"a\", \"b\", \"c\"] {\n    $0.uppercased()\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">작은 비용으로 언어의 표현력과 일관성이 크게 향상됩니다.</span></blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>호환성</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Source compatibility</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이 파싱 변경은 array literal 뒤에 오는 기존 closure literal의 의미를 바꿉니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 현재 실제로 컴파일되는 케이스는 거의 없어요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">대부분은 closure expression is unused 에러가 납니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>[\"a\", \"b\", \"c\"] { // error: closure expression is unused\n  \"a\"\n}\n\n[\"a\", \"b\", \"c\"]\n{ \"a\" } // error: closure expression is unused</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>에러가 안 나는 유일한 케이스</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Closure를 받는 result builder에서만 에러가 안 납니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>@resultBuilder\nenum FunctionArrayBuilder {\n    static func buildBlock(_ components: (() -&gt; Void)...) -&gt; [() -&gt; Void] {\n        components\n    }\n}\n\n@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    { print(array) }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이 코드는 이제 컴파일되지 않습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><b><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 이 result builder 케이스는 이미 매우 취약하고 비실용적입니다.</span></b></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>왜 취약한가?</b></span></h2>\n<ul style=\"list-style-type: circle; color: #000000; text-align: start;\" data-ke-list-type=\"circle\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>연속된 closure literal은 세미콜론 없이 지원 안 됨</b></span></li>\n</ul>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    { print(\"a\") }\n    { print(\"b\") } // error: extra trailing closure passed in call\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<ul style=\"list-style-type: circle; color: #000000; text-align: start;\" data-ke-list-type=\"circle\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>작은 변경으로도 컴파일이 깨짐</b></span></li>\n</ul>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>// Compiles\n@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    { print(array) };\n    { print(array.count) }\n}</code></pre>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>// Doesn't compile\n@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    let count = array.count\n    { print(array) }; // error: cannot convert value of type '()' to closure result type 'Bool'\n    { print(count) }\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<ul style=\"list-style-type: circle; color: #000000; text-align: start;\" data-ke-list-type=\"circle\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>callAsFunction이 있으면 의미가 바뀜</b></span></li>\n</ul>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension Int {\n  func callAsFunction(_ closure: () -&gt; Void) -&gt; Int {\n    closure()\n    return self\n  }\n}\n\n@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    let count = array.count\n    { print(array) }; // callAsFunction trailing closure, not an accumulated result builder value\n    { print(count) }\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">이런 케이스는 실제로 사용되는 예시가 없고, 더 복잡한 파싱 규칙으로 수용하는 것보다 이 source break를 받아들이는 게 낫다고 판단했습니다.</span></blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>ABI compatibility</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">기존 선언에 대한 새로운 callsite 문법만 추가하는 거라 ABI에 영향이 없습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>향후 방향</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>모든 literal에 trailing closure 허용?</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이 제안은 array와 dictionary literal만 지원합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">더 나아가서&nbsp;<b>모든 literal</b>에 trailing closure를 허용할 수도 있어요.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>extension String {\n  func callAsFunction(_ closure: (String) -&gt; Void) {\n    closure(self)\n  }\n}\n\n\"Hello world\" { // currently, error: closure expression is unused \n  print($0)\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">다른 trailing closure 케이스와 더 일관되고, 특별한 단점도 없습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">다만 array/dictionary만큼 강력하게 동기부여되지는 않아요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array와 dictionary는 타입 표현식이 literal로 파싱되는 잠재적 모호성 때문에 특별하거든요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>고려된 대안들</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>추가 파싱 휴리스틱</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>같은 줄에서만 허용?</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Source break는 array literal 다음 줄에 result builder closure가 오는 경우입니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array = [\"a\", \"b\", \"c\"]\n    { print(array) }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">같은 줄에 있으면 이미 컴파일되지 않습니다.<br /><br /></span></blockquote>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>@FunctionArrayBuilder\nvar buildFunctions: [() -&gt; Void] {\n    let array1 = [\"a\", \"b\", \"c\"] { // error: cannot convert return expression of type '()' to return type '[String]'\n        print(array)\n    }\n\n    let array2 = [\"a\", \"b\", \"c\"] { // error: variable with getter/setter cannot have an initial value\n        [\"d\"]\n    }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">같은 줄일 때만 trailing closure로 처리하면 source break를 피할 수 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 이건 다른 모든 brace/trailing closure 케이스와 일관성이 없어요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let array = [\"a\", \"b\", \"c\"].map \n{ \n  $0.uppercased()\n}\n\nif array.count &gt;= 3\n{\n  print(\"success: \\(array)\")\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">이런 임의적인 불일치는 코드 포매팅 도구 같은 생태계 전반에 복잡성을 추가합니다.</span></blockquote>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Array 타입만 지원?</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Array/dictionary&nbsp;<b>타입</b>만 지원하고 다른 literal은 제외하는 방법도 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">[String]&nbsp;타입은 valid한 표현식이 아니니까 source compatibility 문제가 없겠죠.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 파싱 시점에는 [String]이 타입인지 literal인지 알 수 없습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>let String = \"a\"\nlet array = [String] // an array literal, [\"a\"]\n{ print(array) }</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">단일 요소 array/dictionary literal이고 단일 identifier를 포함하는 경우만 허용할 수도 있지만, 이러면&nbsp;callAsFunction&nbsp;케이스가 불필요하게 제거됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Conclusion</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">SE-0508은 이미&nbsp;<b>Accepted</b>되었고 구현도 완료된 상태입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">개인적으로는 정말 합리적인 개선이라고 생각해요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">InlineArray에서는 되는데&nbsp;Array에서는 안 된다는 게 말이 안 됐거든요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">@ArrayBuilder&nbsp;같은 result builder와 함께 쓰면 정말 깔끔한 API를 만들 수 있을 것 같습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">작은 변경이지만 언어의 일관성과 표현력을 크게 높여주는 개선이네요  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>References</b></span></h2>\n<figure id=\"og_1771051388731\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"object\" data-og-title=\"swift-evolution/proposals/0508-array-expression-trailing-closures.md at main &middot; swiftlang/swift-evolution\" data-og-description=\"This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution\" data-og-host=\"github.com\" data-og-source-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0508-array-expression-trailing-closures.md\" data-og-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0508-array-expression-trailing-closures.md\" data-og-image=\"https://scrap.kakaocdn.net/dn/bS0M8s/dJMb81fOPWD/c76NIZp9xG0ojyKY2eBNtk/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/efaHyc/dJMb86OX17s/mxgcN5ifXfbwk4u9N9Y4xK/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600\"><a href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0508-array-expression-trailing-closures.md\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0508-array-expression-trailing-closures.md\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/bS0M8s/dJMb81fOPWD/c76NIZp9xG0ojyKY2eBNtk/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/efaHyc/dJMb86OX17s/mxgcN5ifXfbwk4u9N9Y4xK/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">swift-evolution/proposals/0508-array-expression-trailing-closures.md at main &middot; swiftlang/swift-evolution</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution</p>\n<p class=\"og-host\" data-ke-size=\"size16\">github.com</p>\n</div>\n</a></figure>\n<figure id=\"og_1771051390535\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"Support trailing closure syntax for single-argument Array and Dictionary initializers\" data-og-description=\"In the recent discussion about @ArrayBuilder, it came up that trailing closure syntax is not currently supported in the most intuitive way for Array initializers like init(@ArrayBuilder build: () -&gt; [Element]): I investigated this on the parsing side, and \" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900\" data-og-url=\"https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900\" data-og-image=\"https://scrap.kakaocdn.net/dn/dGvRso/dJMb8RjX80E/0o15WTQ5BcEMSwkM8oqcrk/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/bUV400/dJMb8WMlMqJ/Nx7x25m9RFBMMED0ubWtO0/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/dGvRso/dJMb8RjX80E/0o15WTQ5BcEMSwkM8oqcrk/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/bUV400/dJMb8WMlMqJ/Nx7x25m9RFBMMED0ubWtO0/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">Support trailing closure syntax for single-argument Array and Dictionary initializers</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">In the recent discussion about @ArrayBuilder, it came up that trailing closure syntax is not currently supported in the most intuitive way for Array initializers like init(@ArrayBuilder build: () -&gt; [Element]): I investigated this on the parsing side, and</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>\n<figure id=\"og_1771051391760\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"SE-0508: Array expression trailing closures\" data-og-description=\"Hi everyone, The review of SE-0508: Array expression trailing closures begins now and runs through February 12, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would l\" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/se-0508-array-expression-trailing-closures/84479\" data-og-url=\"https://forums.swift.org/t/se-0508-array-expression-trailing-closures/84479\" data-og-image=\"https://scrap.kakaocdn.net/dn/mrO38/dJMb9cBEklL/KSq5U4vhCLOSpsia3zRM90/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/bh9p0b/dJMb9bvYwCl/uSf6zpRxKdTLUowmZ3JME0/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/se-0508-array-expression-trailing-closures/84479\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/se-0508-array-expression-trailing-closures/84479\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/mrO38/dJMb9cBEklL/KSq5U4vhCLOSpsia3zRM90/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/bh9p0b/dJMb9bvYwCl/uSf6zpRxKdTLUowmZ3JME0/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">SE-0508: Array expression trailing closures</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Hi everyone, The review of SE-0508: Array expression trailing closures begins now and runs through February 12, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would l</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>\n<figure id=\"og_1771051392730\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"[Accepted] SE-0508: Array expression trailing closures\" data-og-description=\"Hi all, The review of SE-0508: Array expression trailing closures concluded on February 12, 2026. The language steering group has decided to accept the proposal. Feedback was positive on adding language support for trailing closures after sugared array and\" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/accepted-se-0508-array-expression-trailing-closures/84728\" data-og-url=\"https://forums.swift.org/t/accepted-se-0508-array-expression-trailing-closures/84728\" data-og-image=\"https://scrap.kakaocdn.net/dn/c0FFeY/dJMb9kTZaKi/KsEQq7QczXPkymQBv9cl41/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cF03Ps/dJMb9dHkf7G/rhBtpMJDOLaoZQ4yVBmvc1/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/accepted-se-0508-array-expression-trailing-closures/84728\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/accepted-se-0508-array-expression-trailing-closures/84728\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/c0FFeY/dJMb9kTZaKi/KsEQq7QczXPkymQBv9cl41/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cF03Ps/dJMb9dHkf7G/rhBtpMJDOLaoZQ4yVBmvc1/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">[Accepted] SE-0508: Array expression trailing closures</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Hi all, The review of SE-0508: Array expression trailing closures concluded on February 12, 2026. The language steering group has decided to accept the proposal. Feedback was positive on adding language support for trailing closures after sugared array and</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://green1229.tistory.com/609"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[SE-0507] Borrow and Mutate Accessors",
    "partialText": "<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">안녕하세요.&nbsp;<span style=\"color: #409d00;\"><b>그린</b></span>입니다  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이번 포스팅에서는&nbsp;<span style=\"background-color: #9feec3;\"><b>SE-0507 Borrow and Mutate Accessors</b></span>에 대해 정리해보겠습니다  </span></p>\n<p><figure class=\"imageblock alignCenter\" data-ke-mobileStyle=\"widthOrigin\" data-filename=\"123123213.001.jpeg\" data-origin-width=\"400\" data-origin-height=\"400\"><span data-url=\"https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg\" data-phocus=\"https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg\"><img src=\"https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg\" srcset=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbMNm6h%2FdJMcacosInm%2Fr4LBgOCIpNeSUcG0RWFlt1%2Fimg.jpg\" onerror=\"this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';\" loading=\"lazy\" width=\"400\" height=\"400\" data-filename=\"123123213.001.jpeg\" data-origin-width=\"400\" data-origin-height=\"400\"/></span></figure>\n</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Intro</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift의 property accessor는 계속 발전중입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">기존에는&nbsp;get,&nbsp;set, 그리고 최근 추가된&nbsp;yielding borrow,&nbsp;yielding mutate가 있었는데요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">이번 SE-0507은 새로운&nbsp;borrow와&nbsp;mutate&nbsp;accessor를 제안합니다.</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">얘네들은&nbsp;<b>borrowing semantics</b>를 사용해서 복사 오버헤드 없이 값에 접근할 수 있고, yielding accessor보다 성능이 좋습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">특히 non-copyable 타입을 다루는 collection이나 성능이 중요한 저수준 데이터 구조에 유용할 거예요  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">현재 2026년 2월 9일까지 리뷰가 진행 중이긴한데 현 시점에서 Draft 상태라 계획대로 내일까지 반영될진 지켜봐야 알것 같아요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>왜 필요한가?</b></span></h2>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">기존 accessor들은 각각 한계가 있습니다.</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>문제 1:&nbsp;get은 복사해야 한다</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">get&nbsp;accessor는 값을 복사하거나 새로 생성해서 반환해야 합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">복사의 코스트가 많이 들거나 불가능한 경우엔 쓸 수 없죠.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\"><code>struct NC: ~Copyable { ... }\nstruct ContainerOfNoncopyable {\n    private var _element: NC\n    var element: Element {\n        return _element //   ERROR: Cannot copy `_element`\n    }\n}\n</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Non-copyable 값을 저장하는 collection은 subscript에&nbsp;get을 쓸 수 없습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>문제 2: yielding accessor는 오버헤드가 크다</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">yielding mutate와&nbsp;yielding borrow는 coroutine을 사용합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">접근 전후로 코드를 실행할 수 있어서 유연하지만, 그만큼 오버헤드가 있습니다.</span></p>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Coroutine을 위한 메모리 할당</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">여러 번의 함수 호출</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">접근 scope가 제한됨 (함수가 끝나기 전에 완료되어야 함)</span></li>\n</ul>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\"><code>struct Element: ~Copyable {\n  var span: Span&lt;...&gt; { ... }\n}\n\nstruct Wrapper: ~Copyable {\n    private var _element: Element\n    var element: Element {\n        yielding borrow { // ❗️Note: Using `yielding borrow` accessor\n            yield _element\n        }\n    }\n}\n\nfunc getSpan(wrapper: borrowing Wrapper) -&gt; Span&lt;...&gt; {\n    // Because we're reading `element` from a yielding accessor,\n    // its access must finish before `getSpan` returns.\n    // But `span` cannot outlive `element`, so ...\n\n    //   ERROR: lifetime-dependent value escapes its scope\n    return wrapper.element.span\n}\n</code></pre>\n<p data-ke-size=\"size16\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Borrowing accessor는 이 두 문제를 모두 해결합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>제안된 솔루션</b></span></h2>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">새로운&nbsp;borrow와&nbsp;mutate&nbsp;키워드로 accessor를 정의합니다.</span></blockquote>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct RigidWrapper&lt;Element: ~Copyable&gt;: ~Copyable {\n    var _element: Element\n    var element: Element {\n        borrow {\n            return _element\n        }\n        mutate {\n            return &amp;_element\n        }\n    }\n}</code></pre>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow: 읽기 전용 접근, 복사하지 않음</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">mutate: 읽기/쓰기 접근,&nbsp;&amp;로 mutable reference 반환</span></li>\n</ul>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">yield&nbsp;대신&nbsp;return을 쓰는 게 차이점입니다.</span></p>\n<p data-ke-size=\"size16\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">물론 single expression이면&nbsp;return&nbsp;키워드는 생략 가능합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>상세 설계</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>반환 값의 제약</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Borrowing accessor는&nbsp;<b>저장된 값</b>만 반환할 수 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">local이나 temporary 값은 반환할 수 없어요.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct InvalidExamples {\n    var _array : [Int]\n    \n    var local: [Int] {\n        borrow {\n            let foo = [1, 2, 3]\n            //   ERROR: Cannot return local value from borrow accessor\n            return foo\n        }\n    }\n    \n    var temporary: [Int]? {\n        borrow {\n            // This would require creating a temporary local\n            // optional array from `_array`.\n            //   ERROR: Cannot return temporary value from borrow accessor\n            return _array\n        }\n    }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">반환하는 값은 accessor 실행이 끝난 후에도 유효해야 합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>사용 방법</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>borrow로 읽기</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">클라이언트 코드는 기존&nbsp;get과 동일하게 보이지만, 내부적으로는 복사가 일어나지 않습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var owner = Wrapper(value)\n\n// \"borrow\" the value to give to a function\n// without copying...\ndoSomething(with: owner.element)\n\nfunc doSomething(with value: borrowing Element) {\n    // `value` is borrowed, so this invokes\n    // the method \"in-place\"\n    value.someMethod() \n\n    // Exclusivity prevents the owner from being\n    // mutated while `value` is alive:\n    owner.mutatingMethod() //   ERROR\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">메모리 일관성을 위해 Swift의 exclusivity rule이 적용됩니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow가 활성화된 동안엔 owner를 변경할 수 없어요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>mutate로 수정하기</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">mutate&nbsp;accessor는 읽기/쓰기 접근을 제공합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var owner = Wrapper(value)\n\n// Mutating/inout access will invoke the `mutate` accessor\ndoSomething(with: &amp;owner.element)\n\nfunc doSomeMutation(with value: inout Element) {\n    // So this invokes a method on the value \"in-place\"\n    // Because you borrowed for mutation, this can be\n    // a mutating method.\n    value.someMutatingMethod()\n\n    // Accessing the owner is an exclusivity violation\n    owner.anyMethod() //   ERROR\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>다른 accessor와의 호환성</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>mutate를 제공하면</b></span></p>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow도 반드시 제공해야 함</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">yielding mutate나&nbsp;yielding borrow는 사용 불가</span></li>\n</ul>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift는 일반적으로 write-only property를 허용하지 않습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">또한 읽기와 쓰기 작업의 접근 scope를 일관되게 유지해야 합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>borrow를 제공하면</b></span></p>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">get이나&nbsp;yielding borrow는 사용 불가</span></li>\n</ul>\n<blockquote data-ke-style=\"style1\"><span style=\"font-family: 'Noto Serif KR';\">여러 read accessor나 여러 write accessor를 동시에 정의하면 호출자 입장에서 혼란스럽기 때문입니다.</span></blockquote>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Ownership 변형</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">기본적으로 아래와 같아요.</span></p>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow: 포함하는 값을 변경하지 않음</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">mutate: 포함하는 값을 변경함</span></li>\n</ul>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이걸&nbsp;mutating이나&nbsp;nonmutating&nbsp;키워드로 오버라이드할 수 있습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>mutating borrow</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">읽기 전용이지만 side-effect로 인해 포함하는 값이 변경될 수 있는 경우입니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct S1 {\n  private var cachedValue: Foo\n  var foo : Foo {\n    mutating borrow {\n      if !cachedValue.available {\n        // Update `cachedValue`\n        // Compiler allows such update\n        // because this is `mutating`\n      }\n      return cachedValue\n    }\n  }\n}\n\nlet s1: S1 // Note: Immutable value\ns1.foo //   Cannot use mutating accessor on immutable value</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">캐시를 업데이트하는 경우 같은 거죠.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>nonmutating mutate</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">값을 변경할 수 있지만 부모 값의 변경으로 간주되지 않는 경우입니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct Outer {\n  var inner: InnerType {\n    borrow {\n      return some_value_stored_elsewhere\n    }\n    nonmutating mutate {\n      return &amp;some_value_stored_elsewhere\n    }\n  }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">외부에 저장된 값에 접근하는 경우 같은 거예요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Protocol requirement로 사용</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Protocol에서도 borrowing accessor를 요구할 수 있습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\"><code>protocol BorrowingAccess {\n  associatedtype Element\n  var element: Element { borrow mutate }\n}\n</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이는 두 가지 기능이 있어요.</span></p>\n<ol style=\"list-style-type: decimal; color: #000000; text-align: start;\" data-ke-list-type=\"decimal\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Protocol을 통한 접근 방식을 제어 (existential이나 generic argument에서)</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">conforming 타입에 해당 accessor가 있어야 함 (명시적 구현 또는 컴파일러 합성)</span></li>\n</ol>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>컴파일러 합성</b></span></h2>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Stored property &rarr;&nbsp;borrow,&nbsp;mutate&nbsp;합성 가능</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">borrow&nbsp;구현 &rarr;&nbsp;yielding borrow나&nbsp;get&nbsp;합성 가능 (copyable만)</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">mutate&nbsp;구현 &rarr;&nbsp;set이나&nbsp;yielding mutate&nbsp;합성 가능</span></li>\n</ul>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>제약사항</b></span></h2>\n<ul style=\"list-style-type: disc; color: #000000; text-align: start;\" data-ke-list-type=\"disc\">\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Protocol이&nbsp;borrow&nbsp;요구 &rarr; conforming 타입도&nbsp;borrow&nbsp;필요</span></li>\n<li><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Protocol이&nbsp;mutate&nbsp;요구 &rarr; conforming 타입은&nbsp;borrow와&nbsp;mutate&nbsp;모두 필요</span></li>\n</ul>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Class와 Actor에서는 불가</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Class는 property 접근 전후로 runtime exclusivity check를 실행해야 합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><b><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Borrowing accessor는 접근 후에 코드를 실행할 방법이 없어서 class property에는 사용할 수 없습니다.</span></b></p>\n<p data-ke-size=\"size16\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">yielding borrow와&nbsp;yielding mutate는 class property에 사용 가능합니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Subscript에도 사용 가능</b></span></h3>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct ArrayLikeType {\n  subscript(index: Int) -&gt; Element {\n    borrow { .... }\n    mutate { .... }\n  }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">다만 subscript는 전체 struct를 암묵적으로 접근하므로, 아래 코드는 불가능해요.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var x: ArrayLikeType\nswap(&amp;x[0], &amp;x[1]) //   두 개의 mutating access</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>호환성</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Source compatibility</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">기존에&nbsp;borrow나&nbsp;mutate라는 이름의 함수를 trailing closure로 호출하는 경우와 충돌 가능성이 있습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\"><code>struct S {\n  func borrow(closure: () -&gt; ()) { ... }\n  // Is this a new borrow accessor?\n  // Or a call to the borrow method just above?\n  var property: Int { borrow { ... } }\n}\n</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 실제로는 거의 발생하지 않을 것으로 봅니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>ABI compatibility</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">새로운 기능이라 기존 ABI에는 영향이 없습니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Adoption 영향</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Non-borrowing accessor를 borrowing accessor로 바꾸는 건 일반적으로&nbsp;<b>ABI-breaking</b>입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">하지만 existential type의 ABI는 보존됩니다. (컴파일러가 계속 accessor를 합성할 수 있다면)</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Source-breaking일 수도 있습니다. 특히&nbsp;get을&nbsp;borrow로 바꾸면 lifetime 제약이 생겨서 기존 코드가 컴파일되지 않을 수 있어요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>향후 방향성</b></span></h2>\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Borrowing returns</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">함수에서도 borrowed 값을 반환할 수 있으면 유용합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>struct S&lt;Value&gt; {\n  subscript(_ index: Int) -&gt; Value {\n     borrow { ... }\n  }\n  func indirect(_ parameter: Foo) -&gt; borrowing Value {\n     let index = ... compute index from parameter ...\n     return self[index]\n  }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style6\" />\n<h3 style=\"color: #000000; text-align: start;\" data-ke-size=\"size23\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Unsafe pointer를 통한 borrowing</b></span></h3>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">저수준 데이터 구조는 종종 unsafe pointer를 사용합니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var _storage: UnsafePointer&lt;Element&gt;\n\nvar first: Element {\n  borrow {\n    // ERROR: borrow accessors can only return stored properties\n    // or computed properties that have borrow accessors\n    return _storage.pointee\n  }\n}</code></pre>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">이런 케이스를 지원하려면 뭔가 annotation이 필요할 것 같습니다.</span></p>\n<pre class=\"swift\" style=\"color: #000000; text-align: start;\" data-ke-language=\"swift\"><code>var first: Element {\n  borrow {\n    return unsafeResultDependsOnSelf(_storage.pointee)\n  }\n}</code></pre>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<p data-ke-size=\"size16\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>나왔던 대안</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>아무것도 하지 않기?</b></span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Yielding coroutine-based accessor도 비슷한 기능을 제공하지만, 성능 특성이 다릅니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Coroutine accessor는 접근 후에 코드를 실행할 수 있어서 의미론적으로는 더 강력하지만, 완전히 inline되지 않으면 여러 함수 호출 오버헤드가 있습니다.</span></p>\n<p data-ke-size=\"size16\"><b><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Borrowing accessor는 여러 함수 호출 오버헤드 없이 in-place mutation 기능을 제공합니다.</span></b></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>Conclusion</b></span></h2>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">특히나 유용한 제안이라고 생각되는 포인트는 non-copyable 타입을 다루는 collection이나 성능이 중요한 저수준 코드에서 큰 도움이 될 것 같아요.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">get의 복사 오버헤드와 yielding accessor의 coroutine 오버헤드 사이의 sweet spot을 찾은 느낌입니다.</span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\">Swift Standard Library 팀에서도 이 기능을 원했다고 하니, 실무에서 정말 필요한 기능인 것 같네요  </span></p>\n<p style=\"color: #000000; text-align: start;\" data-ke-size=\"size18\">&nbsp;</p>\n<hr contenteditable=\"false\" data-ke-type=\"horizontalRule\" data-ke-style=\"style5\" />\n<h2 style=\"color: #000000; text-align: start;\" data-ke-size=\"size26\"><span style=\"font-family: 'Nanum Gothic'; color: #000000;\"><b>References</b></span></h2>\n<figure id=\"og_1770505989159\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"object\" data-og-title=\"swift-evolution/proposals/0507-borrow-accessors.md at main &middot; swiftlang/swift-evolution\" data-og-description=\"This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution\" data-og-host=\"github.com\" data-og-source-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md\" data-og-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md\" data-og-image=\"https://scrap.kakaocdn.net/dn/ctPukB/dJMb9dHjFxz/rPnfoqlUZ4qumwRqATtnpk/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/bdORDD/dJMb9fZqV5N/AkOXRj8eXvJSDwE9R37zz0/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600\"><a href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/ctPukB/dJMb9dHjFxz/rPnfoqlUZ4qumwRqATtnpk/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/bdORDD/dJMb9fZqV5N/AkOXRj8eXvJSDwE9R37zz0/img.png?width=1200&amp;height=600&amp;face=0_0_1200_600');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">swift-evolution/proposals/0507-borrow-accessors.md at main &middot; swiftlang/swift-evolution</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution</p>\n<p class=\"og-host\" data-ke-size=\"size16\">github.com</p>\n</div>\n</a></figure>\n<figure id=\"og_1770505992248\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"[Pitch] Borrowing Accessors\" data-og-description=\"I just put up the draft proposal for Borrowing Accessors, which together with Yielding Accessors completes the full suite of accessor support described in the Prospective Vision for Accessors. More complete details are in the draft proposal. The following \" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/pitch-borrowing-accessors/83933\" data-og-url=\"https://forums.swift.org/t/pitch-borrowing-accessors/83933\" data-og-image=\"https://scrap.kakaocdn.net/dn/bmTS6N/dJMb86nTaz5/thh0HrQh32roiksV5DQfb1/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/INQ8e/dJMb8TB5b1Y/vKaE9NKcC5Hx35h96ojMJk/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/pitch-borrowing-accessors/83933\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/pitch-borrowing-accessors/83933\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/bmTS6N/dJMb86nTaz5/thh0HrQh32roiksV5DQfb1/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/INQ8e/dJMb8TB5b1Y/vKaE9NKcC5Hx35h96ojMJk/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">[Pitch] Borrowing Accessors</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">I just put up the draft proposal for Borrowing Accessors, which together with Yielding Accessors completes the full suite of accessor support described in the Prospective Vision for Accessors. More complete details are in the draft proposal. The following</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>\n<figure id=\"og_1770505992871\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"SE-0507: Borrow and Mutate Accessors\" data-og-description=\"Hi everyone, The review of SE-0507 &quot;Borrow and Mutate Accessors&quot; begins now and runs through February 9, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would like to \" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376\" data-og-url=\"https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376\" data-og-image=\"https://scrap.kakaocdn.net/dn/ArLsY/dJMb9jgsO0V/MaREBk3jT8n59WyTYrLSaK/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/Vkdgg/dJMb9iICK3v/lMt6Y2eKRhuCzg7lQKTBMK/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/ArLsY/dJMb9jgsO0V/MaREBk3jT8n59WyTYrLSaK/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/Vkdgg/dJMb9iICK3v/lMt6Y2eKRhuCzg7lQKTBMK/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">SE-0507: Borrow and Mutate Accessors</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Hi everyone, The review of SE-0507 \"Borrow and Mutate Accessors\" begins now and runs through February 9, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would like to</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>\n<figure id=\"og_1770505993582\" contenteditable=\"false\" data-ke-type=\"opengraph\" data-ke-align=\"alignCenter\" data-og-type=\"website\" data-og-title=\"[Prospective Vision] Accessors\" data-og-description=\"Hello, Swift Community. The Language Steering Group would like to gather feedback on a prospective vision for accessors in Swift. Vision documents help describe an overall direction for Swift. The actual Swift changes for executing on the vision will come \" data-og-host=\"forums.swift.org\" data-og-source-url=\"https://forums.swift.org/t/prospective-vision-accessors/76707\" data-og-url=\"https://forums.swift.org/t/prospective-vision-accessors/76707\" data-og-image=\"https://scrap.kakaocdn.net/dn/Uj5X6/dJMb9iICK3w/nC3pXJNA1Q0nU5Y6KbMHwk/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cTf3MU/dJMb9jgsO0W/66gUNcaH9jsd7hOeewxwp0/img.png?width=151&amp;height=150&amp;face=0_0_151_150\"><a href=\"https://forums.swift.org/t/prospective-vision-accessors/76707\" target=\"_blank\" rel=\"noopener\" data-source-url=\"https://forums.swift.org/t/prospective-vision-accessors/76707\">\n<div class=\"og-image\" style=\"background-image: url('https://scrap.kakaocdn.net/dn/Uj5X6/dJMb9iICK3w/nC3pXJNA1Q0nU5Y6KbMHwk/img.png?width=590&amp;height=585&amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cTf3MU/dJMb9jgsO0W/66gUNcaH9jsd7hOeewxwp0/img.png?width=151&amp;height=150&amp;face=0_0_151_150');\">&nbsp;</div>\n<div class=\"og-text\">\n<p class=\"og-title\" data-ke-size=\"size16\">[Prospective Vision] Accessors</p>\n<p class=\"og-desc\" data-ke-size=\"size16\">Hello, Swift Community. The Language Steering Group would like to gather feedback on a prospective vision for accessors in Swift. Vision documents help describe an overall direction for Swift. The actual Swift changes for executing on the vision will come</p>\n<p class=\"og-host\" data-ke-size=\"size16\">forums.swift.org</p>\n</div>\n</a></figure>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://green1229.tistory.com/608"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "언론사 망하게 하는 AI 봇 개발기",
    "partialText": "<p>코딩 대신해주는 AI 등장 이후 개발자들은 다 굶어 죽을거라는 둥, 직원을 다 잘라도 사장 혼자 사업을 해도 된다는 둥 하는 FOMO(놓치는 것에 대한 두려움) 기사가 워낙 흥하다 보니 나도 FOMO 스러운 제목을 적어보았다. ‘언론사 망하게 하는 AI 봇’ 을 만들었다고.</p>\n\n<p>반은 뻥이다. 그리고 반은 진담이다.</p>\n\n<hr />\n\n<p>2026년 2월 9일, 음성인식 AI모델이 오픈소스로 풀렸다는 소식을 들었다. 사람 말귀를 알아 듣는 스마트 스피커를 나도 쉽게 만들 수 있겠구나 라고 생각했다. 명령어 한 줄 만으로도 데모가 실행되었는데, 꽤 그럴싸하게 한국어와 일본어, 영어 발음을 인식했다. 다음날, MacOS에 내장된 음성인식 엔진을 가져다 써도 쓸만하다는 평을 들었다. 성능이 어느 정도인지 궁금해서 Claude AI에게 이 엔진으로 음성을 인식해 프린트하는 프로그램을 만들어달라고 했다. AI 모델이 아니어도 꽤 그럴싸하게 한국어를 인식하는 것을 확인했다. 로컬에서도 돌아가는 이 엔진을 쓰면 비용도 덜 들고 속도도 빠르겠구나…라고 생각했다. 그렇게, 간단히 ‘지금 몇시야?’ 같은 질문에 TTS로 대답을 하는 코드를 덧붙였다. 나와 목소리로 대화할 수 있는 대화 봇을 만든 것이다.</p>\n\n<p>그 때, Claude AI에게 한가지 프롬프트를 더 얹었다.</p>\n\n<p>“오늘의 뉴스를 물어보면 오늘의 뉴스를 요약해서 읽어줘.”</p>\n\n<p>30여초 뒤, 수십여개의 신문사와 방송사를 사라지게 할 수 있는 봇이 탄생했다.</p>\n\n<h1 id=\"일단-구경하시라\">일단 구경하시라</h1>\n\n<p>이 글은 인터넷에 올라온 하이퍼미디어 글이다. 글을 읽다가 동영상을 볼 수도 있다는 의미이다. 일단 봇의 작동장면을 5분간 시청해보자.</p>\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/38ewaWdLZKk?si=de-i6wt9SXbYz50T\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"></iframe>\n\n<p>요약된 뉴스는 4~5분 가량이고, 이정도면 지상파 방송 라디오 정시 뉴스 길이와 비슷하다. 문장이 매끄럽지 못한 부분은 몇 달 지나면 개선될 것이고, 중요 뉴스는 충분히 설명하기 때문에 이미 원하는 기능은 모두 구현되었다고 판단되었다. 라디오 정시 뉴스와 품질도 비슷하다.</p>\n\n<p>음성인식은 MacOS 에서 기본적으로 제공하는 <a href=\"https://developer.apple.com/documentation/speech/sfspeechrecognizer\">SFSpeechRecognizer</a> 프레임워크를 이용했다. 루프를 돌면서 마이크로 들어오는 사람의 목소리를 인식하는 프레임워크이다. ‘오늘의 뉴스’ 라고 외치는 것은 다음 작동을 위한 트리거에 불과하다. 원래 파이썬에서 만들기 쉬웠던 프레임워크이고, AI에게 시켜서 만들기도 쉽다. 이 프레임워크의 존재는 이 글의 주제는 아니다.</p>\n\n<p>스피커로 대답을 하기 위해 쓰는 TTS 역시 MacOS 에서 기본적으로 제공한다. 터미널에 <code class=\"language-plaintext highlighter-rouge\">say -v Yuna \"안녕하세요\"</code> 라고 치면 안녕하세요 라는 목소리가 스피커에서 흘러나올 것이다. 이 목소리보다 마이크로소프트의 MS Edge TTS가 더 자연스러워서 이걸 쓰기로 했다. 파이썬에는 이미 <a href=\"https://pypi.org/project/edge-tts/\">Edge TTS</a> 패키지가 존재한다. 쉽게 가져다 쓸 수 있다는 이야기이다. 이 패키지도 이 글의 주제는 아니다.</p>\n\n<p>‘오늘의 뉴스’라는 음성이 트리거링되었을 때, 파이썬 코드는 <a href=\"https://news.google.com/rss?hl=ko&amp;gl=KR&amp;ceid=KR:ko\">구글 뉴스 RSS</a>에서 최신 뉴스를 가져온다. <a href=\"https://ko.wikipedia.org/wiki/RSS\">RSS</a>는 Really Simple Syndication의 약자. 20여년 전부터 쓰여온 콘텐츠 전달 포맷이다. 각 언론사도 자사 사이트에서 RSS를 제공한다. 그리고 구글 뉴스는 전 세계의 언론사로부터 뉴스를 공급받아 목록을 제공한다. 그래서 Claude AI는 특별히 어떤 언론사를 지목하지 않고 구글 뉴스를 쓰기로 결정했던 모양이다. 이것도 개발일을 해온 입장에선 어렵지 않은 일이다.</p>\n\n<p>기사 요약은 언론사 사이트를 읽은 뒤 Gemini 에게 내용을 요약해달라고 시켰다. AI학습 금지 조항을 달아둔 언론사들도 있지만 기계적인 차단장치를 걸어둔 곳은 국내에는 그리 많지 않았다. 반면 해외 매체는 프로그래밍적 접근이 문제가 아니라 아예 페이월(Paywall - 돈을 내야 볼 수 있는 잠금화면)이 걸려있다.</p>\n\n<p>구글 뉴스는 알고리즘을 통해 중요 뉴스를 배치한다. 여기서 언론사 크레딧은 그다지 중요하지 않다. 기사 주인이 조선일보든 한겨레든 MBN이든 KBS든 알 바 아니다.\n거의 모든 언론사들이 같은 주제로 기사를 써내려가고 있고, 비슷비슷한 기사는 그 아젠다의 중요성에 가중치를 부여하는 역할로만 알고리즘에서 기여한다.\n각 뉴스의 제호는 프롬프트에서 <code class=\"language-plaintext highlighter-rouge\">언론사 이름은 읽지는 마</code> 라는 한 문장으로 쉽게 제거된다.\n그리고, 아무리 자세하게 기자가 글에 살을 붙였다 한들, <code class=\"language-plaintext highlighter-rouge\">4~6문장으로 요약해</code> 라는 프롬프트만으로 기자가 정성스레 덧붙인 코멘트는 소거된다.</p>\n\n<p>군더더기 버그를 고쳐달라는 프롬프트를 제외하면, <code class=\"language-plaintext highlighter-rouge\">말 귀를 알아듣는 음성인식 봇을 만들어줘</code> 그리고 <code class=\"language-plaintext highlighter-rouge\">오늘의 뉴스를 물어보면 오늘의 뉴스를 요약해서 읽어줘</code> 두 가지만 Claude AI에게 물어보았더니 4~5분 가량의 개인용 실시간 오디오 뉴스가 탄생했다.</p>\n\n<p>상품화를 못할거라고? 요즘 알리익스프레스는 설명서를 포함한 오픈소스 키트를 묶어 판다. 3D프린터로 조립된 케이스 안에 부품을 조립해 넣고 USB 로 소프트웨어를 주입하면 알아서 돌아가는 식이다.</p>\n\n<h1 id=\"꼴-좋다고-비웃던-사이에\">꼴 좋다고 비웃던 사이에</h1>\n\n<p>자 이제, 방송사 뉴스는 뭐하러 듣고, 신문사 기사는 뭐하러 봐야하는가?</p>\n\n<p>뉴스에 관점을 붙여온 기자는 이제 어디로 가야하는가? LLM이 문장을 대신 쓰고 있다.</p>\n\n<p>뉴스를 고르는 데스크는 이제 어디로 가야하는가? 알고리즘이 데스킹을 대신하고 있다.</p>\n\n<p>뉴스를 읽는 아나운서는 이제 어디로 가야하는가? TTS가 뉴스를 대신 읽고 있다.</p>\n\n<p>뉴스를 틀어주는 방송사는 어디로 가야하는가? 인터넷이 알아서 뉴스를 배달하고 있다.</p>\n\n<p>뉴스를 만드는 언론사는 어디로 가야하는가? AI가 알아서…</p>\n\n<p><a href=\"https://rainygirl.github.io/2018/04/macro-program-ask-you\">프로그래밍된 동작이 인간의 동작을 대체하고 있다고 2018년 칼럼에 썼었다</a>. 누군가의 일자리를 빼앗지 못하면 혁신이 아니라는 구호가 스타트업 업계에 팽배하던 시절도 지나갔다. AI 등장 이후 진짜로 여기저기 일자리를 빼앗을 수 있다는 곡소리가 나온다. 하필 ‘고액 연봉 개발자들 이제 쪽박 찬다’는 FOMO 기사를 수많은 언론들이 쏟아냈다. 그런데 이번에는 그 언론사들도 존립이 위태로운 형국이다. AI가 뉴스를 대신 요약하면서 언론사 사이트 방문자수가 급감했다는 소식이 심심치 않게 들려온다.</p>\n\n<p>꼴 좋다고 비웃는 사람들이 있었다. 언론사가 언론사답지 못하다는 힐난이야 50여년 전부터 내려온 것이긴 하다. 황색저널리즘 이야기도 있었다. 30여년 전 쯤부터 지하철역 입구에 무가지가 배치되면서 신문 안 읽는 세상이라고 혀를 차는 이들도 있었다. 그러다 20여년 전부터 포털 사이트를 통해 조각조각난 뉴스를 보는 사람들이 전체 뉴스 소비자의 대부분이 되어버렸다. 방송 뉴스도 45분 가까이 되는 뉴스편성이 포털에서 3분 단위로 조각조각나고 스탠딩 멘트는 스크립트로 따여져 텍스트로 재가공되었다. 제호 아래의 1면 배치로 권력을 휘두르던 신문 권력과 메인 뉴스 첫꼭지 배치로 권력을 휘두르던 방송 권력이 물러갔다며 좋아하는 사람들도 있었다. 레거시 미디어라는 용어가 한국어로 ‘재래식 언론’으로 바뀌더니 언제부터인가 조롱의 언어로 쓰이고 있다.</p>\n\n<p>솔직히 AI 앞에서 남 밥그릇 사라지는 일에 즐거워하던 기사들을 떠올리면 나도 니들 꼴 좋다고 비아냥거리고 싶은 마음이 아른거리긴 한다. 하지만, 정말 꼴 좋다고 비웃어도 될 일인가? 빈 자리는 저마다 내편을 찾는 유투버들이 새로운 언론인을 자처하며 저마다의 부족을 만들어냈다. <a href=\"https://www.youtube.com/watch?v=7GPZhCEgWjY\">일론 머스크는 공영방송이 쓰레기라며 NPR의 예산을 끊으라 했고, 트럼프 정부는 정말로 예산을 끊어 PBS와 NPR을 문닫게 했다.</a> 그 결과 <a href=\"https://www.wired.com/story/turning-point-usas-halftime-show-was-exactly-what-youd-expect/\">2026년 슈퍼볼 하프타임 공연은 두 쪽이 났다.</a> 남의 나라 이야기인가? 한국도 “우리는 유튜브만 믿어! 유튜브가 진실이야!”가 구호로 등장한다.</p>\n\n<p><img src=\"/images/2026-02-10-youtube.png\" alt=\"\" /></p>\n\n<p>그래서 그 결과는 어떠한가? 릴스 쇼츠는 극우선전에 잠식되었고, 좌파 부모에게서 우파 청년이 탄생했다고 어디서는 폭죽을 터트린다. 그렇게 대화가 단절되고, 나의 일상에서 안전이 위협을 받기 시작한다. 꼴 좋다고 비웃고 넘어간 댓가는 아닌지?</p>\n\n<h1 id=\"저널리즘-그-너머에\">저널리즘 그 너머에</h1>\n\n<p>사회의 합의를 이끌어내는 공론장은 민주주의 사회에서 언제나 필요하고, 공공의 아젠다가 공유되지 않는다면 분리주의가 팽배해진다. 선전매체가 아닌 ‘언론’은 그래서 필요하다. 특히나 공영 언론은 민주주의 유지를 위한 세금에 가깝다.</p>\n\n<p>AI가 만들어내는 요약은 요약 텍스트일 뿐 진실을 담고 있지 않다. 가짜뉴스가 양적으로 팽창할수록, <a href=\"https://rainygirl.github.io/2018/05/alternative-facts\">대안팩트가 팽배한 시대일수록</a>, 우리에게는 진짜 ‘진실’이 더욱 절실해질 것이다.</p>\n\n<p>LLM이 품고 있는 본질적인 구조때문에, LLM은 자신이 만들어낸 문장의 ‘진실성’을 보증할 길이 없다. 그럴 수록 우리에게는 진실의 ‘신뢰할 만한 보증인’이 필요하다. 언론의 제호, 콜싸인은 이제 그 보증인의 역할을 해야 한다.</p>\n\n<p>알고리즘은 공공의 영역이 아니고 공적 지배구조를 가지고 있지 않다. 필요에 따라선 누군가의 욕망을 담아 편향되게 운영될 수도 있는 것이 알고리즘이다. (<a href=\"https://rainygirl.github.io/2015/10/the-desire-to-dominate-the-internet\">포털 장악의 욕망을 다시 읽어보시라</a>) 그냥 하는 이야기가 아니라 <a href=\"https://www.joongang.co.kr/article/25402481\">플랫폼을 차지한 뒤 타국 선거에 개입했다는 공식 발표를 내놓는 정부 수사기관도 있었다</a>. 그러니, 어딘가에는 공적 지배구조를 가지거나 공적 영역에 발을 담근 사명을 가진 이들이 알고리즘을 감시할 수 있어야 한다. 저널리즘은 알고리즘과 AI시대에 알고리즘을 감시하는 역할을 해야 한다.</p>\n\n<p>수제 코딩에 대해 비웃는 사람들이 많다. 하지만 LLM이 만들어낸 코드를 많은 개발자들이 직접 검수를 한다. 회사 사장님이 확 가버린 사람이 아닌 한, 보안 문제를 챙기기 위해서라도 사람이 검수를 해야하고, 한심하게 비용이 늘어나게끔 설계하지 않았는지 최종 검수하는 역할은 결국 인간이 해야 한다. 그렇다면 ‘자기 이름을 걸고’ 기사를 쓰는 기자들 역시 자기 기사에는 그 정도 가치를 걸고 보도를 해야 가치가 입증되지 않을까? 받아쓰는 기사가 아니라 자기 이름을 걸 만한 기사를 만들어내야 한다는 이야기다. 이제는 그런 기사만이 AI의 쓰레기더미로부터 살아남아 빛을 볼 것이다.</p>\n\n<p>프롬프트 몇개면 뉴스는 쉽게 확보된다. 그러면 누가 언론사 사이트를 방문하겠는가? 이제는 사람이 아니라 파이썬 코드가 기사를 읽고, AI가 기사를 읽는다. 광고를 봐줄 사람이 사라지는데, 그러면 언론사는 무엇으로 자생력을 갖추어야 하는가?</p>\n\n<p>프롬프트를 조금만 고친다면 내가 관심있어하는 언론사의 기사만 읽거나, 특정 주제의 기사만 요악해서 들려주는 봇을 만드는 것도 가능할 것이다. 뉴스의 소비가 더욱 파편화되고 개인화되며 맥락이 소거되는 시대에 대한 전망은 포털을 통한 뉴스공급이 시작될 즈음부터 예견되었던 것이다. 그 미래가 예정대로 찾아왔을 뿐이다. 클릭바이트에 매몰되었던 지난 몇십여 년의 관성에서 다시 벗어나, 본래의 존립 근거를 물어야 한다. 언론이 왜 필요한지, 민주주의 사회에서 언론은 어떤 역할을 해야하는지 처음부터 물어봐야할 때가 되었다. 그리고 새로이 바뀐 생태계에 맞게 생존 방식을 바꾸어야 한다.</p>\n\n<p>굳이 이런 시대에도 언론사의 콘텐츠를 일부러 찾고, 신문을 읽고 방송을 찾는 이유를 다시 만들어내야 한다. 그것이 무엇인지는 실은 언론인들도 다 알고 있을 것이다. 모르겠다면 다시 옛 책을 펼쳐 볼 때이다.</p>\n\n<h1 id=\"소스코드-공개\">소스코드 공개</h1>\n\n<p>사람 말을 알아듣고 뉴스를 요약해 들려주는 봇의 코드는\n<a href=\"https://github.com/rainygirl/rspeaker\">https://github.com/rainygirl/rspeaker</a>\n에서 누구나 다운받아 체험해볼 수 있다.</p>\n\n<blockquote>\n  <p><img src=\"/images/2026-02-10-terminal.png\" alt=\"\" />\nmake run 만 하면 작동한다</p>\n</blockquote>\n\n<p>MIT 라이센스이다. 어차피 내가 수제로 만든 코드도 아니다. 누구나 고쳐 쓸 수 있지만 각 코드의 책임은 고쳐쓰는 각자에게 있다.</p>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://rainygirl.github.io/2026/02/rspeaker"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "AI, 그리고 제품",
    "partialText": "AI가 만들어준 잉여시간 덕분에 기존 제품을 더 잘 만들거나, 뾰족한 페르소나를 공략하거나, 새로운 기술 기반 제품을 만드는 것이 가능해졌다. 프론트엔드 엔지니어는 이 시간을 활용해 사용자 경험의 상방을 뚫는 혁신의 주체가 될 수 있다.",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://jbee.io/articles/essay/AI, 그리고 제품"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "무료 TTS 서비스 추천. 클로바 vs Azure",
    "partialText": "<h2>Intro</h2>\n<p>아이를 위한 어린이용 단어장을 만들면서 한국어와 영어 음성을 넣어야 할 일이 생겼다. 무료이거나 비용이 거의 들지 않으면서, 라이선스 문제 없이 상업적으로도 사용 가능한 TTS 서비스가 필요했다. 여러 서비스를 직접 비교해본 끝에 결론부터 말하면 Microsoft Azure Text-to-Speech를 선택했다.</p>\n<h2>비교해본 서비스들</h2>\n<p>TTS 서비스를 고를 때 가장 중요하게 본 기준은 세 가지였다. 음성 품질, 무료 사용량, 그리고 라이선스.</p>\n<h3>네이버 클로바더빙</h3>\n<p>한국어 음성 품질만 놓고 보면 클로바더빙이 꽤 괜찮았다. 자연스러운 한국어 발음과 다양한 목소리를 제공하고 있어서 첫인상은 좋았다. 다만 무료 사용 시 반드시 출처를 표기해야 하고, 상업 콘텐츠 제작에는 사용할 수 없다는 제약이 있다. 당장 수익화 계획이 없다고 해도 라이선스 제약이 있는 서비스를 선택하는 부담스러운 일이다.</p>\n<blockquote data-ke-style=\"style1\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>※ 무료 서비스는 콘텐츠로 인한 수익이 발생하지 않는 채널 게시 용도로만 사용할 수 있습니다.</p>\n<p><a href=\"https://help.naver.com/service/23823/contents/12463?lang=ko&amp;osType=COMMONOS\">무료 사용 허용 범위 안내</a></p>\n</span></p></blockquote><h3>Google Cloud TTS</h3>\n<p>Google Cloud TTS는 무료 제공량이 넉넉한 편이다. 월 100만 자(Neural/WaveNet)까지 무료로 사용할 수 있다. 반면 셋업 과정이 불필요하게 복잡했다. 프로젝트 생성, 서비스 계정 설정, 인증 키 파일 관리 등 실제로 API를 호출하기까지 거쳐야 할 단계가 많다. 하다보니 너무 불편했다.</p>\n<h3>Azure Text-to-Speech</h3>\n<p>Azure는 셋업도 간결하고 무료 티어 설정도 명확했다. 리소스를 생성할 때 가격 계층에서 <code>Free F0</code>를 선택하면 그걸로 끝이다. 과금에 대한 걱정을 할 필요가 전혀 없다. 월 50만 자까지 무료로 제공되는데, 단어장 수천 개를 처리하기에 충분한 양이다. 음성 품질도 좋고, 특히 어린이 목소리 옵션이 만족스러웠다.</p>\n<h2>Azure TTS 시작하기</h2>\n<h3>리소스 생성</h3>\n<p><a href=\"https://portal.azure.com/\">Azure Portal</a>에 접속해서 상단 검색창에 <code>Speech</code>를 입력한 뒤 Speech Services를 선택한다. 리소스를 만들 때 중요한 것은 가격 계층에서 반드시 <strong>Free F0</strong>를 선택하는 것이다. 이렇게 하면 유료 전환 없이 무료 범위 안에서만 사용하게 된다.</p>\n<p>리소스가 생성되면 왼쪽 메뉴에서 <code>Keys and Endpoint</code>로 들어가면 API 키 두 개와 엔드포인트가 이미 만들어져 있다. 별도로 키를 생성하거나 서비스 계정을 설정할 필요 없이 바로 사용할 수 있다.</p>\n<h3>Speech Studio에서 테스트</h3>\n<p>코딩 없이 음성을 확인해보고 싶다면 <a href=\"https://speech.microsoft.com/\">Speech Studio</a>에 접속하면 된다. Audio Content Creation 메뉴에서 언어와 보이스를 선택하고 텍스트를 입력하면 바로 들어볼 수 있다. MP3 파일로 내보내기도 가능하다.</p>\n<h3>추천 보이스</h3>\n<p>어린이용 콘텐츠에 적합한 보이스를 찾느라 여러 가지를 들어봤는데, 최종적으로 선택한 것은 다음 두 가지다.</p>\n<ul>\n<li>한국어: <code>ko-KR-SeoHyeonNeural</code> — 자연스러운 어린이 목소리</li>\n<li>영어: <code>en-GB-MaisieNeural</code> — 영국 영어 어린이 목소리</li>\n</ul>\n<p>둘 다 발음이 또렷하고 톤이 부드러워서 단어장 용도로 잘 맞았다.</p>\n<h3>API 연동</h3>\n<p>수천 개의 단어를 하나씩 Speech Studio에서 만들 수는 없으니 API를 사용했다. Python SDK를 설치하고 키와 리전만 넣으면 바로 동작한다.</p>\n<pre><code class=\"language-bash\">pip install azure-cognitiveservices-speech\nimport azure.cognitiveservices.speech as speechsdk\n\nspeech_config = speechsdk.SpeechConfig(\n    subscription=&quot;YOUR_KEY&quot;,\n    region=&quot;koreacentral&quot;\n)\nspeech_config.speech_synthesis_voice_name = &quot;ko-KR-SeoHyeonNeural&quot;\n\naudio_config = speechsdk.audio.AudioOutputConfig(filename=&quot;apple.mp3&quot;)\nsynthesizer = speechsdk.SpeechSynthesizer(\n    speech_config=speech_config,\n    audio_config=audio_config\n)\nsynthesizer.speak_text_async(&quot;사과&quot;).get()</code></pre>\n<p>실제로 수백 개의 단어를 대상으로 음성 파일을 생성해봤는데, API 요청을 빠른 간격으로 보내도 별다른 문제 없이 모두 정상적으로 생성되었다. 무료 티어 사용량 안에서도 넉넉하게 처리할 수 있었다.</p>\n<h2>라이선스</h2>\n<p>Azure TTS의 라이선스가 깔끔한 편이다. <a href=\"https://learn.microsoft.com/en-us/legal/ai-code-of-conduct\">Microsoft Enterprise AI Services Code of Conduct</a>를 보면, 이 규정은 무료든 유료든 Microsoft AI 서비스의 모든 고객에게 동일하게 적용된다. 문서에 상업적 이용을 금지하는 조항은 없으며, 오히려 결과물에 대한 권리와 책임이 고객에게 있음을 명시하고 있다.</p>\n<blockquote data-ke-style=\"style1\"><p data-ke-size=\"size16\"><span style=\"font-family: 'Noto Serif KR';\"><p>아래의 질문 답변도 무료티어의 상업적 활용에 대해 명확하게 설명해준다.</p>\n<p><a href=\"https://learn.microsoft.com/en-us/answers/questions/1070009/usage-policy-limitation-for-free-tier\">https://learn.microsoft.com/en-us/answers/questions/1070009/usage-policy-limitation-for-free-tier</a></p>\n</span></p></blockquote><h2>비교 정리</h2>\n<table>\n<thead>\n<tr>\n<th>항목</th>\n<th>Azure TTS</th>\n<th>Google Cloud TTS</th>\n<th>클로바더빙</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>무료 사용량</td>\n<td>월 50만 자</td>\n<td>월 100만 자</td>\n<td>제한적</td>\n</tr>\n<tr>\n<td>셋업 난이도</td>\n<td>간단</td>\n<td>복잡</td>\n<td>간단</td>\n</tr>\n<tr>\n<td>음성 품질</td>\n<td>좋음</td>\n<td>좋음</td>\n<td>좋음 (한국어)</td>\n</tr>\n<tr>\n<td>상업적 이용</td>\n<td>가능</td>\n<td>가능</td>\n<td>불가 (무료)</td>\n</tr>\n<tr>\n<td>출처 표기</td>\n<td>불필요</td>\n<td>불필요</td>\n<td>필수 (무료)</td>\n</tr>\n</tbody></table>\n<h2>마치며</h2>\n<p>TTS 서비스를 고를 때 음성 품질만 보면 상당히 상향평준화가 되어 있다. 결국 차이를 만드는 것은 셋업의 간편함, 과금 구조의 명확함, 그리고 라이선스의 깔끔함이다. Azure TTS는 이 세 가지를 모두 만족시켜주기에 추천한다.</p>\n<p><strong>References</strong></p>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/answers/questions/1192398/can-i-use-azure-text-to-speech-for-commercial-usag\">https://learn.microsoft.com/en-us/answers/questions/1192398/can-i-use-azure-text-to-speech-for-commercial-usag</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/answers/questions/1070009/usage-policy-limitation-for-free-tier\">https://learn.microsoft.com/en-us/answers/questions/1070009/usage-policy-limitation-for-free-tier</a></li>\n<li><a href=\"https://help.naver.com/service/23823/contents/12463?lang=ko&amp;osType=COMMONOS\">https://help.naver.com/service/23823/contents/12463?lang=ko&amp;osType=COMMONOS</a></li>\n</ul>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://shanepark.tistory.com/559"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "진짜로 코딩의 판도는 바뀌었다. 개발자는 어떻게 해야 할까?",
    "partialText": "<blockquote>\n<p>&#39;진짜 한번 해볼까? 한번 코드를 내가 직접 작성하지 않고 어디까지 가능할지를 확인해봐야겠다! 한계를 정확히 알아줘야지&#39;</p>\n</blockquote>\n<p>두달전 재미로 시작하게 된 사이드 프로젝트에서 시작한 에이전트 기반 코딩은 단순하게 &quot;채팅만으로 어디까지 코딩할 수 있을까?&quot;로 시작해서 지금은 에이전트 기반 코딩의 시대가 도래했다는 것을 체감했고 개발의 방식이 완전히 바뀌었습니다.</p>\n<p>이제는 AI에게 일을 시켰을때 검증을 걱정하지 않을 정도로 하는 수준이 오면서 개발하는 방식이 완전히 바뀌었다. 어셈블러에서 C++로 오듯 코드에서 자연어 수준으로 넘어가는 것을 느낍니다. 코드를 직접 수정하지 않고서도 대부분의 개발이 가능한 수준, 아니 그 이상이 되었습니다.</p>\n<p>에이전트가 GitHub 이슈를 스스로 해결하는 벤치마크(SWE-bench)에서 2023년 초기 성공률은 2%였습니다. 2%짜리 주사위를 반반 확률로 한 번이라도 성공하려면 35번을 던져야 해요. 바이브 코딩이 개발자의 빈축을 산 이유죠.</p>\n<p>지금은 어떨까요? 같은 벤치마크의 검증된 문제셋(SWE-bench Verified) 기준으로 79%입니다. 한 번 던지면 79%. 못해도 네 번이면 99%. 거의 성공하고 틀리면 &quot;안되는데? 다시 해봐.&quot; 한번 더 시키면 그만인 수준이 되었습니다.</p>\n<h3 id=\"그렇다면-앞으로-개발자는-뭘-해야-할까요\">그렇다면 앞으로 개발자는 뭘 해야 할까요?</h3>\n<p>하지만 모든 문제가 79%일 수 없습니다. 실제 현업 수준의 복잡한 문제를 모은 별도의 벤치마크(SWE-bench Pro)에서는 최고 모델도 23%라고 합니다. 3번 정도 돌리면 반반의 확률로 성공하는 수준이군요. 그것도 매번 접근 방식을 바꿔가며 돌렸을 때 이야기입니다. 같은 방식으로 반복하면 오히려 더 깊은 수렁에 빠지면서 같은 실패를 반복할 가능성이 높아요. 이따금 우리가 에이전트를 돌리다 겪는 모습입니다. 그래서 가끔 개발자가 방향을 잡아줘야 하죠. 그러면 개발자는 이렇게 조금씩 방향만 잡아주면 되는 사람일까요? </p>\n<blockquote>\n<p>&quot;어? 이게 왜 되지?&quot;</p>\n</blockquote>\n<p>개발자에게 가장 무서운건 버그가 분명 있었고 나는 분명 그 버그를 수정한 적이 없었는데 그냥 되는 경우입니다. 개발자에게는 차라리 깨끗한 실패와 에러가 낫습니다. 코드 수정의 실패는 단순한 실패가 아니기 때문입니다. 분석이나 보고서는 실패하면 버리면 끝이에요. 원본이 그대로니까.</p>\n<p>하지만 코드 수정은? 파일 여러 개를 건드려놓고 일부는 맞고 일부는 틀리고 테스트는 통과하는데 사이드이펙트가 숨어있을 수도 있고 리뷰가 &quot;됐다/안됐다&quot;가 아니라 코드 리뷰가 됩니다. 그것도 내가 짠 코드가 아니라 남이 짠 코드의 리뷰.</p>\n<p>대규모의 유지보수에 많은 인력이 들어가는 이유는 한번 잘못된 설계로 진행하면 그 누적된 문제를 복구하고 고치는 비용이 너무 비싸기 때문이죠. AI도 마찬가지예요. 특히나 잘못된 구조를 정석이라고 믿고 고치다보면 노이즈가 컨텍스트를 방해합니다. AI의 시행착오는 비용입니다.</p>\n<h3 id=\"개발자-ai의-시행착오의-비용을-줄여주는-사람\">&quot;개발자, AI의 시행착오의 비용을 줄여주는 사람&quot;</h3>\n<p>그러면 이 시대에 개발자의 역할은 뭘까요? 세 가지를 한번 생각해봤습니다.</p>\n<p>1 문제를 쪼개는 사람 — 23%짜리 어려운 문제를 79%짜리 여러 개로 분해하는 것. 에이전트가 한 번에 성공할 수 있는 단위로 만들어주는 겁니다.</p>\n<p>2 실패를 빠르게 판별하는 사람 — 에이전트의 결과물이 쓸 만한지, 버려야 하는지, 부분 성공의 함정에 빠진 건 아닌지. 이 판단을 빠르게 내릴수록 시행착오의 비용이 줄어듭니다.</p>\n<p>3 성공률 자체를 높이는 환경을 설계하는 사람 — 좋은 테스트, 명확한 인터페이스, 잘 분리된 모듈. 코드베이스의 아키텍처가 곧 에이전트의 성공률을 결정하는 변수가 됩니다.</p>\n<p>사실 이건 좋은 시니어가 주니어를 키울 때 하는 일과 많이 겹칩니다. 하지만 결정적 차이가 하나 있어요.</p>\n<h3 id=\"에이전트는-욕망이-없고-성장하지-않습니다\">&quot;에이전트는 욕망이 없고, 성장하지 않습니다.&quot;</h3>\n<p>주니어는 냅둬도 알아서 성장합니다. 잘하고 싶다는 욕망이 있으니까요. 물론 좋은 시니어가 옆에 있으면 더 빠르지만, 본인의 의지로 알아서 커갑니다. 에이전트는? 절대적으로 가만히 있어요. 프롬프트를 다듬고 규칙을 정리하면 성공률은 올라가지만, 그건 에이전트가 성장한 게 아니라 환경을 설계한 사람의 역량이 올라간 겁니다.</p>\n<p>그래서 역설적으로, 에이전트 시대에 사람의 가치가 더 선명해집니다. 문제를 쪼개려면 제품이 어디로 가야 하는지 알아야 하고, 실패를 판별하려면 좋은 코드에 대한 감각이 있어야 하고, 환경을 설계하려면 미래에 어떤 변경이 올지 예측해야 합니다. 이건 전부 경험과 의지에서 나오는 것들이고, 자동화가 안 되는 영역입니다.</p>\n<p>저는 지금 제 클론을 만들고 있습니다. 에이전트는 똑똑한데 일은 못하는 사원이에요. 지식은 있는데 일하는 감각이 없는 거죠. 문제를 어떻게 쪼개는지, 실패를 어떻게 판단하는지, 어떤 구조가 좋은 구조인지 — 제가 일하는 방식을 하나하나 알려주고 있는데, 이게 신입사원 키우는 재미와 똑같습니다.</p>\n<p>에이전트가 아직 23%인 지금이 오히려 가르치는 법을 익히기 좋은 때라고 생각합니다. 79%가 되면 다들 그냥 갖다 쓰겠지만, 지금 가르치는 법을 익혀둔 사람은 그때 훨씬 더 잘 쓸 수 있을 테니까요.</p>\n<p>저도 이제 막 눈을 뜬 직후라 아직은 대단하게 정리되지는 못했지만 조만간 정리된 아티클을 만들어서 공유하려고 합니다. 우선 제가 발견한거 하나를 공유드립니다.</p>\n<blockquote>\n<p>&quot;스킬을 등록하는 스킬을 등록해&quot;\n&quot;... 를 스킬로 등록해&quot;</p>\n</blockquote>\n<p>콜롬부스의 달걀. 아는 사람에게는 너무 당연한 데, 이걸 처음 입력하는 순간이 진짜 시작이 됩니다. 이 첫 단추가 여러분들이 에이전트를 쓰는 관점을 바꾸는데 도움이 되기를 바랍니다.</p>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://velog.io/@teo/ai-agent-prolog"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "[Swift][Macro] 환경별 Swift 매크로 분기 처리: 환경에 따라 다른 매크로 호출",
    "partialText": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n<html><body>\n<p>Swift 매크로를 사용하다보면 개발 환경에서 생성된 코드가 운영 환경에서는 불필요한 경우가 발생할 수 있습니다. 특정 Protocol을 구현한 Mock 객체를 생성하는 매크로를 사용한다고 가정해봅시다. <a href=\"https://github.com/Matejkob/swift-spyable\">swift-spyable</a>, <a href=\"https://github.com/Kolos65/Mockable\">Mockable</a> 등의 매크로를 이용해서 Mock 객체를 쉽게 생성할 수 있습니다.</p>\n\n<p>이들 매크로의 코드는 전처리기를 이용해서 <code class=\"language-plaintext highlighter-rouge\">#if DEBUG ... #endif</code> 구문을 사용해서 개발 환경에서만 생성되도록 할 수 있습니다.</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">@Mockable</span>\n<span class=\"kd\">protocol</span> <span class=\"kt\">MyService</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">doSomething</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n\n<span class=\"cp\">#if DEBUG</span>\n<span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"kt\">MyServiceMock</span><span class=\"p\">:</span> <span class=\"kt\">MyService</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">doSomethingCallCount</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">doSomethingCallCount</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"cp\">#endif</span>\n</code></pre></div></div>\n\n<p>하지만 이러한 방식은 생성된 매크로 코드를 다른 모듈에서 인식을 할 수 없는 단점이 있습니다.(예: Mock 객체를 다른 모듈에서 사용해야 하는 경우, 인식이 되지 않음. 단순 코드 작성하면 동작하나, 자동완성이 되지 않음.)</p>\n\n<p>개발 환경에서는 생성된 코드를 통해 테스트를 진행하고, 운영 환경에서는 코드가 생성되지 않도록 하는 방법은 없을까요?</p>\n\n<h2 id=\"매크로-인터페이스-분기-처리\">매크로 인터페이스 분기 처리</h2>\n\n<p>매크로 템플릿을 통해 생성하면 기본 매크로인 <code class=\"language-plaintext highlighter-rouge\">stringify</code> 를 만들 수 있습니다.</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">@freestanding</span><span class=\"p\">(</span><span class=\"n\">expression</span><span class=\"p\">)</span>\n<span class=\"kd\">public</span> <span class=\"n\">macro</span> <span class=\"n\">stringify</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">String</span><span class=\"p\">)</span> <span class=\"o\">=</span>\n    <span class=\"cp\">#externalMacro(module: \"MyMacroMacros\", type: \"StringifyMacro\")</span>\n</code></pre></div></div>\n\n<p>외부에서는 매크로를 호출하지만, 실제로는 매크로 모듈의 매크로를 호출하는 방식입니다. 즉, 여기서는 매크로 모듈에 전처리기를 이용해서 분기 처리를 할 수 있습니다.</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">#if DEBUG</span>\n\n<span class=\"kd\">@freestanding</span><span class=\"p\">(</span><span class=\"n\">expression</span><span class=\"p\">)</span>\n<span class=\"kd\">public</span> <span class=\"n\">macro</span> <span class=\"n\">stringify</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">String</span><span class=\"p\">)</span> <span class=\"o\">=</span> \n    <span class=\"err\">#</span><span class=\"nf\">externalMacro</span><span class=\"p\">(</span><span class=\"nv\">module</span><span class=\"p\">:</span> <span class=\"s\">\"MyMacroMacros\"</span><span class=\"p\">,</span> <span class=\"nv\">type</span><span class=\"p\">:</span> <span class=\"s\">\"StringifyMacro\"</span><span class=\"p\">)</span>\n\n<span class=\"cp\">#else</span>\n\n<span class=\"kd\">@freestanding</span><span class=\"p\">(</span><span class=\"n\">expression</span><span class=\"p\">)</span>\n<span class=\"kd\">public</span> <span class=\"n\">macro</span> <span class=\"n\">stringify</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">String</span><span class=\"p\">)</span> <span class=\"o\">=</span> \n    <span class=\"err\">#</span><span class=\"nf\">externalMacro</span><span class=\"p\">(</span><span class=\"nv\">module</span><span class=\"p\">:</span> <span class=\"s\">\"MyMacroMacros\"</span><span class=\"p\">,</span> <span class=\"nv\">type</span><span class=\"p\">:</span> <span class=\"s\">\"DummyMacro\"</span><span class=\"p\">)</span>\n\n<span class=\"cp\">#endif</span>\n</code></pre></div></div>\n\n<p>이와 같이 매크로 인터페이스를 분기 처리하면, 환경에 관계없이 동일하게 매크로를 호출할 수 있습니다.</p>\n\n<h3 id=\"dummymacro의-역할\">DummyMacro의 역할</h3>\n\n<p>여기서 <code class=\"language-plaintext highlighter-rouge\">DummyMacro</code>는 운영 환경에서 매크로가 불필요한 작업을 수행하지 않도록 설계합니다. 예를 들어, <code class=\"language-plaintext highlighter-rouge\">stringify</code> 매크로의 경우 <code class=\"language-plaintext highlighter-rouge\">DummyMacro</code>는 단순히 입력받은 값을 그대로 반환하기만 하도록 구현할 수 있습니다.</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// MyMacroMacros/DummyMacro.swift</span>\n<span class=\"kd\">public</span> <span class=\"kd\">struct</span> <span class=\"kt\">DummyMacro</span><span class=\"p\">:</span> <span class=\"kt\">ExpressionMacro</span> <span class=\"p\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">func</span> <span class=\"nf\">expansion</span><span class=\"p\">(</span>\n        <span class=\"n\">of</span> <span class=\"nv\">node</span><span class=\"p\">:</span> <span class=\"kd\">some</span> <span class=\"kt\">FreestandingMacroExpansionSyntax</span><span class=\"p\">,</span>\n        <span class=\"k\">in</span> <span class=\"nv\">context</span><span class=\"p\">:</span> <span class=\"kd\">some</span> <span class=\"kt\">MacroExpansionContext</span>\n    <span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">ExprSyntax</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 단순히 입력 인자를 그대로 반환하거나 결과값만 전달</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"</span><span class=\"se\">\\(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">argumentList</span><span class=\"o\">.</span><span class=\"n\">first</span><span class=\"o\">!.</span><span class=\"n\">expression</span><span class=\"se\">)</span><span class=\"s\">\"</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이렇게 하면 운영 환경의 바이너리에는 복잡한 Mock 생성 로직이나 디버깅용 코드가 포함되지 않으며, 매크로 확장으로 인한 빌드 시간 오버헤드도 최소화할 수 있습니다.</p>\n\n<h2 id=\"결론-관심사의-분리와-깔끔한-코드\">결론: 관심사의 분리와 깔끔한 코드</h2>\n\n<p>이 방식의 핵심 이점은 다음과 같습니다.</p>\n\n<ol>\n  <li>\n<strong>관심사의 분리</strong>: 매크로를 사용하는 쪽에서 <code class=\"language-plaintext highlighter-rouge\">#if DEBUG</code>를 일일이 관리할 필요가 없습니다. 환경에 따른 동작 결정은 매크로 인터페이스 정의 단계에서 한 번만 처리됩니다.</li>\n  <li>\n<strong>깨끗한 코드</strong>: 호출부 코드가 복잡해지지 않아 가독성이 높아지고 유지보수가 쉬워집니다.</li>\n  <li>\n<strong>DX(개발 경험) 향상</strong>: 모듈 간 참조 시 발생하는 인식 문제나 자동완성 누락 문제를 매크로 수준에서 해결하여 더 쾌적한 개발 환경을 제공합니다.</li>\n</ol>\n\n</body></html>",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://minsOne.github.io/conditional-swift-macros-generating-development-code-vs-production-dummy-macros"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "펑터를 넘어서, 모나드까지",
    "partialText": "이번 포스팅에서는 이전에 다뤘던 펑터의 개념에 이어 모나드에 대한 설명을 이어가보려고 한다. 아무래도 모나드라고 하면 가장 먼저 떠오르는 것은 “모나드는 내부함자 범주의 모노이드 대상 어쩌고”하는 설명인데, 사실 이것은 모나드를 가장 잘 설명하는 문장이면서도 가장 설명을 못하는 문장이기도 하다. 모나드를 이해하는 순간 모나드를 설명할 수 없게 되어버린다는 모나드의 저주라고 불리는 유명한 밈이 존재할만큼, 수학을 잘 모르는 입장에서는 참 이해하기 난해한 대상이기는 하다. 이에 필자도 야심차게 모나드를 설명하기 위한 도전을 한번 해보려고 한다. (물론 실패할 수도 있다…)",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://evan-moon.github.io/2026/02/07/monads-in-typescript/"
  },
  {
    "publisherId": "awesome-blogs",
    "publisherName": "Awesome Blogs",
    "specTitle": "개발자 블로그 모음",
    "categories": [
      "_all_"
    ],
    "specUrl": "https://awesome-blogs.petabytes.org/feeds?group=dev",
    "title": "Beyond Functors, All the Way to Monads",
    "partialText": "In this post, I’ll continue from the concept of functors I covered previously and move on to explaining monads. When people hear “monad,” the first thing that usually comes to mind is the infamous explanation: “A monad is a monoid in the category of endofunctors, blah blah blah.” While this is technically the most accurate description of a monad, it’s also the most unhelpful one. There’s even a well-known meme called the “monad curse” — the idea that the moment you understand monads, you lose the ability to explain them. For those of us who aren’t deeply versed in mathematics, monads are indeed a notoriously elusive concept. With that in mind, I’m going to take my own ambitious crack at explaining monads. (Of course, I might fail…)",
    "date": "2026-02-14T17:52:54.255Z",
    "url": "https://evan-moon.github.io/2026/02/07/monads-in-typescript/en/"
  }
]