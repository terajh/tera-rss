<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>dev RSS - Awesome Blogs</title>
    <link>https://awesome-blogs.petabytes.org</link>
    <description>Awesome Blogs RSS 피드</description>
    <lastBuildDate>Fri, 13 Feb 2026 02:25:11 GMT</lastBuildDate>
    <item>
      <title>2025 한해 회고</title>
      <link>https://elky84.github.io/2026/02/07/retrospect/</link>
      <guid>https://elky84.github.io/2026/02/07/retrospect/</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;h1 id=&quot;개요&quot;&gt;개요&lt;/h1&gt;
        
        &lt;p&gt;작년 한해는 별 거 안했는데 바빴다&lt;/p&gt;
        
        &lt;p&gt;일도 많은 시기가 있었지만, 그 이후에도 이것 저것 많은 것들을 시도했는데, 그 결과물은 아직이긴 하다&lt;/p&gt;
        
        &lt;p&gt;올해 역시 건강을 더 잘 챙기고 업무 성과, 또 개인적 학습이나 토이 프로젝트도 조금 더 진행해보고자 한다.&lt;/p&gt;
        
        &lt;p&gt;사실 회고를 할 까, 넘길 까 고민했지만 늦게라도 회고를 남겨놔야 내년에도 회고를 할 수 있을 거 같기도하고 올해 블로그 글을 더 쓰게 될 거 같아서 뒤늦게라도 쓰게 됐다&lt;/p&gt;
        
        &lt;h1 id=&quot;개인적인-개발-이야기&quot;&gt;개인적인 개발 이야기&lt;/h1&gt;
        
        &lt;h3 id=&quot;올-한해-github-활동&quot;&gt;올 한해 github 활동&lt;/h3&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://github.com/elky84?tab=overview&amp;amp;from=2025-01-01&amp;amp;to=2025-12-31&quot;&gt;elky84 (elky (SeongHoon Kim)) (github.com)&lt;/a&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;nuget-패키지-누적-다운로드&quot;&gt;nuget 패키지 누적 다운로드&lt;/h3&gt;
        
        &lt;table&gt;
        &lt;tbody&gt;
        &lt;tr&gt;
        &lt;td&gt;[NuGet Gallery&lt;/td&gt;
        &lt;td&gt;elky](https://www.nuget.org/profiles/elky)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;/table&gt;
        
        &lt;h3 id=&quot;올-해-블로그-글-갯수&quot;&gt;올 해 블로그 글 갯수&lt;/h3&gt;
        
        &lt;p&gt;회고 포함 5개
        너무 적게 썼던 듯 하다&lt;/p&gt;
        
        &lt;p&gt;올핸 좀 더 많이 써보리&lt;/p&gt;
        
        &lt;hr /&gt;
        &lt;h1 id=&quot;게임-플레이&quot;&gt;게임 플레이&lt;/h1&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://store.steampowered.com/replay/76561197988905808/2025&quot;&gt;elky’s STEAM YEAR IN REVIEW 2025 (steampowered.com)&lt;/a&gt;&lt;/p&gt;
        
        &lt;h1 id=&quot;2025년-best-choice&quot;&gt;2025년 Best Choice&lt;/h1&gt;
        
        &lt;h2 id=&quot;올해의-게임&quot;&gt;올해의 게임&lt;/h2&gt;
        
        &lt;h3 id=&quot;1-poe-1-용병-리그&quot;&gt;1. POE 1 용병 리그&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;용켓몬만으로도 너무 재밌었고, 역저항 날먹이 되다보니 탱도 되는 역저항으로 대동단결이 조금 아쉬웠지만, 디아 2부터 있던 용병으로 인한 2개의 템 세팅의 조합으로 인한 재미는 너무나 좋았다.
        &lt;ul&gt;
        &lt;li&gt;2달 가까이 돌았던 스발린 런에서 스발린을 못먹은건 아쉽지만…&lt;/li&gt;
        &lt;li&gt;패시브 트리를 못찍음에도, 여러 버프만으로 오라봇을 통한 빌드까지 돌아가는 과정이 재밌었다&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;본 서버 편입 예정이라고 들었는데, 역저항만 잘 막아도 꽤나 재밌는 기재가 많았던 만큼 재미를 크게 더 해줄수 있을 거란 기대가 된다.
        &lt;h3 id=&quot;2-poe-2-바알의-운명-리그&quot;&gt;2. POE 2 바알의 운명 리그&lt;/h3&gt;
        &lt;/li&gt;
        &lt;li&gt;POE1 불길의 수호자 리그에서의 삿된 아이템 (고유템에서 특정 옵션 하나를 대체한 변성 아이템)에서 조금 더 틀어서, 확률이 더 들어갔고, 더블 커럽 (타락 2번으로, 홈 변경, 수치 변경, 옵션 부여가 최대 2번 가능)이 POE1 보다 편하게 도입되면서 재밌는 아이템이 많이 나왔다
        &lt;ul&gt;
        &lt;li&gt;물론 POE1보다 제한이 많은 역냉각, 그나마 공격은 흡수라도 되지만 주문 스킬 사용 시 코스트 제한이 큰 POE2의 제약을 풀어주는 계약 갑옷의 함양 옵션은 블러 메이지 어센던시가 얼마나 사기였는지 알 수 있었다.&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;무한 불가능한 탈출, 히든 패시브 스킬 트리의 오라클도 재밌었고, 곰, 늑대, 와이번 드루이드도 꽤 재밌게 즐겼다.&lt;/li&gt;
        &lt;li&gt;바알 사원이 POE1의 고난 리그 못지 않은 도파민 리그였고, 이를 막으려다가 롤백하는 등 사소한 이슈들이 있었지만, 역시 핵슬은 도파민이 리그 흥행에 도움이 된다는 것을 다시 한번 느끼게 됐다.
        &lt;h3 id=&quot;3-디아블로-4-시즌-10&quot;&gt;3. 디아블로 4 시즌 10&lt;/h3&gt;
        &lt;/li&gt;
        &lt;li&gt;오픈 베타 이후 아쉬움을 느껴 POE를 시작했고 라스트 에포크를 즐겼지만, 워낙 여러 영상에서 극찬이 많던 시즌이라 나도 즐기게 됐다.&lt;/li&gt;
        &lt;li&gt;확실히 액트 구간을 빠르게 넘길 수 있고, 이로 인해 엔드 게임을 빠르게 진입할 수 있는 것은 장점이었지만, 직관적이고 빠르게 적응 가능한 시스템들도 많았던 데에 비해, 위상 같은 것은 번거롭기만 한 느낌도 지울 수 없었다.&lt;/li&gt;
        &lt;li&gt;비약 같은 시스템은 MMORPG같은 느낌이 드는 버프도 있었는데, 또 어떤 부분은 핵슬의 기본 문법 스러운 포인트도 있고해서 나름 재밌게 즐겼다&lt;/li&gt;
        &lt;li&gt;아이템 거래가 불편한 것만 아니었다면 좀 더 재밌게 즐겼을 듯
        &lt;ul&gt;
        &lt;li&gt;제발 거래소 좀..&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;지향점 자체가 라이트한 핵앤 슬래시라는 게 느껴지긴 했으나, 그래도 좀 더 파고들기 요소가 있어야 되지 않을까?
        &lt;h2 id=&quot;올해의-워스트-게임&quot;&gt;올해의 워스트 게임&lt;/h2&gt;
        &lt;h3 id=&quot;1-poe-2-사냥의-서막&quot;&gt;1. POE 2 사냥의 서막&lt;/h3&gt;
        &lt;/li&gt;
        &lt;li&gt;POE2 얼리억세스의 좋은 기세에 찬물을 끼얹은 시즌&lt;/li&gt;
        &lt;li&gt;액트 시간이 단축되는 것을 못마땅하게 여겼는지, 가뜩이나 어렵던 액트 구간을 더 어렵게 만들었고, 이 과정에서의 이탈했고 나 역시 모든 POE2 시즌 중 일주일 남짓에 오프한 리그
        &lt;ul&gt;
        &lt;li&gt;특히 워리어 계열이 크게 고통 받았는데, 여러가지 반발이 많았고 이로 인해 허리띠에 호신부 슬롯 기본 부여, 전직 변경 가능을 비롯한 여러가지 개선이 이뤄진 전화위복 시즌이었다&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;번개창으로 대동단결된 시즌이라, 시원시원하게 재밌게 즐긴 분도 많았겠지만, 시즌제 게임에서 초반이 얼마나 중요한지, 그 대응의 중요성도 느꼈던 시즌
        &lt;h3 id=&quot;2-풋볼-매니저-26&quot;&gt;2. 풋볼 매니저 26&lt;/h3&gt;
        &lt;/li&gt;
        &lt;li&gt;아직 버그가 너무 많다&lt;/li&gt;
        &lt;li&gt;새로운 게임이 된 거 같지만, 잘 정돈되지 않은 느낌은 크게 아쉬웠음
        &lt;ul&gt;
        &lt;li&gt;할만은 하지만, 할만한 정도론 이전 버전을 플레이 하는게 낫지 않나 싶은 생각이 들었음
        &lt;h3 id=&quot;3-몬스터-헌터-와일즈&quot;&gt;3. 몬스터 헌터 와일즈&lt;/h3&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;내가 굳이 언급하지 않아도 알겠지만, 여러 이슈로 인해 확장팩만 기다리는 사람이 산더미인 게임&lt;/li&gt;
        &lt;li&gt;과연 확장팩에선 개과천선할 수 있을까?&lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h2 id=&quot;기억에-남는-게임&quot;&gt;기억에 남는 게임&lt;/h2&gt;
        &lt;h3 id=&quot;1-라스트-에포크-시즌-2-3&quot;&gt;1. 라스트 에포크 시즌 2, 3&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;사실 아직 많이 모자르다
        &lt;ul&gt;
        &lt;li&gt;그래도 같은 직업군 내의 패시브를 혼합해서 찍을 수도 있고, 기본적 게임의 틀은 잘 완성된 형태여서 재밌게 즐겼다&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;시즌 중에 발생한 거래소 한글 버그가 고쳐지지 않은 문제나, 패치마다 발생하는 소소한 버그가 너무 늦게 고쳐지는 이슈, 시즌 2 -3 간격도 빠른 편이라 보긴 어렵지만, 1-2의 간격, 3-4의 간격은 지나치게 길다는 점, 시즌 컨텐츠 양이 부족하다는 점 등은 아쉽다&lt;/li&gt;
        &lt;li&gt;엔드 게임이 디아4보다는 풍부하지만 부족함이 많고, 컨텐츠 역시 갈길이 먼 측면이 있으며, 플레이 타임을 유지하기 위해서인지 한번 사용된 아이템은 각인되는데, 이로 인해 반복 노가다와 득템의 효율이 조금 아쉽다&lt;/li&gt;
        &lt;li&gt;총평하자면 포텐은 증명했으나, 용이 되지 못했고, 발표한 플랜도 아쉬움이 크다.
        &lt;ul&gt;
        &lt;li&gt;그럼에도 관심을 놓자니 미련이 남는 게임
        &lt;h3 id=&quot;2-토치-라이트-인피니트-ss10&quot;&gt;2. 토치 라이트 인피니트 SS10&lt;/h3&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;핵슬에 대한 이해도를 높일 겸사 겸사 시작했던 게임
        &lt;ul&gt;
        &lt;li&gt;널리 알려진거에 비해서 무료 캐릭으로 무료로 즐겨도 할만했음&lt;/li&gt;
        &lt;li&gt;그래픽의 호불호는 나도 좀 있긴했지만, 생각보다 완성도 높은 게임이라서 놀라웠음&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;왜 이 게임을 POE 다음 가는 수준의 깊이 있는 게임이라고 말하는지는 충분히 알았고, 이후에도 종종 타이밍 맞으면 즐길 게임
        &lt;h3 id=&quot;3-엘더-스크롤-4-오블리비언-리마스터&quot;&gt;3. 엘더 스크롤 4 오블리비언 리마스터&lt;/h3&gt;
        &lt;/li&gt;
        &lt;li&gt;사실 원작이 발매됐던 시기에도 엑박버전이나 스팀 버전 등 여러번 샀음에도, 적응을 못하고 넘어갔었다&lt;/li&gt;
        &lt;li&gt;이후 스카이림을 재밌게 즐겼으나, 굳이 구작을 즐기지 않았었는데 이번에 리마스터가 되면서 즐기게 됐다.&lt;/li&gt;
        &lt;li&gt;아니 이런 명작을 놓쳤다니…? 이래서 오블리비언 오블리비언 얘기가 나왔고, 엘더 스크롤이 메이저 게임으로 한국에도 퍼진 계기였구나 싶은 감탄이 나왔던 게임&lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h2 id=&quot;올해의-영상&quot;&gt;올해의 영상&lt;/h2&gt;
        
        &lt;h3 id=&quot;1-서울-자가에-대기업-다니는-김부장-이야기&quot;&gt;1. 서울 자가에 대기업 다니는 김부장 이야기&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;그 감정선이나 묘사가 너무 재밌었음&lt;/li&gt;
        &lt;li&gt;나 역시 나이가 들어가는 입장에서 많이 공감되어야 하는거 아니냐고 말할 수도 있지만, 약간 과장되었거나, 공감이 안되는 내용이 꽤 있었다&lt;/li&gt;
        &lt;li&gt;하지만 드라마로써의 완성도나 만족도는 충분했음
        &lt;h3 id=&quot;2-중증외상센터&quot;&gt;2. 중증외상센터&lt;/h3&gt;
        &lt;/li&gt;
        &lt;li&gt;여러 의학 드라마의 무게감보다 훨씬 명확하고 명쾌해서 좋았다
        &lt;ul&gt;
        &lt;li&gt;중증 외상 센터가 왜 필요한지에 대해서 알 수 있던 점은 덤&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;깔끔한 전개로 즐겁게 볼 수 있었던 드라마
        &lt;h3 id=&quot;3-경도를-기다리며&quot;&gt;3. 경도를 기다리며&lt;/h3&gt;
        &lt;/li&gt;
        &lt;li&gt;오징어 게임의 세미역으로 나왔던 원지안 배우가 여주인공이었는데, 아주 매력적으로 나왔다&lt;/li&gt;
        &lt;li&gt;약간 디테일은 많이 다르지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그 해 우리는&lt;/code&gt; 의 김다미 배우처럼, 작품과 딱 맞아떨어져 매력적으로 보였던 작품&lt;/li&gt;
        &lt;li&gt;의외로 이런 저런 전개 과정이 멜로나, 로맨틱 코메디보다 재밌게 볼 수 있는 부분이 많아서 좋았다다&lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h2 id=&quot;올해의-아쉬운-드라마&quot;&gt;올해의 아쉬운 드라마&lt;/h2&gt;
        &lt;h3 id=&quot;1-오징어-게임-2-3&quot;&gt;1. 오징어 게임 2, 3&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;군계 일학이라 하나만 꼽겠음&lt;/li&gt;
        &lt;li&gt;이유는 굳이 말 안해도 많은 사람들이 알거라 생각하지만…
        &lt;ul&gt;
        &lt;li&gt;무언가 기간 부족인지 1에 비해 떨어지는 디테일이 공감, 감정 이입을 방해했다
        &lt;h2 id=&quot;올해의-음악&quot;&gt;올해의 음악&lt;/h2&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h3 id=&quot;1-프로미스-나인---하얀-그리움&quot;&gt;1. 프로미스 나인 - 하얀 그리움&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;
        &lt;table&gt;
        &lt;tbody&gt;
        &lt;tr&gt;
        &lt;td&gt;[fromis_9 (프로미스나인) - White Memories (하얀 그리움)&lt;/td&gt;
        &lt;td&gt;Show! MusicCore&lt;/td&gt;
        &lt;td&gt;MBC251206방송](https://www.youtube.com/watch?v=fXyVxWRjSco&amp;amp;list=RDfXyVxWRjSco&amp;amp;start_radio=1)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;/li&gt;
        &lt;li&gt;알아듣기 힘든 노래 속에, 옛날 김민종님의 90-00 감성이 살아나는 노래를 잘 살렸다&lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h3 id=&quot;2-nmixx---blue-valentine&quot;&gt;2. NMIXX - Blue Valentine&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;
        &lt;table&gt;
        &lt;tbody&gt;
        &lt;tr&gt;
        &lt;td&gt;[NMIXX (엔믹스) - Blue Valentine&lt;/td&gt;
        &lt;td&gt;Show! MusicCore&lt;/td&gt;
        &lt;td&gt;MBC251018방송](https://www.youtube.com/watch?v=VnUNpf0sgFE&amp;amp;list=RDVnUNpf0sgFE&amp;amp;start_radio=1)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;/li&gt;
        &lt;li&gt;이 노래 역시, 하얀 그리움처럼 잘 알아들을 수 있고 겨울 감성 살아있는 설레임 가득한 느낌이 드는 음악이어서 좋았다&lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h3 id=&quot;3-behind-the-moon---밤의-끝자락&quot;&gt;3. Behind the Moon - 밤의 끝자락&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=m1OZqiSDy1s&amp;amp;list=RDm1OZqiSDy1s&quot;&gt;밤의 끝자락 (Official Audio)&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;시티팝? J-POP? 스러운 감성의 노래였는데 감성적으로 취향 저격이었음&lt;/li&gt;
        &lt;li&gt;다만 Behind the Moon의 노래중 이 노래가 특히 좋았다는 점은 조금 아쉬웠음
        &lt;ul&gt;
        &lt;li&gt;김수영처럼 많은 노래가 비슷하게 취향 저격이었음 좋았을텐데…&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h1 id=&quot;올해의-기술-주제&quot;&gt;올해의 기술 주제&lt;/h1&gt;
        
        &lt;h2 id=&quot;1-llm-쇼크-바이브-코딩&quot;&gt;1. LLM 쇼크, 바이브 코딩&lt;/h2&gt;
        &lt;ul&gt;
        &lt;li&gt;LLM의 발전이 기대보다 빠르게 진행되고 있다&lt;/li&gt;
        &lt;li&gt;바이브 코딩과 함께 일정 수준 이하의 단순한 작업은 코드를 작성하지 않고도 가능해진 점은, 여러 분야의 생산성을 극대화 시킬 수 있는 부분이라고 보여진다&lt;/li&gt;
        &lt;li&gt;물론 여전히 한계도 많고, 그 퀄리티의 제약도 많은 것은 당연한데, 이렇게 진행되다보면 개발자 무용론이 더 심해지지 않을까 우려도, 또 한편으로는 기회일 수도 있다는 생각도 든다
        &lt;ul&gt;
        &lt;li&gt;또 더 성장해야 된다는 생각 역시 들고 말이다
        &lt;h2 id=&quot;2-메모리-가격-쇼크&quot;&gt;2. 메모리 가격 쇼크&lt;/h2&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;이게 왜 기술 주제냐하실 수 있는데, 메모리가 비싸지면 PC 시장이나, 서버 시장에도 영향을 줘서라고 말하고 싶다&lt;/li&gt;
        &lt;li&gt;메모리 가격이 몇배씩 뛰면서, 게이머들의 PC 업그레이드 저항감은 더 커졌다
        &lt;ul&gt;
        &lt;li&gt;심지어 맥미니가 가성비라는 말 (원래도 어느정돈 그랬지만)이 더 공감을 얻고 있는데, 이러한 램 가격은 한동안 내려오지 않을 듯 하다&lt;/li&gt;
        &lt;li&gt;SSD도 가격 인상중인데, 이 영향이 얼마나 커질까?&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;또 게이머 관점에서도, 게임 개발자 관점에서도 PC 보급의 저항감이 낮아진 것은 우려가 되는 것은 사실이다
        &lt;h2 id=&quot;3-postgresql의-강세-mysql의-약세&quot;&gt;3. PostgreSQL의 강세, MySQL의 약세&lt;/h2&gt;
        &lt;/li&gt;
        &lt;li&gt;이러한 흐름은 몇년이나 지속 됐지만, 그 흐름이 더 커지는 명확한 시그널이 느껴진다&lt;/li&gt;
        &lt;li&gt;오라클이 MySQL 커뮤니티, 개발을 유지할지에 대한 우려가 더 커지는 상황이 나오고 있고, 반면 PostgreSQL은 더 발전이 가속화 되는 상황이 이어지며, 이 흐름이 한국에서 얼마나 영향을 줄 지 궁금해진다.&lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h1 id=&quot;올해의-글&quot;&gt;올해의 글&lt;/h1&gt;
        &lt;h2 id=&quot;1-aws-버지니아-ddb-장애&quot;&gt;1. AWS 버지니아 DDB 장애&lt;/h2&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/message/101925/&quot;&gt;Summary of the Amazon DynamoDB Service Disruption in the Northern Virginia (US-EAST-1) Region&lt;/a&gt;
        &lt;ul&gt;
        &lt;li&gt;실제 내가 서비스중인 프로덕트도 영향을 받았고, 이외에도 많은 제품이 영향을 받아 어떤 제품들이 AWS를 쓰고 있는지 알 수 있었음&lt;/li&gt;
        &lt;li&gt;원인을 잘 설명해주긴 했으나, 결국 과도하게 복잡해진 시스템은 작은 오류도 복구가 쉽지 않아진다는 점은 크게 공감할 수 있었다
        &lt;h2 id=&quot;2-llm과-함께라면-3달이-3일&quot;&gt;2. LLM과 함께라면 3달이 3일&lt;/h2&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://marianogappa.github.io/software/2025/08/24/i-made-two-card-games-in-go/&quot;&gt;Mariano Gappa’s Blog&lt;/a&gt;
        &lt;ul&gt;
        &lt;li&gt;사실 나 역시 토이 프로젝트나, 프로토타이핑 개발 시 단순한 기능의 구현이 떠오르지 않아 시간을 많이 소모한 일이 적지 않았다&lt;/li&gt;
        &lt;li&gt;예를 들면, 그리드 기반 게임에서의 AStar라던지, 서버에서의 연산을 위한 경량 Raycast라던지, 투사체의 궤도라던지와 같은 로직들은 어떠한 동작을 원할 때 기능을 찾거나, 직접 구현하는 과정에서 많은 시간을 소모했다&lt;/li&gt;
        &lt;li&gt;반면 이러한 수준의 작업은 아주 아주 쉬워진 상황이 나에게도 체감이 되고 있다.&lt;/li&gt;
        &lt;li&gt;물론 상대적으로 게임은 바이브 코딩으로 최종 결과물이 안나오는 경우가 꽤 되지만, 이 역시 많이 해소 되고 있고, 더 가속화 될 거 같다.
        &lt;ul&gt;
        &lt;li&gt;다만 재미를 찾는 것은 여전히 사람의 영역이므로 이 부분에 경쟁력이 더 중요해져 가고 있다는 생각도 들었다
        &lt;h2 id=&quot;3-llm-사용을-줄인-이유&quot;&gt;3. LLM 사용을 줄인 이유&lt;/h2&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://zed.dev/blog/dialing-back-my-llm-usage-with-alberto-fortin&quot;&gt;Why I’m Dialing Back My LLM Usage — Zed’s Blog&lt;/a&gt;
        &lt;ul&gt;
        &lt;li&gt;요약하자면 보조적인 용도로 LLM을 써야 한다는 의미
        &lt;ul&gt;
        &lt;li&gt;나 역시 비슷한 의견을 가지고 있긴 하지만, 조금 더 그 생각을 명확히 드러내준 글이라고 볼 수 있겠다&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://lucianonooijen.com/blog/why-i-stopped-using-ai-code-editors&quot;&gt;Why I stopped using AI code editors · Luciano Nooijen&lt;/a&gt;
        &lt;ul&gt;
        &lt;li&gt;비슷한 의견
        &lt;ul&gt;
        &lt;li&gt;LLM을 사용하면 깊이 있는 생각과 통찰은 못 얻는 아쉬움을 대체하기 위해서, 기준을 정하고 사용한다는 의미
        &lt;ul&gt;
        &lt;li&gt;
        &lt;h2 id=&quot;바이브-코딩으로-얻는-장단점을-명확하게-말한-듯-하다&quot;&gt;바이브 코딩으로 얻는 장단점을 명확하게 말한 듯 하다&lt;/h2&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h1 id=&quot;새해-바램&quot;&gt;새해 바램&lt;/h1&gt;
        &lt;h3 id=&quot;건강&quot;&gt;건강&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;다른 곳은 그래도 좀 괜찮았는데, 수면 장애랑 목이 너무 아프다
        &lt;ul&gt;
        &lt;li&gt;이 부분을 주기적으로 병원 가서 치료 받고 있지만, 아직은 좀 아파서 신경 쓰이는 상황
        &lt;h3 id=&quot;강아지&quot;&gt;강아지&lt;/h3&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;초코가 그래도 많이 안아팠다
        &lt;ul&gt;
        &lt;li&gt;특히 돈은 많이 들어가고 있지만, 건강을 잘 챙기고 있게 되서 다행이다&lt;/li&gt;
        &lt;li&gt;올해도 괜찮길&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;파이는 여전히 건강하다
        &lt;ul&gt;
        &lt;li&gt;살만 안찌면 그래도 괜찮을 듯
        &lt;h3 id=&quot;여가-생활&quot;&gt;여가 생활&lt;/h3&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;핵앤슬래시에 대한 이해가 크게 올라온 한해였다
        &lt;ul&gt;
        &lt;li&gt;대다수의 메이저 핵앤 슬래시를 모두 어느정도 수준까지 이해할 수 있게 됐다&lt;/li&gt;
        &lt;li&gt;핵앤 슬래시 토이 프로젝트로 이어보고 싶은 개인적 바램이 있다
        &lt;h1 id=&quot;마치며&quot;&gt;마치며&lt;/h1&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;매년 그렇듯, 건강도 잘 챙기고, 업무적 성취도 잘 이루고 싶다&lt;/li&gt;
        &lt;li&gt;특히 매년 노력해온 건강, 토이 프로젝트와 함께 가족과의 시간도 더 잘 보내고 싶다&lt;/li&gt;
        &lt;li&gt;핵앤 슬래시 게임을 로직적으로나 기획적으로는 어느정도 엿볼 수 있는 제품을 만들어보고 싶다&lt;/li&gt;
        &lt;li&gt;다들 건강 잘 챙기시길!&lt;/li&gt;
        &lt;/ul&gt;
      </content:encoded>
    </item>
    <item>
      <title>AI 코딩이 오히려 개발자의 생산성을 떨어뜨린다? - Anthropic 논문</title>
      <link>https://bcho.tistory.com/1500</link>
      <guid>https://bcho.tistory.com/1500</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        Anthropic에서 개발자 생산성에 AI가 미치는 영향을 탐구한 매우 흥미로운 논문(https://arxiv.org/pdf/2601.20245)을을) 발표했다.
        놀랍게도, AI 기반 코딩이 실제로는 생산성을 높이지 않을 수도 있다는 결과가 나왔는데,&amp;nbsp; 프롬프트를 작성하고 다듬는 과정, 그리고 생성된 결과를 해석하는 데 상당한 시간이 소요되기 때문이다. 게다가 엔지니어가 핵심 개념을 이해하거나 코드 구조를 파악하고, 직접 디버깅해 볼 기회를 뺏..
      </content:encoded>
    </item>
    <item>
      <title>AI 코딩 플랫폼 트렌드 비교(Claude Code, Codex,Gemini)</title>
      <link>https://bcho.tistory.com/1499</link>
      <guid>https://bcho.tistory.com/1499</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        조대협 (http://bcho.tistory.com)
        &amp;nbsp;
        작년이 Cursor, Winsurf등 AI 코딩 도구와 Lovable, Replit 등의 바이브 코딩으로 시작되는 한해였다면, 금년은 Claude Code와 같은 CLI 기반의 에이전트 코딩으로 넘어가는 한해이다.
        &amp;nbsp;
        2026년 트랜드 변화
        2025년에는 개발자들이 전체 코드가 아니라 일부 모듈이나 코딩 부분을 Cursor 와 같은 IDE에서 개발하는 정도로, AI의 도움을 받아..
      </content:encoded>
    </item>
    <item>
      <title>CDP &amp;amp; Playwright를 이용한 브라우저 자동화</title>
      <link>https://bcho.tistory.com/1498</link>
      <guid>https://bcho.tistory.com/1498</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        CDP &amp;amp; Playwright
        조대협 (http://bcho.tistory.com)아래 코드는 프롬프트를 이용해서, Sonnet-4를 사용해 생성한 컨텐츠 입니다.
        브라우저 자동화 학습 교본
        Chrome DevTools Protocol과 Playwright를 활용한 웹 자동화 완벽 가이드
        
        목차
        
        1. 소개
        2. 아키텍처 이해
        3. 프로젝트 설정
        4. CDP 예제
        5. Playwright 예제
        6. 사람처럼 행동하기 (Advanced)
        7..
      </content:encoded>
    </item>
    <item>
      <title>AI 시대의 Fail Fast: 실패의 수준이 달라졌다</title>
      <link>https://novemberde.github.io/post/2026/02/10/AI-Fail-Fast-Product-Quality-ko/</link>
      <guid>https://novemberde.github.io/post/2026/02/10/AI-Fail-Fast-Product-Quality-ko/</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&amp;ldquo;빠르게 실패하라(Fail Fast).&amp;rdquo;&lt;/p&gt;
        &lt;p&gt;스타트업과 프로덕트 세계에서 가장 많이 들리는 조언 중 하나다. 아이디어를 빠르게 시장에 내놓고, 피드백을 받고, 방향을 수정하라. 틀린 말이 아니다. 하지만 현실은 종종 이랬다. 빠르게 만드느라 수준이 떨어지고, 수준이 떨어지니 피드백 자체가 왜곡되고, 왜곡된 피드백으로 잘못된 결론을 내린다.&lt;/p&gt;
        &lt;p&gt;AI가 이 공식을 근본적으로 바꾸고 있다.&lt;/p&gt;
        &lt;h2 id=&quot;과거의-fail-fast-속도와-수준의-트레이드오프&quot;&gt;과거의 Fail Fast: 속도와 수준의 트레이드오프&lt;/h2&gt;
        &lt;p&gt;전통적인 Fail Fast에는 구조적 한계가 있었다. 빠르게 만들려면 수준을 타협해야 했다. MVP(Minimum Viable Product)라는 이름 아래, &amp;ldquo;최소한으로 동작하는&amp;rdquo; 수준의 프로덕트를 만들어 시장에 내놓았다. 문제는 이 &amp;ldquo;최소한&amp;quot;의 수준이 너무 낮았다는 점이다.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Amazon Redshift의 내부 Architecture: ParAccel에서 Serverless까지</title>
      <link>https://novemberde.github.io/post/2026/02/09/Redshift-Internals-Architecture-ko/</link>
      <guid>https://novemberde.github.io/post/2026/02/09/Redshift-Internals-Architecture-ko/</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;h2 id=&quot;용어-사전&quot;&gt;용어 사전&lt;/h2&gt;
        &lt;p&gt;이 글에서 자주 등장하는 핵심 용어를 먼저 정리한다.&lt;/p&gt;
        &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
        &lt;th&gt;용어&lt;/th&gt;
        &lt;th&gt;설명&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;MPP&lt;/strong&gt; (Massively Parallel Processing)&lt;/td&gt;
        &lt;td&gt;다수의 Node가 Query를 분할하여 동시에 처리하는 Architecture&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Leader Node&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;Client 요청을 받아 SQL Parsing, Query Planning, Code Generation을 수행하고 결과를 집계하는 Coordinator&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Compute Node&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;실제 데이터를 저장하고 Query Segment를 병렬 실행하는 Worker Node&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Slice&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;Compute Node 내부의 병렬 처리 단위. 독립적인 CPU, Memory, Disk Partition을 가짐&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;RMS&lt;/strong&gt; (Redshift Managed Storage)&lt;/td&gt;
        &lt;td&gt;S3 기반 Tiered Storage. Local SSD Cache + S3 Cold Storage로 구성&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;AQUA&lt;/strong&gt; (Advanced Query Accelerator)&lt;/td&gt;
        &lt;td&gt;Storage Layer에서 FPGA/Nitro Processor로 Filtering과 Aggregation을 사전 수행하는 가속기&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Zone Map&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;각 1MB Block의 Min/Max 값을 Memory에 보관하는 Metadata. Block Skipping에 사용&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;AZ64&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;Amazon이 자체 개발한 SIMD 기반 Compression Algorithm. Numeric/Date Type에 특화&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;WLM&lt;/strong&gt; (Workload Management)&lt;/td&gt;
        &lt;td&gt;Query Queue별 Memory, Concurrency Slot을 배분하는 Resource Management 시스템&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;ATO&lt;/strong&gt; (Automatic Table Optimization)&lt;/td&gt;
        &lt;td&gt;Query Pattern을 분석하여 Distribution Key/Sort Key를 자동 최적화하는 AI 기반 기능&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;RPU&lt;/strong&gt; (Redshift Processing Unit)&lt;/td&gt;
        &lt;td&gt;Redshift Serverless의 Compute 단위. 1 RPU = 16GB Memory&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Concurrency Scaling&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;Workload 급증 시 Transient Cluster를 자동 추가하여 Throughput을 확장하는 기능&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;SQA&lt;/strong&gt; (Short Query Acceleration)&lt;/td&gt;
        &lt;td&gt;짧은 Query를 전용 Queue(Service Class 14)에서 우선 실행하여 긴 Query에 Block되지 않게 하는 기능&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;MVCC&lt;/strong&gt; (Multi-Version Concurrency Control)&lt;/td&gt;
        &lt;td&gt;각 Transaction이 데이터의 Snapshot을 기반으로 동작하여 Read/Write Blocking을 최소화하는 동시성 제어&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;hr&gt;
        &lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;
        &lt;p&gt;Amazon Redshift는 2012년 re:Invent에서 발표되어 2013년 2월 15일 GA(General Availability)된 이후, Cloud Data Warehouse 시장의 판도를 바꾸어 놓았다. 2025년 기준 수만 개의 조직이 Petabyte 규모의 데이터를 Redshift 위에서 분석하고 있다.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Colossus와 Capacitor: BigQuery를 지탱하는 Storage의 구조</title>
      <link>https://novemberde.github.io/post/2026/02/09/Colossus-Capacitor-BigQuery-Internals-ko/</link>
      <guid>https://novemberde.github.io/post/2026/02/09/Colossus-Capacitor-BigQuery-Internals-ko/</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;
        &lt;p&gt;BigQuery의 Performance는 단순히 좋은 Query Engine 하나로 만들어지지 않았다. 그 아래에는 Google이 20년 넘게 진화시켜 온 Infrastructure Stack이 있다.&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;Colossus&lt;/strong&gt;: Exabyte 규모의 Distributed File System&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Capacitor&lt;/strong&gt;: Compressed 상태에서 직접 Query할 수 있는 Columnar Format&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Jupiter&lt;/strong&gt;: 13 Petabits/sec Bandwidth의 Data Center Network&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Dremel&lt;/strong&gt;: Tree 구조 병렬 Execution Engine&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Borg&lt;/strong&gt;: 수만 대 Machine의 Cluster Management System&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;이 글에서는 이 중 &lt;strong&gt;Colossus와 Capacitor&lt;/strong&gt;에 집중한다. BigQuery에서 Query를 실행하면, 실제 데이터는 어디에 어떻게 저장되어 있고, 어떤 원리로 읽히는지 구조적으로 살펴본다.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>BigQuery vs Redshift: Cloud Data Warehouse 선택을 위한 비교</title>
      <link>https://novemberde.github.io/post/2026/02/08/BigQuery-vs-Redshift-Deep-Dive-ko/</link>
      <guid>https://novemberde.github.io/post/2026/02/08/BigQuery-vs-Redshift-Deep-Dive-ko/</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;h2 id=&quot;용어-사전&quot;&gt;용어 사전&lt;/h2&gt;
        &lt;p&gt;이 글에서 자주 등장하는 핵심 용어를 먼저 정리한다.&lt;/p&gt;
        &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
        &lt;th&gt;용어&lt;/th&gt;
        &lt;th&gt;설명&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;MPP&lt;/strong&gt; (Massively Parallel Processing)&lt;/td&gt;
        &lt;td&gt;다수의 Node가 Query를 분할하여 동시에 처리하는 Architecture&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Slot&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;BigQuery의 Compute 단위. 가상 CPU + Memory + I/O를 추상화한 Resource Unit&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;RPU&lt;/strong&gt; (Redshift Processing Unit)&lt;/td&gt;
        &lt;td&gt;Redshift Serverless의 Compute 단위. 1 RPU = 16GB Memory&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Columnar Storage&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;데이터를 Row가 아닌 Column 단위로 저장하는 방식. 분석 Query에서 필요한 Column만 읽어 I/O 절감&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Distribution Key&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;Redshift에서 데이터를 Node 간에 분산하는 기준 Column. JOIN Performance에 직접 영향&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Sort Key&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;Redshift에서 데이터를 디스크에 물리적으로 정렬하는 기준 Column. Filter Performance에 직접 영향&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Partitioning&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;BigQuery에서 Table을 날짜/정수 범위 등으로 논리 분할. Scan 범위를 제한하여 비용과 속도 모두 개선&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Clustering&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;BigQuery에서 Partition 내 데이터를 특정 Column 기준으로 정렬. 최대 4개 Column 지정 가능&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;WLM&lt;/strong&gt; (Workload Management)&lt;/td&gt;
        &lt;td&gt;Redshift의 Query Queue 관리 시스템. Query 종류별 Memory/Concurrency 배분&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;ATO&lt;/strong&gt; (Automatic Table Optimization)&lt;/td&gt;
        &lt;td&gt;Redshift가 Query Pattern을 분석하여 Distribution Key/Sort Key를 자동 최적화하는 기능&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Zero-ETL&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;Source Database → Data Warehouse로 데이터를 ETL Pipeline 없이 자동 복제하는 기능&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Dry Run&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;BigQuery에서 Query를 실행하지 않고 Scan량과 예상 비용만 미리 확인하는 기능. 무료&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;AQUA&lt;/strong&gt; (Advanced Query Accelerator)&lt;/td&gt;
        &lt;td&gt;Redshift RA3 Node에서 Storage Layer의 AWS 전용 Processor/FPGA로 사전 Filtering/Aggregation을 수행하는 가속기&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;Materialized View&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;Query 결과를 사전 계산하여 저장한 View. 반복 Query의 속도를 크게 개선&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;BI Engine&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;BigQuery의 In-memory Analysis Layer. Sub-second Response로 Dashboard를 가속&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;hr&gt;
        &lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;
        &lt;p&gt;Cloud Data Warehouse를 선택하는 일은 단순한 기술 비교가 아니다. 조직의 데이터 전략, 운영 문화, 그리고 장기적인 Cloud Roadmap에 깊이 관여하는 의사결정이다.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>블랙베리</title>
      <link>https://jojoldu.tistory.com/863</link>
      <guid>https://jojoldu.tistory.com/863</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;blockquote data-ke-style=&quot;style2&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://www.ctvnews.ca/business/article/jim-balsillie-sets-the-record-straight-on-blackberry-movie/&quot;&gt;짐 발실리가 영화 블랙베리에 대해 자신의 입장을 밝힌 인터뷰 기사&lt;/a&gt;도 함께 보면 더 재밌다.&lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;박소령 대표님의 실패를 통과하는 일을 다 보고, 이어서 넷플릭스에서 &lt;a href=&quot;https://www.netflix.com/kr/title/81725542&quot;&gt;블랙베리&lt;/a&gt;를 봤다.&lt;br&gt;2시간이 너무 짧았다.&lt;br&gt;더 깊게 이야기를 보고 싶었는데, 2시간 동안 십수 년의 기록을 담아두려니 생략된 이야기가 많아서 아쉬웠다.  &lt;/p&gt;
        &lt;p&gt;아쉬움과는 별개로 마음에 확 와닿는 대화 내용들이 몇 개 있었다.  &lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;더그 프레긴은 블랙베리 특유의 분위기를 계속해서 유지하려고 하며, 그와 같은 생각을 했던 마이크는 점점 기업의 CEO로 변해갔다.&lt;/p&gt;
        &lt;p&gt;베스트 프렌드이자 공동 창업자였던 더그 프레긴과 마이크 라자리디스의 대화다.  &lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style2&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;더그: &amp;quot;저거 봤어?&amp;quot;&lt;br&gt;마이크: &amp;quot;아니&amp;quot;&lt;br&gt;더그: &amp;quot;짐이 영화의 밤을 없앴어.&lt;br&gt;직접 할 배짱도 없어서 140kg 덩치를 불러서는 소리 지르고 다니게 했잖아.&lt;br&gt;앨런을 해고하겠다고 했대&amp;quot;&lt;br&gt;마이크: &amp;quot;... 일을 하긴 해야 해&amp;quot;&lt;br&gt;더그: &amp;quot;이 친구들이 일주일에 80시간을 기꺼이 일하는 이유를 알긴 해? 가족도 못 만나고, 인정도 못 받는데?&amp;quot;&lt;br&gt;마이크: &amp;quot;알지, 세계 최고의 휴대폰을 만들고 있으니까&amp;quot;&lt;br&gt;더그: &amp;quot;그래. 그런가 보다&amp;quot;&lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;스타트업에서는 일을 일처럼 보지 않는 문화가 많다.&lt;br&gt;그런 문화가 성과를 최적화하는 데는 방해가 된다.&lt;br&gt;그래서 조직이 커지다 보면 그런 문화가 점점 옅어지게 된다.  &lt;/p&gt;
        &lt;p&gt;반면에, 새로운 시도는 그런 문화 속에서 더 쉽게 시작할 수 있는 것 같다.&lt;br&gt;만약에 블랙베리가 일반적인 대기업으로 변해가지 않고, 위 문화를 유지했다면 아이폰의 등장을 어떻게 봤을까?&lt;br&gt;분해하고, 해체하고, 모방하고, 시도하고 그러면서 자연스레 블랙베리만의 스마트폰을 만들어가지 않았을까? 생각이 들었다.  &lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;아이폰의 발표 이후 투자자들의 기대를 충족시키기 위해 마이크는 공수표를 남발한다.&lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style2&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;마이크: &amp;quot;짐은 지금 워터루에 있어요.&lt;br&gt;다른 얘기는 하지 않기로 약속했는데, 아직 완성 단계는 아니지만 극비에 개발 중인 기술이 있거든요.&lt;br&gt;시제품이 나오려면 몇 주가 더 필요하지만.&lt;br&gt;큰 틀은 우리 블랙베리에요.&lt;br&gt;다만 여기 있는 키보드가 화면이에요.&lt;br&gt;전체가 다 스크린이죠.&lt;br&gt;대신 우리 제품은 이걸 누르면 그대로 경험할 수 있어요.&lt;br&gt;달칵하는 블랙베리의 키감을 느낄 수 있죠.&lt;br&gt;스크린, 키보드, 전화.&lt;br&gt;감이 오시나요?&amp;quot;  &lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;이 발표로 마이크는 &lt;strong&gt;버라이즌에 100만대를 판매&lt;/strong&gt;한다.  &lt;/p&gt;
        &lt;p&gt;그리고 몇 주 내 시제품을 보여줘야 하기 때문에 엔지니어링 팀에게 갑작스러운 요구 사항을 전달한다.&lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style2&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;마이크: &amp;quot;아니, 아니야 잘 들어.&lt;br&gt;스크린이긴 한데 내가 여기 쓴 대로 경첩이든 액추에이터든 다는 거야.&lt;br&gt;화면이랑 몸체 사이에.&lt;br&gt;그러면 화면을 누를 때마다 달칵거리겠지.&amp;quot;  &lt;/p&gt;
        &lt;p&gt;폴 스태노스: &amp;quot;이걸 왜 하는지 궁금해요&amp;quot;  &lt;/p&gt;
        &lt;p&gt;마이크: &amp;quot;지금 여기에서 그런 질문은 하면 안되지.&lt;br&gt;&amp;#39;왜&amp;#39; 는 몰라도 돼! 알겠어?&lt;br&gt;내가 하라잖아.&lt;br&gt;내가 이걸 팔았다고, 알겠어?&lt;br&gt;근데 누구야?&amp;quot;  &lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&amp;quot;&amp;#39;왜&amp;#39;는 몰라도 돼&amp;quot; 라는 말을 나는 몇 번을 했을까? 란 생각이 들었다.&lt;br&gt;스스로는 하지 않았다고 생각하지만, 막상 또 팀원들이 보기엔 표현 방식만 다를 뿐이지 같은 뜻으로 전달받기도 했겠지?  &lt;/p&gt;
        &lt;p&gt;해야 할 일을 당장 시작하기 위해서 설명을 하다가 나 스스로 설명을 포기하고 &amp;quot;일단 해&amp;quot;라고 얘기한 적은 없을까 기억을 많이 뒤적이게 된다.  &lt;/p&gt;
        &lt;p&gt;마이크는 점점 거대기업의 CEO가 되어간다.&lt;br&gt;블랙베리 초반, 팀이 풀지 못했던 엔지니어링 문제를 풀기 위해 데려왔던 구글 엔지니어링 팀장인 폴 스태노스를 더 이상 기억하지 못하기도 하는 장면이기도 했다.    &lt;/p&gt;
        &lt;p&gt;이 장면이 특히나 기억에 남았던 것은 영화 초반에 마이크는 짐에게 핸드폰을 더 판매하지 말아달라는 부탁을 했기 때문이다.  &lt;/p&gt;
        &lt;p&gt;현재 블랙베리의 완성도와 안정성을 위해 더 이상 판매하지 말고 물량을 조절해야 한다는 의견을 계속 피력한다.  &lt;/p&gt;
        &lt;p&gt;그랬던 마이크가 이제는 공수표를 남발하면서까지 세일즈를 한다.&lt;br&gt;납득할 수 없는 납기일과 사전에 얘기되지 않은 기능까지 요구하면서 결국은 고객이 등을 돌리게 만드는 제품을 출시하게 된다.  &lt;/p&gt;
        &lt;p&gt;마이크는 자신이 만든 제품에 대한 자부심이 강했기에 후발주자이자 블랙베리와 완전히 대척점에 선 제품인 아이폰을 용납할 수 없다.&lt;br&gt;그래서 같은 터치폰을 만드는 과정에서도 결코 &amp;#39;아이폰 같은&amp;#39; 이란 표현은 쓰지 않는다.&lt;br&gt;병적으로.&lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style2&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;더그: &amp;quot;정리하면 블랙베리만의 키감을 유지하면서 아이폰의 화면을 접목하면 돼.&lt;br&gt;그게 다야.&amp;quot;&lt;br&gt;마이크: &amp;quot;아니야, 그게 아니지!&lt;br&gt;애플의 무언가를 접목하는 게 아니야.&lt;br&gt;여러분 어려운 일이 아니야.&lt;br&gt;돈을 많이 받았잖아.&lt;br&gt;어렵지 않아.&lt;br&gt;결국 키보드야.&lt;br&gt;화면 위에 키보드.&lt;br&gt;어떻게 생각하든 상관 없어&amp;quot;&lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;
        &lt;p&gt;조화로워보였던 짐과 마이크의 협업도 점점 서로간의 방임으로 가기 시작했다.  &lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style2&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;팀원: &amp;quot;아이폰에 대한 소비자 기대치가 사상 최고를 기록했어요.&lt;br&gt;세계 1위 휴대폰에서 아이폰 이전 휴대폰이 되게 생겼다고요.&amp;quot;&lt;br&gt;짐: &amp;quot;괜찮아. 마이크가 해결할 거야&amp;quot;&lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-ke-style=&quot;style2&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;마이크: &amp;quot;증권 거래 위원회가 왜 우릴 조사해요? 스톡옵션 일이라던데&amp;quot;&lt;br&gt;짐: &amp;quot;별일 아닐 거예요&amp;quot;&lt;br&gt;마이크: &amp;quot;별일 아니에요?&amp;quot;&lt;br&gt;짐: &amp;quot;그럼요. 애플 일은 어때요? 우리 위험해요?&amp;quot;&lt;br&gt;마이크: &amp;quot;아뇨.&amp;quot;&lt;br&gt;짐: &amp;quot;어째서요?&amp;quot;&lt;br&gt;마이크: &amp;quot;기기당 데이터 사용량이 블랙베리 5,000대고 키보드도 없고 그냥 말이 안 되니까요.&amp;quot;&lt;br&gt;짐: &amp;quot;다들 우리가 끝났다고 떠들어 대는데요?&amp;quot;&lt;br&gt;마이크: &amp;quot;다들 멍청이거든요.&amp;quot;&lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;서로가 서로의 영역을 모니터링하지 않았다.&lt;br&gt;제품이 뒤처지고 있어도 &amp;quot;마이크가 알아서 하겠지&amp;quot;라고 생각했고,&lt;br&gt;세일즈가 무리한 약속을 해도 &amp;quot;짐이 알아서 하겠지&amp;quot;라고 넘겼다.&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;공동 CEO 체제의 장점은 전문성의 분담이지만, 단점은 책임의 분산&lt;/strong&gt;이다.&lt;br&gt;블랙베리에서는 그 단점이 극대화되었다.&lt;br&gt;서로의 영역에 간섭하지 않는 것이 &lt;strong&gt;신뢰&lt;/strong&gt;가 아니라 &lt;strong&gt;무관심&lt;/strong&gt;이 되어버린 것이다.  &lt;/p&gt;
        &lt;p&gt;만약 단일 CEO였다면 어땠을까?&lt;br&gt;영업과 제품 둘 다 문제가 있을 경우 둘 다 CEO가 강력하게 개입했을 것이다.  &lt;/p&gt;
        &lt;p&gt;각 분야별 C레벨이 있더라도 결국은 CEO가 최종적으로 결정을 내리는 구조로 갈 수밖에 없는 이유를 영화로 본 것 같았다.&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;레딧에서 흥미로운 질문을 봤다.&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/blackberry/comments/193rgt2/is_mike_or_jim_more_at_fault_for_the_fall_of/?tl=ko&quot;&gt;마이크와 짐 중에 블랙베리 몰락에 더 책임이 있는 사람은 누구일까?&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;같은 회사를 이끌면서도 서로 다른 꿈을 꾸고 있었다.&lt;/p&gt;
        &lt;p&gt;실제로 짐 발실리는 NHL 하키팀 인수에 집착하느라 회사 일에 소홀했다는 비판을 받는다.&lt;br&gt;피츠버그 펭귄스, 내슈빌 프레데터스, 피닉스 코요테스까지 세 번이나 팀 인수를 시도했고, 모두 실패했다.&lt;br&gt;2008~2010년 RIM에서 일했던 한 직원은 레딧에 이렇게 썼다.&lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style2&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;&amp;quot;짐은 하키팀 사는 데 너무 몰두해서 시장에서 눈을 떼버렸다.&lt;br&gt;나는 실리콘밸리에 살았는데, 아이폰에 대한 열광이 진짜라는 걸 봤다.&lt;br&gt;하지만 RIM 임원들은 그걸 믿지 않았다.&amp;quot;&lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;한편 마이크 라자리디스는 물리 키보드에 대한 자부심에 갇혀 터치스크린으로의 전환을 거부했다.&lt;br&gt;아이폰이 2007년 6월에 나왔는데, 블랙베리가 터치스크린 폰을 내놓은 건 짐 발실리가 경영에서 물러난 이후였다.  &lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;상호 보완적인 상위 레벨의 구조는 &amp;quot;역할 분담&amp;quot;만 있어서는 안 되고 &amp;quot;상호 이해&amp;quot;도 있어야 한다는 걸 새삼 느끼게 됐다.  &lt;/p&gt;
        &lt;p&gt;나와 대표님도 역할이 나뉘어 있다.&lt;br&gt;대표님은 비즈니스와 전략을, 나는 기술과 제품을 담당한다.&lt;br&gt;하지만 그것이 &lt;strong&gt;상호보완&lt;/strong&gt;이 되려면, 서로의 영역에 대한 관심과 이해가 필요하다.&lt;br&gt;&amp;quot;저건 대표님 영역이니까&amp;quot;, &amp;quot;저건 CTO 영역이니까&amp;quot;라고 선을 긋는 순간, 우리도 블랙베리처럼 동상이몽에 빠질 수 있다.  &lt;/p&gt;
        &lt;p&gt;역할만 나누고 이해가 없으면, 그건 그냥 &lt;strong&gt;분리&lt;/strong&gt;일 뿐이다.&lt;br&gt;블랙베리의 두 CEO는 역할은 완벽히 나눴지만, 상호 이해는 없었다.&lt;br&gt;그래서 위기가 왔을 때 서로를 도울 수 없었다.&lt;/p&gt;
        &lt;p&gt;기술 리더로서 비즈니스를 이해하려는 노력,&lt;br&gt;비즈니스 리더로서 기술을 이해하려는 노력,&lt;br&gt;이 양방향의 노력이 있어야 진정한 파트너십이 된다.&lt;br&gt;그렇지 않으면 &amp;quot;저 사람이 알아서 하겠지&amp;quot;라는 방치로 이어지고, 결국 조직 전체가 무너진다.  &lt;/p&gt;
        &lt;p&gt;요즘 회계 공부를 시작한 것도 그런 맥락이다.&lt;br&gt;기술만 잘하면 된다고 생각했던 때가 있었다.&lt;br&gt;하지만 대표님이 보는 숫자를 나도 읽을 수 있어야, 같은 그림을 보고 대화할 수 있다.&lt;br&gt;서로의 언어를 이해하려는 노력 없이는 결국 &amp;quot;마이크가 알아서 하겠지&amp;quot;, &amp;quot;짐이 알아서 하겠지&amp;quot;가 되어버린다.&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;역할을 나누되, 관심은 나누지 말아야 한다&lt;/strong&gt;.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>[SE-0507] Borrow and Mutate Accessors</title>
      <link>https://green1229.tistory.com/608</link>
      <guid>https://green1229.tistory.com/608</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;안녕하세요.&amp;nbsp;&lt;span style=&quot;color: #409d00;&quot;&gt;&lt;b&gt;그린&lt;/b&gt;&lt;/span&gt;입니다  &lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;이번 포스팅에서는&amp;nbsp;&lt;span style=&quot;background-color: #9feec3;&quot;&gt;&lt;b&gt;SE-0507 Borrow and Mutate Accessors&lt;/b&gt;&lt;/span&gt;에 대해 정리해보겠습니다  &lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&lt;figure class=&quot;imageblock alignCenter&quot; data-ke-mobileStyle=&quot;widthOrigin&quot; data-filename=&quot;123123213.001.jpeg&quot; data-origin-width=&quot;400&quot; data-origin-height=&quot;400&quot;&gt;&lt;span data-url=&quot;https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg&quot; data-phocus=&quot;https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg&quot;&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bMNm6h/dJMcacosInm/r4LBgOCIpNeSUcG0RWFlt1/img.jpg&quot; srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbMNm6h%2FdJMcacosInm%2Fr4LBgOCIpNeSUcG0RWFlt1%2Fimg.jpg&quot; onerror=&quot;this.onerror=null; this.src=&apos;//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png&apos;; this.srcset=&apos;//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png&apos;;&quot; loading=&quot;lazy&quot; width=&quot;400&quot; height=&quot;400&quot; data-filename=&quot;123123213.001.jpeg&quot; data-origin-width=&quot;400&quot; data-origin-height=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/figure&gt;
        &lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Intro&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Swift의 property accessor는 계속 발전중입니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;기존에는&amp;nbsp;get,&amp;nbsp;set, 그리고 최근 추가된&amp;nbsp;yielding borrow,&amp;nbsp;yielding mutate가 있었는데요.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style1&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;이번 SE-0507은 새로운&amp;nbsp;borrow와&amp;nbsp;mutate&amp;nbsp;accessor를 제안합니다.&lt;/span&gt;&lt;/blockquote&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;얘네들은&amp;nbsp;&lt;b&gt;borrowing semantics&lt;/b&gt;를 사용해서 복사 오버헤드 없이 값에 접근할 수 있고, yielding accessor보다 성능이 좋습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;특히 non-copyable 타입을 다루는 collection이나 성능이 중요한 저수준 데이터 구조에 유용할 거예요  &lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;현재 2026년 2월 9일까지 리뷰가 진행 중이긴한데 현 시점에서 Draft 상태라 계획대로 내일까지 반영될진 지켜봐야 알것 같아요.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;왜 필요한가?&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;blockquote data-ke-style=&quot;style1&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;기존 accessor들은 각각 한계가 있습니다.&lt;/span&gt;&lt;/blockquote&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;문제 1:&amp;nbsp;get은 복사해야 한다&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;get&amp;nbsp;accessor는 값을 복사하거나 새로 생성해서 반환해야 합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;복사의 코스트가 많이 들거나 불가능한 경우엔 쓸 수 없죠.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot;&gt;&lt;code&gt;struct NC: ~Copyable { ... }
        struct ContainerOfNoncopyable {
        private var _element: NC
        var element: Element {
        return _element //   ERROR: Cannot copy `_element`
        }
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Non-copyable 값을 저장하는 collection은 subscript에&amp;nbsp;get을 쓸 수 없습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;문제 2: yielding accessor는 오버헤드가 크다&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;yielding mutate와&amp;nbsp;yielding borrow는 coroutine을 사용합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;접근 전후로 코드를 실행할 수 있어서 유연하지만, 그만큼 오버헤드가 있습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;ul style=&quot;list-style-type: disc; color: #000000; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Coroutine을 위한 메모리 할당&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;여러 번의 함수 호출&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;접근 scope가 제한됨 (함수가 끝나기 전에 완료되어야 함)&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot;&gt;&lt;code&gt;struct Element: ~Copyable {
        var span: Span&amp;lt;...&amp;gt; { ... }
        }
        
        struct Wrapper: ~Copyable {
        private var _element: Element
        var element: Element {
        yielding borrow { // ❗️Note: Using `yielding borrow` accessor
        yield _element
        }
        }
        }
        
        func getSpan(wrapper: borrowing Wrapper) -&amp;gt; Span&amp;lt;...&amp;gt; {
        // Because we&apos;re reading `element` from a yielding accessor,
        // its access must finish before `getSpan` returns.
        // But `span` cannot outlive `element`, so ...
        
        //   ERROR: lifetime-dependent value escapes its scope
        return wrapper.element.span
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Borrowing accessor는 이 두 문제를 모두 해결합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;제안된 솔루션&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;blockquote data-ke-style=&quot;style1&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;새로운&amp;nbsp;borrow와&amp;nbsp;mutate&amp;nbsp;키워드로 accessor를 정의합니다.&lt;/span&gt;&lt;/blockquote&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;struct RigidWrapper&amp;lt;Element: ~Copyable&amp;gt;: ~Copyable {
        var _element: Element
        var element: Element {
        borrow {
        return _element
        }
        mutate {
        return &amp;amp;_element
        }
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;ul style=&quot;list-style-type: disc; color: #000000; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;borrow: 읽기 전용 접근, 복사하지 않음&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;mutate: 읽기/쓰기 접근,&amp;nbsp;&amp;amp;로 mutable reference 반환&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;yield&amp;nbsp;대신&amp;nbsp;return을 쓰는 게 차이점입니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;물론 single expression이면&amp;nbsp;return&amp;nbsp;키워드는 생략 가능합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;상세 설계&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;반환 값의 제약&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Borrowing accessor는&amp;nbsp;&lt;b&gt;저장된 값&lt;/b&gt;만 반환할 수 있습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;local이나 temporary 값은 반환할 수 없어요.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;struct InvalidExamples {
        var _array : [Int]
        
        var local: [Int] {
        borrow {
        let foo = [1, 2, 3]
        //   ERROR: Cannot return local value from borrow accessor
        return foo
        }
        }
        
        var temporary: [Int]? {
        borrow {
        // This would require creating a temporary local
        // optional array from `_array`.
        //   ERROR: Cannot return temporary value from borrow accessor
        return _array
        }
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;반환하는 값은 accessor 실행이 끝난 후에도 유효해야 합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;사용 방법&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;borrow로 읽기&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;클라이언트 코드는 기존&amp;nbsp;get과 동일하게 보이지만, 내부적으로는 복사가 일어나지 않습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;var owner = Wrapper(value)
        
        // &quot;borrow&quot; the value to give to a function
        // without copying...
        doSomething(with: owner.element)
        
        func doSomething(with value: borrowing Element) {
        // `value` is borrowed, so this invokes
        // the method &quot;in-place&quot;
        value.someMethod() 
        
        // Exclusivity prevents the owner from being
        // mutated while `value` is alive:
        owner.mutatingMethod() //   ERROR
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;메모리 일관성을 위해 Swift의 exclusivity rule이 적용됩니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;borrow가 활성화된 동안엔 owner를 변경할 수 없어요.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;mutate로 수정하기&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;mutate&amp;nbsp;accessor는 읽기/쓰기 접근을 제공합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;var owner = Wrapper(value)
        
        // Mutating/inout access will invoke the `mutate` accessor
        doSomething(with: &amp;amp;owner.element)
        
        func doSomeMutation(with value: inout Element) {
        // So this invokes a method on the value &quot;in-place&quot;
        // Because you borrowed for mutation, this can be
        // a mutating method.
        value.someMutatingMethod()
        
        // Accessing the owner is an exclusivity violation
        owner.anyMethod() //   ERROR
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;다른 accessor와의 호환성&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;mutate를 제공하면&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;ul style=&quot;list-style-type: disc; color: #000000; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;borrow도 반드시 제공해야 함&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;yielding mutate나&amp;nbsp;yielding borrow는 사용 불가&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Swift는 일반적으로 write-only property를 허용하지 않습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;또한 읽기와 쓰기 작업의 접근 scope를 일관되게 유지해야 합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;borrow를 제공하면&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;ul style=&quot;list-style-type: disc; color: #000000; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;get이나&amp;nbsp;yielding borrow는 사용 불가&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;blockquote data-ke-style=&quot;style1&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;여러 read accessor나 여러 write accessor를 동시에 정의하면 호출자 입장에서 혼란스럽기 때문입니다.&lt;/span&gt;&lt;/blockquote&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Ownership 변형&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;기본적으로 아래와 같아요.&lt;/span&gt;&lt;/p&gt;
        &lt;ul style=&quot;list-style-type: disc; color: #000000; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;borrow: 포함하는 값을 변경하지 않음&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;mutate: 포함하는 값을 변경함&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;이걸&amp;nbsp;mutating이나&amp;nbsp;nonmutating&amp;nbsp;키워드로 오버라이드할 수 있습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;mutating borrow&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;읽기 전용이지만 side-effect로 인해 포함하는 값이 변경될 수 있는 경우입니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;struct S1 {
        private var cachedValue: Foo
        var foo : Foo {
        mutating borrow {
        if !cachedValue.available {
        // Update `cachedValue`
        // Compiler allows such update
        // because this is `mutating`
        }
        return cachedValue
        }
        }
        }
        
        let s1: S1 // Note: Immutable value
        s1.foo //   Cannot use mutating accessor on immutable value&lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;캐시를 업데이트하는 경우 같은 거죠.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;nonmutating mutate&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;값을 변경할 수 있지만 부모 값의 변경으로 간주되지 않는 경우입니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;struct Outer {
        var inner: InnerType {
        borrow {
        return some_value_stored_elsewhere
        }
        nonmutating mutate {
        return &amp;amp;some_value_stored_elsewhere
        }
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;외부에 저장된 값에 접근하는 경우 같은 거예요.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Protocol requirement로 사용&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Protocol에서도 borrowing accessor를 요구할 수 있습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot;&gt;&lt;code&gt;protocol BorrowingAccess {
        associatedtype Element
        var element: Element { borrow mutate }
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;이는 두 가지 기능이 있어요.&lt;/span&gt;&lt;/p&gt;
        &lt;ol style=&quot;list-style-type: decimal; color: #000000; text-align: start;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Protocol을 통한 접근 방식을 제어 (existential이나 generic argument에서)&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;conforming 타입에 해당 accessor가 있어야 함 (명시적 구현 또는 컴파일러 합성)&lt;/span&gt;&lt;/li&gt;
        &lt;/ol&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;컴파일러 합성&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;ul style=&quot;list-style-type: disc; color: #000000; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Stored property &amp;rarr;&amp;nbsp;borrow,&amp;nbsp;mutate&amp;nbsp;합성 가능&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;borrow&amp;nbsp;구현 &amp;rarr;&amp;nbsp;yielding borrow나&amp;nbsp;get&amp;nbsp;합성 가능 (copyable만)&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;mutate&amp;nbsp;구현 &amp;rarr;&amp;nbsp;set이나&amp;nbsp;yielding mutate&amp;nbsp;합성 가능&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;제약사항&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;ul style=&quot;list-style-type: disc; color: #000000; text-align: start;&quot; data-ke-list-type=&quot;disc&quot;&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Protocol이&amp;nbsp;borrow&amp;nbsp;요구 &amp;rarr; conforming 타입도&amp;nbsp;borrow&amp;nbsp;필요&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Protocol이&amp;nbsp;mutate&amp;nbsp;요구 &amp;rarr; conforming 타입은&amp;nbsp;borrow와&amp;nbsp;mutate&amp;nbsp;모두 필요&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Class와 Actor에서는 불가&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Class는 property 접근 전후로 runtime exclusivity check를 실행해야 합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Borrowing accessor는 접근 후에 코드를 실행할 방법이 없어서 class property에는 사용할 수 없습니다.&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;yielding borrow와&amp;nbsp;yielding mutate는 class property에 사용 가능합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Subscript에도 사용 가능&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;struct ArrayLikeType {
        subscript(index: Int) -&amp;gt; Element {
        borrow { .... }
        mutate { .... }
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;다만 subscript는 전체 struct를 암묵적으로 접근하므로, 아래 코드는 불가능해요.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;var x: ArrayLikeType
        swap(&amp;amp;x[0], &amp;amp;x[1]) //   두 개의 mutating access&lt;/code&gt;&lt;/pre&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;호환성&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Source compatibility&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;기존에&amp;nbsp;borrow나&amp;nbsp;mutate라는 이름의 함수를 trailing closure로 호출하는 경우와 충돌 가능성이 있습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot;&gt;&lt;code&gt;struct S {
        func borrow(closure: () -&amp;gt; ()) { ... }
        // Is this a new borrow accessor?
        // Or a call to the borrow method just above?
        var property: Int { borrow { ... } }
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;하지만 실제로는 거의 발생하지 않을 것으로 봅니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;ABI compatibility&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;새로운 기능이라 기존 ABI에는 영향이 없습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Adoption 영향&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Non-borrowing accessor를 borrowing accessor로 바꾸는 건 일반적으로&amp;nbsp;&lt;b&gt;ABI-breaking&lt;/b&gt;입니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;하지만 existential type의 ABI는 보존됩니다. (컴파일러가 계속 accessor를 합성할 수 있다면)&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Source-breaking일 수도 있습니다. 특히&amp;nbsp;get을&amp;nbsp;borrow로 바꾸면 lifetime 제약이 생겨서 기존 코드가 컴파일되지 않을 수 있어요.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;향후 방향성&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Borrowing returns&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;함수에서도 borrowed 값을 반환할 수 있으면 유용합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;struct S&amp;lt;Value&amp;gt; {
        subscript(_ index: Int) -&amp;gt; Value {
        borrow { ... }
        }
        func indirect(_ parameter: Foo) -&amp;gt; borrowing Value {
        let index = ... compute index from parameter ...
        return self[index]
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style6&quot; /&gt;
        &lt;h3 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size23&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Unsafe pointer를 통한 borrowing&lt;/b&gt;&lt;/span&gt;&lt;/h3&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;저수준 데이터 구조는 종종 unsafe pointer를 사용합니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;var _storage: UnsafePointer&amp;lt;Element&amp;gt;
        
        var first: Element {
        borrow {
        // ERROR: borrow accessors can only return stored properties
        // or computed properties that have borrow accessors
        return _storage.pointee
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;이런 케이스를 지원하려면 뭔가 annotation이 필요할 것 같습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;pre class=&quot;swift&quot; style=&quot;color: #000000; text-align: start;&quot; data-ke-language=&quot;swift&quot;&gt;&lt;code&gt;var first: Element {
        borrow {
        return unsafeResultDependsOnSelf(_storage.pointee)
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;나왔던 대안&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;아무것도 하지 않기?&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Yielding coroutine-based accessor도 비슷한 기능을 제공하지만, 성능 특성이 다릅니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Coroutine accessor는 접근 후에 코드를 실행할 수 있어서 의미론적으로는 더 강력하지만, 완전히 inline되지 않으면 여러 함수 호출 오버헤드가 있습니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p data-ke-size=&quot;size16&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Borrowing accessor는 여러 함수 호출 오버헤드 없이 in-place mutation 기능을 제공합니다.&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;Conclusion&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;특히나 유용한 제안이라고 생각되는 포인트는 non-copyable 타입을 다루는 collection이나 성능이 중요한 저수준 코드에서 큰 도움이 될 것 같아요.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;get의 복사 오버헤드와 yielding accessor의 coroutine 오버헤드 사이의 sweet spot을 찾은 느낌입니다.&lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;Swift Standard Library 팀에서도 이 기능을 원했다고 하니, 실무에서 정말 필요한 기능인 것 같네요  &lt;/span&gt;&lt;/p&gt;
        &lt;p style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size18&quot;&gt;&amp;nbsp;&lt;/p&gt;
        &lt;hr contenteditable=&quot;false&quot; data-ke-type=&quot;horizontalRule&quot; data-ke-style=&quot;style5&quot; /&gt;
        &lt;h2 style=&quot;color: #000000; text-align: start;&quot; data-ke-size=&quot;size26&quot;&gt;&lt;span style=&quot;font-family: &apos;Nanum Gothic&apos;; color: #000000;&quot;&gt;&lt;b&gt;References&lt;/b&gt;&lt;/span&gt;&lt;/h2&gt;
        &lt;figure id=&quot;og_1770505989159&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;object&quot; data-og-title=&quot;swift-evolution/proposals/0507-borrow-accessors.md at main &amp;middot; swiftlang/swift-evolution&quot; data-og-description=&quot;This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution&quot; data-og-host=&quot;github.com&quot; data-og-source-url=&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md&quot; data-og-url=&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/ctPukB/dJMb9dHjFxz/rPnfoqlUZ4qumwRqATtnpk/img.png?width=1200&amp;amp;height=600&amp;amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/bdORDD/dJMb9fZqV5N/AkOXRj8eXvJSDwE9R37zz0/img.png?width=1200&amp;amp;height=600&amp;amp;face=0_0_1200_600&quot;&gt;&lt;a href=&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md&quot;&gt;
        &lt;div class=&quot;og-image&quot; style=&quot;background-image: url(&apos;https://scrap.kakaocdn.net/dn/ctPukB/dJMb9dHjFxz/rPnfoqlUZ4qumwRqATtnpk/img.png?width=1200&amp;amp;height=600&amp;amp;face=0_0_1200_600,https://scrap.kakaocdn.net/dn/bdORDD/dJMb9fZqV5N/AkOXRj8eXvJSDwE9R37zz0/img.png?width=1200&amp;amp;height=600&amp;amp;face=0_0_1200_600&apos;);&quot;&gt;&amp;nbsp;&lt;/div&gt;
        &lt;div class=&quot;og-text&quot;&gt;
        &lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;swift-evolution/proposals/0507-borrow-accessors.md at main &amp;middot; swiftlang/swift-evolution&lt;/p&gt;
        &lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;This maintains proposals for changes and user-visible enhancements to the Swift Programming Language. - swiftlang/swift-evolution&lt;/p&gt;
        &lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;github.com&lt;/p&gt;
        &lt;/div&gt;
        &lt;/a&gt;&lt;/figure&gt;
        &lt;figure id=&quot;og_1770505992248&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;[Pitch] Borrowing Accessors&quot; data-og-description=&quot;I just put up the draft proposal for Borrowing Accessors, which together with Yielding Accessors completes the full suite of accessor support described in the Prospective Vision for Accessors. More complete details are in the draft proposal. The following &quot; data-og-host=&quot;forums.swift.org&quot; data-og-source-url=&quot;https://forums.swift.org/t/pitch-borrowing-accessors/83933&quot; data-og-url=&quot;https://forums.swift.org/t/pitch-borrowing-accessors/83933&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/bmTS6N/dJMb86nTaz5/thh0HrQh32roiksV5DQfb1/img.png?width=590&amp;amp;height=585&amp;amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/INQ8e/dJMb8TB5b1Y/vKaE9NKcC5Hx35h96ojMJk/img.png?width=151&amp;amp;height=150&amp;amp;face=0_0_151_150&quot;&gt;&lt;a href=&quot;https://forums.swift.org/t/pitch-borrowing-accessors/83933&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://forums.swift.org/t/pitch-borrowing-accessors/83933&quot;&gt;
        &lt;div class=&quot;og-image&quot; style=&quot;background-image: url(&apos;https://scrap.kakaocdn.net/dn/bmTS6N/dJMb86nTaz5/thh0HrQh32roiksV5DQfb1/img.png?width=590&amp;amp;height=585&amp;amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/INQ8e/dJMb8TB5b1Y/vKaE9NKcC5Hx35h96ojMJk/img.png?width=151&amp;amp;height=150&amp;amp;face=0_0_151_150&apos;);&quot;&gt;&amp;nbsp;&lt;/div&gt;
        &lt;div class=&quot;og-text&quot;&gt;
        &lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;[Pitch] Borrowing Accessors&lt;/p&gt;
        &lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;I just put up the draft proposal for Borrowing Accessors, which together with Yielding Accessors completes the full suite of accessor support described in the Prospective Vision for Accessors. More complete details are in the draft proposal. The following&lt;/p&gt;
        &lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;forums.swift.org&lt;/p&gt;
        &lt;/div&gt;
        &lt;/a&gt;&lt;/figure&gt;
        &lt;figure id=&quot;og_1770505992871&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;SE-0507: Borrow and Mutate Accessors&quot; data-og-description=&quot;Hi everyone, The review of SE-0507 &amp;quot;Borrow and Mutate Accessors&amp;quot; begins now and runs through February 9, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would like to &quot; data-og-host=&quot;forums.swift.org&quot; data-og-source-url=&quot;https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376&quot; data-og-url=&quot;https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/ArLsY/dJMb9jgsO0V/MaREBk3jT8n59WyTYrLSaK/img.png?width=590&amp;amp;height=585&amp;amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/Vkdgg/dJMb9iICK3v/lMt6Y2eKRhuCzg7lQKTBMK/img.png?width=151&amp;amp;height=150&amp;amp;face=0_0_151_150&quot;&gt;&lt;a href=&quot;https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376&quot;&gt;
        &lt;div class=&quot;og-image&quot; style=&quot;background-image: url(&apos;https://scrap.kakaocdn.net/dn/ArLsY/dJMb9jgsO0V/MaREBk3jT8n59WyTYrLSaK/img.png?width=590&amp;amp;height=585&amp;amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/Vkdgg/dJMb9iICK3v/lMt6Y2eKRhuCzg7lQKTBMK/img.png?width=151&amp;amp;height=150&amp;amp;face=0_0_151_150&apos;);&quot;&gt;&amp;nbsp;&lt;/div&gt;
        &lt;div class=&quot;og-text&quot;&gt;
        &lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;SE-0507: Borrow and Mutate Accessors&lt;/p&gt;
        &lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;Hi everyone, The review of SE-0507 &quot;Borrow and Mutate Accessors&quot; begins now and runs through February 9, 2026. Reviews are an important part of the Swift evolution process. All review feedback should be either on this forum thread or, if you would like to&lt;/p&gt;
        &lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;forums.swift.org&lt;/p&gt;
        &lt;/div&gt;
        &lt;/a&gt;&lt;/figure&gt;
        &lt;figure id=&quot;og_1770505993582&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot; data-ke-align=&quot;alignCenter&quot; data-og-type=&quot;website&quot; data-og-title=&quot;[Prospective Vision] Accessors&quot; data-og-description=&quot;Hello, Swift Community. The Language Steering Group would like to gather feedback on a prospective vision for accessors in Swift. Vision documents help describe an overall direction for Swift. The actual Swift changes for executing on the vision will come &quot; data-og-host=&quot;forums.swift.org&quot; data-og-source-url=&quot;https://forums.swift.org/t/prospective-vision-accessors/76707&quot; data-og-url=&quot;https://forums.swift.org/t/prospective-vision-accessors/76707&quot; data-og-image=&quot;https://scrap.kakaocdn.net/dn/Uj5X6/dJMb9iICK3w/nC3pXJNA1Q0nU5Y6KbMHwk/img.png?width=590&amp;amp;height=585&amp;amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cTf3MU/dJMb9jgsO0W/66gUNcaH9jsd7hOeewxwp0/img.png?width=151&amp;amp;height=150&amp;amp;face=0_0_151_150&quot;&gt;&lt;a href=&quot;https://forums.swift.org/t/prospective-vision-accessors/76707&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-source-url=&quot;https://forums.swift.org/t/prospective-vision-accessors/76707&quot;&gt;
        &lt;div class=&quot;og-image&quot; style=&quot;background-image: url(&apos;https://scrap.kakaocdn.net/dn/Uj5X6/dJMb9iICK3w/nC3pXJNA1Q0nU5Y6KbMHwk/img.png?width=590&amp;amp;height=585&amp;amp;face=0_0_590_585,https://scrap.kakaocdn.net/dn/cTf3MU/dJMb9jgsO0W/66gUNcaH9jsd7hOeewxwp0/img.png?width=151&amp;amp;height=150&amp;amp;face=0_0_151_150&apos;);&quot;&gt;&amp;nbsp;&lt;/div&gt;
        &lt;div class=&quot;og-text&quot;&gt;
        &lt;p class=&quot;og-title&quot; data-ke-size=&quot;size16&quot;&gt;[Prospective Vision] Accessors&lt;/p&gt;
        &lt;p class=&quot;og-desc&quot; data-ke-size=&quot;size16&quot;&gt;Hello, Swift Community. The Language Steering Group would like to gather feedback on a prospective vision for accessors in Swift. Vision documents help describe an overall direction for Swift. The actual Swift changes for executing on the vision will come&lt;/p&gt;
        &lt;p class=&quot;og-host&quot; data-ke-size=&quot;size16&quot;&gt;forums.swift.org&lt;/p&gt;
        &lt;/div&gt;
        &lt;/a&gt;&lt;/figure&gt;
      </content:encoded>
    </item>
    <item>
      <title>언론사 망하게 하는 AI 봇 개발기</title>
      <link>https://rainygirl.github.io/2026/02/rspeaker</link>
      <guid>https://rainygirl.github.io/2026/02/rspeaker</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;코딩 대신해주는 AI 등장 이후 개발자들은 다 굶어 죽을거라는 둥, 직원을 다 잘라도 사장 혼자 사업을 해도 된다는 둥 하는 FOMO(놓치는 것에 대한 두려움) 기사가 워낙 흥하다 보니 나도 FOMO 스러운 제목을 적어보았다. ‘언론사 망하게 하는 AI 봇’ 을 만들었다고.&lt;/p&gt;
        
        &lt;p&gt;반은 뻥이다. 그리고 반은 진담이다.&lt;/p&gt;
        
        &lt;hr /&gt;
        
        &lt;p&gt;2026년 2월 9일, 음성인식 AI모델이 오픈소스로 풀렸다는 소식을 들었다. 사람 말귀를 알아 듣는 스마트 스피커를 나도 쉽게 만들 수 있겠구나 라고 생각했다. 명령어 한 줄 만으로도 데모가 실행되었는데, 꽤 그럴싸하게 한국어와 일본어, 영어 발음을 인식했다. 다음날, MacOS에 내장된 음성인식 엔진을 가져다 써도 쓸만하다는 평을 들었다. 성능이 어느 정도인지 궁금해서 Claude AI에게 이 엔진으로 음성을 인식해 프린트하는 프로그램을 만들어달라고 했다. AI 모델이 아니어도 꽤 그럴싸하게 한국어를 인식하는 것을 확인했다. 로컬에서도 돌아가는 이 엔진을 쓰면 비용도 덜 들고 속도도 빠르겠구나…라고 생각했다. 그렇게, 간단히 ‘지금 몇시야?’ 같은 질문에 TTS로 대답을 하는 코드를 덧붙였다. 나와 목소리로 대화할 수 있는 대화 봇을 만든 것이다.&lt;/p&gt;
        
        &lt;p&gt;그 때, Claude AI에게 한가지 프롬프트를 더 얹었다.&lt;/p&gt;
        
        &lt;p&gt;“오늘의 뉴스를 물어보면 오늘의 뉴스를 요약해서 읽어줘.”&lt;/p&gt;
        
        &lt;p&gt;30여초 뒤, 수십여개의 신문사와 방송사를 사라지게 할 수 있는 봇이 탄생했다.&lt;/p&gt;
        
        &lt;h1 id=&quot;일단-구경하시라&quot;&gt;일단 구경하시라&lt;/h1&gt;
        
        &lt;p&gt;이 글은 인터넷에 올라온 하이퍼미디어 글이다. 글을 읽다가 동영상을 볼 수도 있다는 의미이다. 일단 봇의 작동장면을 5분간 시청해보자.&lt;/p&gt;
        
        &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/38ewaWdLZKk?si=de-i6wt9SXbYz50T&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
        
        &lt;p&gt;요약된 뉴스는 4~5분 가량이고, 이정도면 지상파 방송 라디오 정시 뉴스 길이와 비슷하다. 문장이 매끄럽지 못한 부분은 몇 달 지나면 개선될 것이고, 중요 뉴스는 충분히 설명하기 때문에 이미 원하는 기능은 모두 구현되었다고 판단되었다. 라디오 정시 뉴스와 품질도 비슷하다.&lt;/p&gt;
        
        &lt;p&gt;음성인식은 MacOS 에서 기본적으로 제공하는 &lt;a href=&quot;https://developer.apple.com/documentation/speech/sfspeechrecognizer&quot;&gt;SFSpeechRecognizer&lt;/a&gt; 프레임워크를 이용했다. 루프를 돌면서 마이크로 들어오는 사람의 목소리를 인식하는 프레임워크이다. ‘오늘의 뉴스’ 라고 외치는 것은 다음 작동을 위한 트리거에 불과하다. 원래 파이썬에서 만들기 쉬웠던 프레임워크이고, AI에게 시켜서 만들기도 쉽다. 이 프레임워크의 존재는 이 글의 주제는 아니다.&lt;/p&gt;
        
        &lt;p&gt;스피커로 대답을 하기 위해 쓰는 TTS 역시 MacOS 에서 기본적으로 제공한다. 터미널에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;say -v Yuna &quot;안녕하세요&quot;&lt;/code&gt; 라고 치면 안녕하세요 라는 목소리가 스피커에서 흘러나올 것이다. 이 목소리보다 마이크로소프트의 MS Edge TTS가 더 자연스러워서 이걸 쓰기로 했다. 파이썬에는 이미 &lt;a href=&quot;https://pypi.org/project/edge-tts/&quot;&gt;Edge TTS&lt;/a&gt; 패키지가 존재한다. 쉽게 가져다 쓸 수 있다는 이야기이다. 이 패키지도 이 글의 주제는 아니다.&lt;/p&gt;
        
        &lt;p&gt;‘오늘의 뉴스’라는 음성이 트리거링되었을 때, 파이썬 코드는 &lt;a href=&quot;https://news.google.com/rss?hl=ko&amp;amp;gl=KR&amp;amp;ceid=KR:ko&quot;&gt;구글 뉴스 RSS&lt;/a&gt;에서 최신 뉴스를 가져온다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/RSS&quot;&gt;RSS&lt;/a&gt;는 Really Simple Syndication의 약자. 20여년 전부터 쓰여온 콘텐츠 전달 포맷이다. 각 언론사도 자사 사이트에서 RSS를 제공한다. 그리고 구글 뉴스는 전 세계의 언론사로부터 뉴스를 공급받아 목록을 제공한다. 그래서 Claude AI는 특별히 어떤 언론사를 지목하지 않고 구글 뉴스를 쓰기로 결정했던 모양이다. 이것도 개발일을 해온 입장에선 어렵지 않은 일이다.&lt;/p&gt;
        
        &lt;p&gt;기사 요약은 언론사 사이트를 읽은 뒤 Gemini 에게 내용을 요약해달라고 시켰다. AI학습 금지 조항을 달아둔 언론사들도 있지만 기계적인 차단장치를 걸어둔 곳은 국내에는 그리 많지 않았다. 반면 해외 매체는 프로그래밍적 접근이 문제가 아니라 아예 페이월(Paywall - 돈을 내야 볼 수 있는 잠금화면)이 걸려있다.&lt;/p&gt;
        
        &lt;p&gt;구글 뉴스는 알고리즘을 통해 중요 뉴스를 배치한다. 여기서 언론사 크레딧은 그다지 중요하지 않다. 기사 주인이 조선일보든 한겨레든 MBN이든 KBS든 알 바 아니다.
        거의 모든 언론사들이 같은 주제로 기사를 써내려가고 있고, 비슷비슷한 기사는 그 아젠다의 중요성에 가중치를 부여하는 역할로만 알고리즘에서 기여한다.
        각 뉴스의 제호는 프롬프트에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;언론사 이름은 읽지는 마&lt;/code&gt; 라는 한 문장으로 쉽게 제거된다.
        그리고, 아무리 자세하게 기자가 글에 살을 붙였다 한들, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4~6문장으로 요약해&lt;/code&gt; 라는 프롬프트만으로 기자가 정성스레 덧붙인 코멘트는 소거된다.&lt;/p&gt;
        
        &lt;p&gt;군더더기 버그를 고쳐달라는 프롬프트를 제외하면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;말 귀를 알아듣는 음성인식 봇을 만들어줘&lt;/code&gt; 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오늘의 뉴스를 물어보면 오늘의 뉴스를 요약해서 읽어줘&lt;/code&gt; 두 가지만 Claude AI에게 물어보았더니 4~5분 가량의 개인용 실시간 오디오 뉴스가 탄생했다.&lt;/p&gt;
        
        &lt;p&gt;상품화를 못할거라고? 요즘 알리익스프레스는 설명서를 포함한 오픈소스 키트를 묶어 판다. 3D프린터로 조립된 케이스 안에 부품을 조립해 넣고 USB 로 소프트웨어를 주입하면 알아서 돌아가는 식이다.&lt;/p&gt;
        
        &lt;h1 id=&quot;꼴-좋다고-비웃던-사이에&quot;&gt;꼴 좋다고 비웃던 사이에&lt;/h1&gt;
        
        &lt;p&gt;자 이제, 방송사 뉴스는 뭐하러 듣고, 신문사 기사는 뭐하러 봐야하는가?&lt;/p&gt;
        
        &lt;p&gt;뉴스에 관점을 붙여온 기자는 이제 어디로 가야하는가? LLM이 문장을 대신 쓰고 있다.&lt;/p&gt;
        
        &lt;p&gt;뉴스를 고르는 데스크는 이제 어디로 가야하는가? 알고리즘이 데스킹을 대신하고 있다.&lt;/p&gt;
        
        &lt;p&gt;뉴스를 읽는 아나운서는 이제 어디로 가야하는가? TTS가 뉴스를 대신 읽고 있다.&lt;/p&gt;
        
        &lt;p&gt;뉴스를 틀어주는 방송사는 어디로 가야하는가? 인터넷이 알아서 뉴스를 배달하고 있다.&lt;/p&gt;
        
        &lt;p&gt;뉴스를 만드는 언론사는 어디로 가야하는가? AI가 알아서…&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://rainygirl.github.io/2018/04/macro-program-ask-you&quot;&gt;프로그래밍된 동작이 인간의 동작을 대체하고 있다고 2018년 칼럼에 썼었다&lt;/a&gt;. 누군가의 일자리를 빼앗지 못하면 혁신이 아니라는 구호가 스타트업 업계에 팽배하던 시절도 지나갔다. AI 등장 이후 진짜로 여기저기 일자리를 빼앗을 수 있다는 곡소리가 나온다. 하필 ‘고액 연봉 개발자들 이제 쪽박 찬다’는 FOMO 기사를 수많은 언론들이 쏟아냈다. 그런데 이번에는 그 언론사들도 존립이 위태로운 형국이다. AI가 뉴스를 대신 요약하면서 언론사 사이트 방문자수가 급감했다는 소식이 심심치 않게 들려온다.&lt;/p&gt;
        
        &lt;p&gt;꼴 좋다고 비웃는 사람들이 있었다. 언론사가 언론사답지 못하다는 힐난이야 50여년 전부터 내려온 것이긴 하다. 황색저널리즘 이야기도 있었다. 30여년 전 쯤부터 지하철역 입구에 무가지가 배치되면서 신문 안 읽는 세상이라고 혀를 차는 이들도 있었다. 그러다 20여년 전부터 포털 사이트를 통해 조각조각난 뉴스를 보는 사람들이 전체 뉴스 소비자의 대부분이 되어버렸다. 방송 뉴스도 45분 가까이 되는 뉴스편성이 포털에서 3분 단위로 조각조각나고 스탠딩 멘트는 스크립트로 따여져 텍스트로 재가공되었다. 제호 아래의 1면 배치로 권력을 휘두르던 신문 권력과 메인 뉴스 첫꼭지 배치로 권력을 휘두르던 방송 권력이 물러갔다며 좋아하는 사람들도 있었다. 레거시 미디어라는 용어가 한국어로 ‘재래식 언론’으로 바뀌더니 언제부터인가 조롱의 언어로 쓰이고 있다.&lt;/p&gt;
        
        &lt;p&gt;솔직히 AI 앞에서 남 밥그릇 사라지는 일에 즐거워하던 기사들을 떠올리면 나도 니들 꼴 좋다고 비아냥거리고 싶은 마음이 아른거리긴 한다. 하지만, 정말 꼴 좋다고 비웃어도 될 일인가? 빈 자리는 저마다 내편을 찾는 유투버들이 새로운 언론인을 자처하며 저마다의 부족을 만들어냈다. &lt;a href=&quot;https://www.youtube.com/watch?v=7GPZhCEgWjY&quot;&gt;일론 머스크는 공영방송이 쓰레기라며 NPR의 예산을 끊으라 했고, 트럼프 정부는 정말로 예산을 끊어 PBS와 NPR을 문닫게 했다.&lt;/a&gt; 그 결과 &lt;a href=&quot;https://www.wired.com/story/turning-point-usas-halftime-show-was-exactly-what-youd-expect/&quot;&gt;2026년 슈퍼볼 하프타임 공연은 두 쪽이 났다.&lt;/a&gt; 남의 나라 이야기인가? 한국도 “우리는 유튜브만 믿어! 유튜브가 진실이야!”가 구호로 등장한다.&lt;/p&gt;
        
        &lt;p&gt;&lt;img src=&quot;/images/2026-02-10-youtube.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
        
        &lt;p&gt;그래서 그 결과는 어떠한가? 릴스 쇼츠는 극우선전에 잠식되었고, 좌파 부모에게서 우파 청년이 탄생했다고 어디서는 폭죽을 터트린다. 그렇게 대화가 단절되고, 나의 일상에서 안전이 위협을 받기 시작한다. 꼴 좋다고 비웃고 넘어간 댓가는 아닌지?&lt;/p&gt;
        
        &lt;h1 id=&quot;저널리즘-그-너머에&quot;&gt;저널리즘 그 너머에&lt;/h1&gt;
        
        &lt;p&gt;사회의 합의를 이끌어내는 공론장은 민주주의 사회에서 언제나 필요하고, 공공의 아젠다가 공유되지 않는다면 분리주의가 팽배해진다. 선전매체가 아닌 ‘언론’은 그래서 필요하다. 특히나 공영 언론은 민주주의 유지를 위한 세금에 가깝다.&lt;/p&gt;
        
        &lt;p&gt;AI가 만들어내는 요약은 요약 텍스트일 뿐 진실을 담고 있지 않다. 가짜뉴스가 양적으로 팽창할수록, &lt;a href=&quot;https://rainygirl.github.io/2018/05/alternative-facts&quot;&gt;대안팩트가 팽배한 시대일수록&lt;/a&gt;, 우리에게는 진짜 ‘진실’이 더욱 절실해질 것이다.&lt;/p&gt;
        
        &lt;p&gt;LLM이 품고 있는 본질적인 구조때문에, LLM은 자신이 만들어낸 문장의 ‘진실성’을 보증할 길이 없다. 그럴 수록 우리에게는 진실의 ‘신뢰할 만한 보증인’이 필요하다. 언론의 제호, 콜싸인은 이제 그 보증인의 역할을 해야 한다.&lt;/p&gt;
        
        &lt;p&gt;알고리즘은 공공의 영역이 아니고 공적 지배구조를 가지고 있지 않다. 필요에 따라선 누군가의 욕망을 담아 편향되게 운영될 수도 있는 것이 알고리즘이다. (&lt;a href=&quot;https://rainygirl.github.io/2015/10/the-desire-to-dominate-the-internet&quot;&gt;포털 장악의 욕망을 다시 읽어보시라&lt;/a&gt;) 그냥 하는 이야기가 아니라 &lt;a href=&quot;https://www.joongang.co.kr/article/25402481&quot;&gt;플랫폼을 차지한 뒤 타국 선거에 개입했다는 공식 발표를 내놓는 정부 수사기관도 있었다&lt;/a&gt;. 그러니, 어딘가에는 공적 지배구조를 가지거나 공적 영역에 발을 담근 사명을 가진 이들이 알고리즘을 감시할 수 있어야 한다. 저널리즘은 알고리즘과 AI시대에 알고리즘을 감시하는 역할을 해야 한다.&lt;/p&gt;
        
        &lt;p&gt;수제 코딩에 대해 비웃는 사람들이 많다. 하지만 LLM이 만들어낸 코드를 많은 개발자들이 직접 검수를 한다. 회사 사장님이 확 가버린 사람이 아닌 한, 보안 문제를 챙기기 위해서라도 사람이 검수를 해야하고, 한심하게 비용이 늘어나게끔 설계하지 않았는지 최종 검수하는 역할은 결국 인간이 해야 한다. 그렇다면 ‘자기 이름을 걸고’ 기사를 쓰는 기자들 역시 자기 기사에는 그 정도 가치를 걸고 보도를 해야 가치가 입증되지 않을까? 받아쓰는 기사가 아니라 자기 이름을 걸 만한 기사를 만들어내야 한다는 이야기다. 이제는 그런 기사만이 AI의 쓰레기더미로부터 살아남아 빛을 볼 것이다.&lt;/p&gt;
        
        &lt;p&gt;프롬프트 몇개면 뉴스는 쉽게 확보된다. 그러면 누가 언론사 사이트를 방문하겠는가? 이제는 사람이 아니라 파이썬 코드가 기사를 읽고, AI가 기사를 읽는다. 광고를 봐줄 사람이 사라지는데, 그러면 언론사는 무엇으로 자생력을 갖추어야 하는가?&lt;/p&gt;
        
        &lt;p&gt;프롬프트를 조금만 고친다면 내가 관심있어하는 언론사의 기사만 읽거나, 특정 주제의 기사만 요악해서 들려주는 봇을 만드는 것도 가능할 것이다. 뉴스의 소비가 더욱 파편화되고 개인화되며 맥락이 소거되는 시대에 대한 전망은 포털을 통한 뉴스공급이 시작될 즈음부터 예견되었던 것이다. 그 미래가 예정대로 찾아왔을 뿐이다. 클릭바이트에 매몰되었던 지난 몇십여 년의 관성에서 다시 벗어나, 본래의 존립 근거를 물어야 한다. 언론이 왜 필요한지, 민주주의 사회에서 언론은 어떤 역할을 해야하는지 처음부터 물어봐야할 때가 되었다. 그리고 새로이 바뀐 생태계에 맞게 생존 방식을 바꾸어야 한다.&lt;/p&gt;
        
        &lt;p&gt;굳이 이런 시대에도 언론사의 콘텐츠를 일부러 찾고, 신문을 읽고 방송을 찾는 이유를 다시 만들어내야 한다. 그것이 무엇인지는 실은 언론인들도 다 알고 있을 것이다. 모르겠다면 다시 옛 책을 펼쳐 볼 때이다.&lt;/p&gt;
        
        &lt;h1 id=&quot;소스코드-공개&quot;&gt;소스코드 공개&lt;/h1&gt;
        
        &lt;p&gt;사람 말을 알아듣고 뉴스를 요약해 들려주는 봇의 코드는
        &lt;a href=&quot;https://github.com/rainygirl/rspeaker&quot;&gt;https://github.com/rainygirl/rspeaker&lt;/a&gt;
        에서 누구나 다운받아 체험해볼 수 있다.&lt;/p&gt;
        
        &lt;blockquote&gt;
        &lt;p&gt;&lt;img src=&quot;/images/2026-02-10-terminal.png&quot; alt=&quot;&quot; /&gt;
        make run 만 하면 작동한다&lt;/p&gt;
        &lt;/blockquote&gt;
        
        &lt;p&gt;MIT 라이센스이다. 어차피 내가 수제로 만든 코드도 아니다. 누구나 고쳐 쓸 수 있지만 각 코드의 책임은 고쳐쓰는 각자에게 있다.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>AI, 그리고 제품</title>
      <link>https://jbee.io/articles/essay/AI, 그리고 제품</link>
      <guid>https://jbee.io/articles/essay/AI, 그리고 제품</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>AI가 만들어준 잉여시간 덕분에 기존 제품을 더 잘 만들거나, 뾰족한 페르소나를 공략하거나, 새로운 기술 기반 제품을 만드는 것이 가능해졌다. 프론트엔드 엔지니어는 이 시간을 활용해 사용자 경험의 상방을 뚫는 혁신의 주체가 될 수 있다.</content:encoded>
    </item>
    <item>
      <title>[번역] 2026년 프런트엔드 개발자라면 알아야 할 4가지 CSS 기능</title>
      <link>https://velog.io/@typo/4-css-features-every-front-end-developer-should-know-in-2026</link>
      <guid>https://velog.io/@typo/4-css-features-every-front-end-developer-should-know-in-2026</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;blockquote&gt;
        &lt;p&gt;원저자의 허락을 받아 원문 &amp;lt;&lt;a href=&quot;https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026&quot;&gt;4 CSS Features Every Front-End Developer Should Know In 2026&lt;/a&gt;&amp;gt;를 한국어로 번역한 글입니다.&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;프런트엔드 개발자라면 &lt;a href=&quot;https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026#scroll-state-container-queries&quot;&gt;스크롤 상태&lt;/a&gt;를 쿼리하는 법, &lt;a href=&quot;https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026#trim-typographic-whitespace-with-text-box&quot;&gt;타이포그래피 여백&lt;/a&gt;을 제거하는 법, &lt;a href=&quot;https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026#sibling-index-and-sibling-count&quot;&gt;sibling-index()&lt;/a&gt;로 시간차 효과를 주는 법, 그리고 &lt;a href=&quot;https://nerdy.dev/4-css-features-every-front-end-developer-should-know-in-2026#advanced-attr()-with-type-checking&quot;&gt;타입 안정적인 &lt;code&gt;attr()&lt;/code&gt;&lt;/a&gt;를 사용하는 법을 알아야 한다고 생각합니다.&lt;/p&gt;
        &lt;p&gt;이 4가지는 2025년에 출시된 CSS 기능들 중 일부에 불과합니다.&lt;/p&gt;
        &lt;h2 id=&quot;sibling-index-sibling-count&quot;&gt;&lt;code&gt;sibling-index()&lt;/code&gt;, &lt;code&gt;sibling-count()&lt;/code&gt;&lt;/h2&gt;
        &lt;p&gt;이 기능들은 올해 초만 해도 실험 단계였지만, 이제 크롬과 사파리에서 안정적으로 사용할 수 있습니다!&lt;/p&gt;
        &lt;p&gt;형제 요소들 사이에서의 상대적인 위치를 값으로 활용할 수 있게 하는 기능입니다. 예를 들어, &lt;code&gt;sibling-index()&lt;/code&gt;를 기반으로 &lt;code&gt;transition-delay&lt;/code&gt;를 주면 요소들에 순차적으로 애니메이션 효과를 적용할 수 있습니다.&lt;/p&gt;
        &lt;p&gt;유용한 트릭을 알려드리면, 1을 빼서 &lt;strong&gt;첫 번째 요소가 즉시 시작하도록 만들 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;li {
        transition: opacity 0.3s ease;
        transition-delay: calc((sibling-index() - 1) * 100ms);
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;code&gt;@starting-style&lt;/code&gt;을 함께 사용하면 요소가 처음 등장할 때 적용되는 애니메이션에 간단하게 시간차 효과를 넣을 수 있습니다!&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;li {
        transition: opacity 0.3s ease;
        transition-delay: calc((sibling-index() - 1) * 100ms);
        
        @starting-style {
        opacity: 0;
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;!-- 스샷? 첨부 --&gt;
        
        &lt;p&gt;oklch에서 색조를 회전시키고, 요소에 자동으로 번호를 매기며, 여러 재미있는 작업을 할 수 있습니다.&lt;/p&gt;
        &lt;details&gt;
        &lt;summary&gt;관련 자료&lt;/summary&gt;
        
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://nerdy.dev/sibling-index&quot;&gt;이전에 쓴 글&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/sibling-index&quot;&gt;sibling-index()&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/sibling-count&quot;&gt;sibling-count()&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://utilitybend.com/blog/styling-siblings-with-CSS-has-never-been-easier.-Experimenting-with-sibling-count-and-sibling-index/&quot;&gt;Brecht&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://css-tricks.com/almanac/functions/s/sibling-index/&quot;&gt;Css tricks&lt;/a&gt;&lt;/details&gt;
        
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;h2 id=&quot;container-scroll-state&quot;&gt;@container &lt;code&gt;scroll-state()&lt;/code&gt;&lt;/h2&gt;
        &lt;p&gt;이 기능들은 스크롤 기반 애니메이션처럼 점진적 향상에 잘 어울립니다.
        필수 요소라기보다는 있으면 더 좋은, “보강 기능”에 가깝기 때문이죠.
        제 생각에는 그렇습니다.&lt;/p&gt;
        &lt;p&gt;이제 스크롤러의 네 가지 상태인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries#using_stuck_queries&quot;&gt;stuck&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries#using_snapped_queries&quot;&gt;snapped&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@container#scrollable&quot;&gt;scrollable&lt;/a&gt;, scrolled를 쿼리할 수 있습니다&lt;/p&gt;
        &lt;p&gt;먼저 &lt;code&gt;stuck&lt;/code&gt;, &lt;code&gt;snapped&lt;/code&gt;, &lt;code&gt;scrollable&lt;/code&gt; 상태를 가지는 요소에
        &lt;code&gt;container-type: scroll-state&lt;/code&gt;를 지정해야 합니다. 그 다음, 그 자식 요소에서 &lt;code&gt;@container scroll-state()&lt;/code&gt;를 사용해 해당 상태를 쿼리할 수 있습니다.&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;&lt;em&gt;NOTE: 요소는 자기 자신을 직접 쿼리할 수는 없지만, 자신의 가상 요소(pseudo element)는 쿼리할 수 있습니다!&lt;/em&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;h3 id=&quot;stuck&quot;&gt;stuck&lt;/h3&gt;
        &lt;p&gt;&lt;code&gt;position: sticky&lt;/code&gt;의 요소가 정확히 언제 &lt;code&gt;stuck&lt;/code&gt;(고정) 상태가 되는지 알 수 있습니다.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://nerdy.dev/media/scroll-state-stuck.mp4&quot;&gt;&lt;img src=&quot;https://nerdy.dev/media/scroll-state-stuck.avif&quot; alt=&quot;스크롤하면서 sticky 탭의 UI가 변경되는 것을 보여주는 영상&quot;&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* .outer-navbar가 stuck 상태일 때 */
        @container scroll-state(stuck) {
        .inner-navbar {
        box-shadow: var(--shadow-3);
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;이 기능을 사용하면 어떤 요소가 이제부터 스크롤 콘텐츠 위에 겹쳐 표시되고 있음을 쉽게 인지하도록 도와줍니다.&lt;/p&gt;
        &lt;h3 id=&quot;snapped&quot;&gt;snapped&lt;/h3&gt;
        &lt;p&gt;&lt;code&gt;scroll-snap&lt;/code&gt; 정렬이 언제 활성화되어 있는지 정확하게 알 수 있습니다.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://nerdy.dev/media/scroll-state-snapped.mp4&quot;&gt;&lt;img src=&quot;https://nerdy.dev/media/scroll-state-snapped.avif&quot; alt=&quot;가로로 스크롤하면서 카드의 UI가 변경됨을 보여주는 영상&quot;&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* &amp;lt;li&amp;gt; 부모 요소가 snapped 일 때 */
        @container scroll-state(snapped) {
        .box {
        scale: 1.1;
        }
        }
        
        /* snapped 상태가 아닐 때  */
        @container not scroll-state(snapped) {
        .box figcaption {
        translate: 0 100%;
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;특정 아이템을 강조하거나 다른 모든 아이템을 하위 요소로 처리할 때 용이합니다.&lt;/p&gt;
        &lt;h3 id=&quot;scrollable&quot;&gt;scrollable&lt;/h3&gt;
        &lt;p&gt;콘텐츠가 컨테이너 밖으로 넘치는 시점과 방향을 파악합니다.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://nerdy.dev/media/scroll-state-scrollable.mp4&quot;&gt;&lt;img src=&quot;https://nerdy.dev/media/scroll-state-scrollable.avif&quot; alt=&quot;세로로 스크롤하면서 overflow 방향에 따라 그림자를 나타내는 영상&quot;&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;@container scroll-state(scrollable) {
        .scroll-hint {
        opacity: 1;
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;이를 활용해 힌트나 스크롤 인디케이터를 켜고 끄거나, 더 많은 콘텐츠가 있다는 것을 알리는 목적으로 패딩을 조정할 수 있습니다.&lt;/p&gt;
        &lt;h3 id=&quot;scrolled&quot;&gt;scrolled&lt;/h3&gt;
        &lt;p&gt;콘텐츠가 어느 방향으로 스크롤되는지 알 수 있습니다.&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;@container scroll-state(scrolled: bottom) {
        translate: 0 -100%;
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;스크롤 방향에 따라 보이거나 숨겨지는 고정된 헤더나 네비게이션 바에 사용하세요.&lt;/p&gt;
        &lt;!-- http://localhost:3030/nintendo-switch-homescreen-css-recreation 는 접근 불가능해서 제외했습니다  --&gt;
        &lt;details&gt;
        &lt;summary&gt;관련 자료&lt;/summary&gt;
        
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://developer.chrome.com/blog/css-scroll-state-queries&quot;&gt;크롬 블로그&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries&quot;&gt;MDN&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://una.im/scroll-state-scrolled&quot;&gt;scrolled에 관한 Una 블로그&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://www.bram.us/2025/10/22/solved-by-css-scroll-state-queries-hide-a-header-when-scrolling-down-show-it-again-when-scrolling-up/&quot;&gt;scrolled에 관한 Bramus 블로그&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;http://localhost:3030/the-css-podcast-on-state-queries&quot;&gt;CSS 팟캐스트&lt;/a&gt;&lt;/details&gt;
        
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;h2 id=&quot;text-box&quot;&gt;&lt;code&gt;text-box&lt;/code&gt;&lt;/h2&gt;
        &lt;p&gt;&lt;code&gt;text-box&lt;/code&gt;로 텍스트 박스의 위아래 줄 사이 간격을 깔끔하게 잘라낼 수 있습니다!&lt;/p&gt;
        &lt;p&gt;웹 폰트 렌더링에는 보통 &lt;a href=&quot;https://matthiasott.com/notes/the-thing-with-leading-in-css&quot;&gt;글리프 위아래에 안전한 여백(safe spacing)이 포함&lt;/a&gt;되는데, 경우에 따라 베이스라인이나 x-height에 픽셀로 딱 맞춘 정렬이 필요하기도 합니다.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;https://nerdy.dev/media/text-box-trim-cap.avif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;위의 이미지를 CSS 코드로 구현하면 다음과 같습니다.&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;h1 {
        text-box: trim-both cap alphabetic;
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;이 한 줄만으로 대문자 높이 위의 여백과 알파벳 기준선 아래의 여백을 말끔히 자를 수 있습니다.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://nerdy.dev/media/text-box-trimmed.mp4&quot;&gt;&lt;img src=&quot;https://nerdy.dev/media/text-box-trimmed.avif&quot; alt=&quot;세로로 스크롤하면서 overflow 방향에 따라 그림자를 나타내는 영상&quot;&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;&lt;a href=&quot;https://nerdy.dev/notebook/text-box.html&quot;&gt;여기서 더 학습해 보세요 💻&lt;/a&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;타이포그래피와 그리드 정렬에 진심인 사람들에게는 정말 완벽한 기능입니다.
        아마 &lt;a href=&quot;https://nerdy.dev/text-box-ftw&quot;&gt;기본값처럼 쓰이게 되지&lt;/a&gt; 않을까요?&lt;/p&gt;
        &lt;details&gt;
        &lt;summary&gt;관련 자료&lt;/summary&gt;
        
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://developer.chrome.com/blog/css-text-box-trim&quot;&gt;크롬 블로그&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://nerdy.dev/notebook/text-box.html&quot;&gt;인터랙티브 노트북&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://codepen.io/collection/zxQBaL&quot;&gt;코드펜 모음&lt;/a&gt;&lt;/details&gt;
        
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;h2 id=&quot;타입이-추가된-attr&quot;&gt;타입이 추가된 &lt;code&gt;attr()&lt;/code&gt;&lt;/h2&gt;
        &lt;p&gt;&lt;code&gt;attr()&lt;/code&gt;의 고급 버전이 등장했습니다. 타입 안정적이며 훨씬 더 강력합니다.&lt;/p&gt;
        &lt;p&gt;타입 체크와 기본값을 포함하여 &lt;strong&gt;HTML 속성을 CSS에서 직접 사용할&lt;/strong&gt; 수 있게 해줍니다.&lt;/p&gt;
        &lt;p&gt;색상을 전달해볼까요?&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div data-bg=&amp;quot;white&amp;quot; data-fg=&amp;quot;deeppink&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.theme {
        background: attr(data-bg color, black);
        color: attr(data-fg color, white);
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;숫자를 전달하는 것도 가능합니다.&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&amp;quot;grid&amp;quot; data-columns=&amp;quot;3&amp;quot;&amp;gt;…&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.grid {
        --_columns: attr(data-columns number, 3);
        
        display: grid;
        grid-template-columns: repeat(var(--_columns), 1fr);
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;HTML과 CSS 사이에 강력한 연결 고리가 생성된 셈입니다.&lt;/p&gt;
        &lt;p&gt;아래 코드는 CSS가 사실상 enum 역할을 하고, HTML은 원하는 동작을 얻기 위해 그에 맞는 유효한 값만 전달하는 예제입니다.&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;li scroll-snap=&amp;quot;start&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li scroll-snap=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li scroll-snap=&amp;quot;end&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li scroll-snap=&amp;quot;nothing&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;&lt;/code&gt;&lt;/pre&gt;
        &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;[scroll-snap] {
        scroll-snap-align: attr(scroll-snap type(start | center | end));
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;code&gt;type()&lt;/code&gt; 함수는 속성 값을 허용된 키워드 목록과 비교해 검증합니다.
        유효하지 않은 값은 자동으로 안전한 기본값으로 대체됩니다.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://codepen.io/argyleink/pen/qEWyZgx&quot;&gt;코드펜에서 테스트 해보세요. 🖊️&lt;/a&gt;&lt;/p&gt;
        &lt;details&gt;
        &lt;summary&gt;관련 자료&lt;/summary&gt;
        
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://nerdy.dev/advanced-attr&quot;&gt;CSS 새로운 기능과 관련하여 2025년에 저자가 작성한 글&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://codepen.io/argyleink/pen/qEWyZgx&quot;&gt;코드펜 데모&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://developer.chrome.com/blog/advanced-attr&quot;&gt;크롬 개발자 아티클&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://css-tip.com/value-input/&quot;&gt;Temani Afif의 아티클&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://codepen.io/t_afif/pen/MWdmZPL&quot;&gt;Temani Afif의 슬라이더 툴팁 데모&lt;/a&gt;&lt;/details&gt;
        
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;이제 &amp;quot;다 갖고 싶다&amp;quot;는 욕심을 담아서 만든, AI 티가 나서 웃긴 짤을 하나 만들었는데 보면서 같이 웃어보는 건 어떨까요?&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;https://nerdy.dev/media/punk-eats-css-cake.avif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;&lt;em&gt;손은 여전히 잘 못 그리네요 ㅋㅋ&lt;/em&gt;&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>무료 TTS 서비스 추천. 클로바 vs Azure</title>
      <link>https://shanepark.tistory.com/559</link>
      <guid>https://shanepark.tistory.com/559</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;h2&gt;Intro&lt;/h2&gt;
        &lt;p&gt;아이를 위한 어린이용 단어장을 만들면서 한국어와 영어 음성을 넣어야 할 일이 생겼다. 무료이거나 비용이 거의 들지 않으면서, 라이선스 문제 없이 상업적으로도 사용 가능한 TTS 서비스가 필요했다. 여러 서비스를 직접 비교해본 끝에 결론부터 말하면 Microsoft Azure Text-to-Speech를 선택했다.&lt;/p&gt;
        &lt;h2&gt;비교해본 서비스들&lt;/h2&gt;
        &lt;p&gt;TTS 서비스를 고를 때 가장 중요하게 본 기준은 세 가지였다. 음성 품질, 무료 사용량, 그리고 라이선스.&lt;/p&gt;
        &lt;h3&gt;네이버 클로바더빙&lt;/h3&gt;
        &lt;p&gt;한국어 음성 품질만 놓고 보면 클로바더빙이 꽤 괜찮았다. 자연스러운 한국어 발음과 다양한 목소리를 제공하고 있어서 첫인상은 좋았다. 다만 무료 사용 시 반드시 출처를 표기해야 하고, 상업 콘텐츠 제작에는 사용할 수 없다는 제약이 있다. 당장 수익화 계획이 없다고 해도 라이선스 제약이 있는 서비스를 선택하는 부담스러운 일이다.&lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style1&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;※ 무료 서비스는 콘텐츠로 인한 수익이 발생하지 않는 채널 게시 용도로만 사용할 수 있습니다.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://help.naver.com/service/23823/contents/12463?lang=ko&amp;amp;osType=COMMONOS&quot;&gt;무료 사용 허용 범위 안내&lt;/a&gt;&lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;Google Cloud TTS&lt;/h3&gt;
        &lt;p&gt;Google Cloud TTS는 무료 제공량이 넉넉한 편이다. 월 100만 자(Neural/WaveNet)까지 무료로 사용할 수 있다. 반면 셋업 과정이 불필요하게 복잡했다. 프로젝트 생성, 서비스 계정 설정, 인증 키 파일 관리 등 실제로 API를 호출하기까지 거쳐야 할 단계가 많다. 하다보니 너무 불편했다.&lt;/p&gt;
        &lt;h3&gt;Azure Text-to-Speech&lt;/h3&gt;
        &lt;p&gt;Azure는 셋업도 간결하고 무료 티어 설정도 명확했다. 리소스를 생성할 때 가격 계층에서 &lt;code&gt;Free F0&lt;/code&gt;를 선택하면 그걸로 끝이다. 과금에 대한 걱정을 할 필요가 전혀 없다. 월 50만 자까지 무료로 제공되는데, 단어장 수천 개를 처리하기에 충분한 양이다. 음성 품질도 좋고, 특히 어린이 목소리 옵션이 만족스러웠다.&lt;/p&gt;
        &lt;h2&gt;Azure TTS 시작하기&lt;/h2&gt;
        &lt;h3&gt;리소스 생성&lt;/h3&gt;
        &lt;p&gt;&lt;a href=&quot;https://portal.azure.com/&quot;&gt;Azure Portal&lt;/a&gt;에 접속해서 상단 검색창에 &lt;code&gt;Speech&lt;/code&gt;를 입력한 뒤 Speech Services를 선택한다. 리소스를 만들 때 중요한 것은 가격 계층에서 반드시 &lt;strong&gt;Free F0&lt;/strong&gt;를 선택하는 것이다. 이렇게 하면 유료 전환 없이 무료 범위 안에서만 사용하게 된다.&lt;/p&gt;
        &lt;p&gt;리소스가 생성되면 왼쪽 메뉴에서 &lt;code&gt;Keys and Endpoint&lt;/code&gt;로 들어가면 API 키 두 개와 엔드포인트가 이미 만들어져 있다. 별도로 키를 생성하거나 서비스 계정을 설정할 필요 없이 바로 사용할 수 있다.&lt;/p&gt;
        &lt;h3&gt;Speech Studio에서 테스트&lt;/h3&gt;
        &lt;p&gt;코딩 없이 음성을 확인해보고 싶다면 &lt;a href=&quot;https://speech.microsoft.com/&quot;&gt;Speech Studio&lt;/a&gt;에 접속하면 된다. Audio Content Creation 메뉴에서 언어와 보이스를 선택하고 텍스트를 입력하면 바로 들어볼 수 있다. MP3 파일로 내보내기도 가능하다.&lt;/p&gt;
        &lt;h3&gt;추천 보이스&lt;/h3&gt;
        &lt;p&gt;어린이용 콘텐츠에 적합한 보이스를 찾느라 여러 가지를 들어봤는데, 최종적으로 선택한 것은 다음 두 가지다.&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;한국어: &lt;code&gt;ko-KR-SeoHyeonNeural&lt;/code&gt; — 자연스러운 어린이 목소리&lt;/li&gt;
        &lt;li&gt;영어: &lt;code&gt;en-GB-MaisieNeural&lt;/code&gt; — 영국 영어 어린이 목소리&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;둘 다 발음이 또렷하고 톤이 부드러워서 단어장 용도로 잘 맞았다.&lt;/p&gt;
        &lt;h3&gt;API 연동&lt;/h3&gt;
        &lt;p&gt;수천 개의 단어를 하나씩 Speech Studio에서 만들 수는 없으니 API를 사용했다. Python SDK를 설치하고 키와 리전만 넣으면 바로 동작한다.&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;pip install azure-cognitiveservices-speech
        import azure.cognitiveservices.speech as speechsdk
        
        speech_config = speechsdk.SpeechConfig(
        subscription=&amp;quot;YOUR_KEY&amp;quot;,
        region=&amp;quot;koreacentral&amp;quot;
        )
        speech_config.speech_synthesis_voice_name = &amp;quot;ko-KR-SeoHyeonNeural&amp;quot;
        
        audio_config = speechsdk.audio.AudioOutputConfig(filename=&amp;quot;apple.mp3&amp;quot;)
        synthesizer = speechsdk.SpeechSynthesizer(
        speech_config=speech_config,
        audio_config=audio_config
        )
        synthesizer.speak_text_async(&amp;quot;사과&amp;quot;).get()&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;실제로 수백 개의 단어를 대상으로 음성 파일을 생성해봤는데, API 요청을 빠른 간격으로 보내도 별다른 문제 없이 모두 정상적으로 생성되었다. 무료 티어 사용량 안에서도 넉넉하게 처리할 수 있었다.&lt;/p&gt;
        &lt;h2&gt;라이선스&lt;/h2&gt;
        &lt;p&gt;Azure TTS의 라이선스가 깔끔한 편이다. &lt;a href=&quot;https://learn.microsoft.com/en-us/legal/ai-code-of-conduct&quot;&gt;Microsoft Enterprise AI Services Code of Conduct&lt;/a&gt;를 보면, 이 규정은 무료든 유료든 Microsoft AI 서비스의 모든 고객에게 동일하게 적용된다. 문서에 상업적 이용을 금지하는 조항은 없으며, 오히려 결과물에 대한 권리와 책임이 고객에게 있음을 명시하고 있다.&lt;/p&gt;
        &lt;blockquote data-ke-style=&quot;style1&quot;&gt;&lt;p data-ke-size=&quot;size16&quot;&gt;&lt;span style=&quot;font-family: &apos;Noto Serif KR&apos;;&quot;&gt;&lt;p&gt;아래의 질문 답변도 무료티어의 상업적 활용에 대해 명확하게 설명해준다.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/answers/questions/1070009/usage-policy-limitation-for-free-tier&quot;&gt;https://learn.microsoft.com/en-us/answers/questions/1070009/usage-policy-limitation-for-free-tier&lt;/a&gt;&lt;/p&gt;
        &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;비교 정리&lt;/h2&gt;
        &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
        &lt;th&gt;항목&lt;/th&gt;
        &lt;th&gt;Azure TTS&lt;/th&gt;
        &lt;th&gt;Google Cloud TTS&lt;/th&gt;
        &lt;th&gt;클로바더빙&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
        &lt;td&gt;무료 사용량&lt;/td&gt;
        &lt;td&gt;월 50만 자&lt;/td&gt;
        &lt;td&gt;월 100만 자&lt;/td&gt;
        &lt;td&gt;제한적&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;셋업 난이도&lt;/td&gt;
        &lt;td&gt;간단&lt;/td&gt;
        &lt;td&gt;복잡&lt;/td&gt;
        &lt;td&gt;간단&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;음성 품질&lt;/td&gt;
        &lt;td&gt;좋음&lt;/td&gt;
        &lt;td&gt;좋음&lt;/td&gt;
        &lt;td&gt;좋음 (한국어)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;상업적 이용&lt;/td&gt;
        &lt;td&gt;가능&lt;/td&gt;
        &lt;td&gt;가능&lt;/td&gt;
        &lt;td&gt;불가 (무료)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;출처 표기&lt;/td&gt;
        &lt;td&gt;불필요&lt;/td&gt;
        &lt;td&gt;불필요&lt;/td&gt;
        &lt;td&gt;필수 (무료)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/tbody&gt;&lt;/table&gt;
        &lt;h2&gt;마치며&lt;/h2&gt;
        &lt;p&gt;TTS 서비스를 고를 때 음성 품질만 보면 상당히 상향평준화가 되어 있다. 결국 차이를 만드는 것은 셋업의 간편함, 과금 구조의 명확함, 그리고 라이선스의 깔끔함이다. Azure TTS는 이 세 가지를 모두 만족시켜주기에 추천한다.&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/answers/questions/1192398/can-i-use-azure-text-to-speech-for-commercial-usag&quot;&gt;https://learn.microsoft.com/en-us/answers/questions/1192398/can-i-use-azure-text-to-speech-for-commercial-usag&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/answers/questions/1070009/usage-policy-limitation-for-free-tier&quot;&gt;https://learn.microsoft.com/en-us/answers/questions/1070009/usage-policy-limitation-for-free-tier&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://help.naver.com/service/23823/contents/12463?lang=ko&amp;amp;osType=COMMONOS&quot;&gt;https://help.naver.com/service/23823/contents/12463?lang=ko&amp;amp;osType=COMMONOS&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      </content:encoded>
    </item>
    <item>
      <title>취뽀</title>
      <link>https://w0nder.land/posts/62-%EC%B7%A8%EB%BD%80</link>
      <guid>https://w0nder.land/posts/62-%EC%B7%A8%EB%BD%80</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        아는 분 소개로 잠깐 대화만 나눠달라고 해서 갔는데, 면접이었다. 그냥 개발자 면접인 줄 알았는데 개발 리드 면접이었고, 대표님이 직접 나와서 면접을 보셨다.
        그리고는 바로 같이 일해보자고 하시더라. 사실 취업할 생각은 전혀 없었다. 올해 1년간 할 다른 도전들을 계획해놨고, 준비도 다 해놨었다. 그런데 대표님이 며칠간 계속 설득하시는 바람에 결국 출근하게 됐다. 하루아침에 직장인으로 돌아온 셈이다. 대표님은 기존에 하던 일은 출근하면서 마무리해도 된다고 하시며, 빠르게 와서 팀 매니징을 부탁한다고만 하셨다.
        이렇게 빠른 결정들은 항상 문제가 생기기도 한다. 그런데 대표님이 너무 간절해 보였다.
        나는 창업을 하면서 이렇게 간절한 적이 있었나 싶었다. 그러면서 지난 창업 기간을 되돌아보기도 했다. 나는 얼마나 대표스러웠을까? 물론 목표가 이런 걸 바라고 창업한 건 아니지만, 나는 과연 얼마나 했을까? 사업에 대한 절실함, 팀에 대한 책임감, 비전을 향한 추진력. 그런 것들이 나에게도 있었을까?
        그래서 이 대표님에게 궁금함이 생겼다. 무엇이 사람을 이렇게 간절하게 만들었을까? 그리고 나를 왜 필요로 하는지, 그 필요가 언제까지 이어질까?
        올해 계획을 세운 지 얼마 되지 않았고, 외주 계약을 몇 개 맺은 지도 얼마 안 됐는데, 바로 출근하게 됐다.
        일단 기존에 진행하던 일은 빠르게 마무리하는 형식으로 진행하고, 추가 계약 직전에 있던 것들은 거절 의사를 전달했다. 클라이언트들에게 상황을 설명하는 게 생각보다 어려웠다. 갑작스러운 변화를 어떻게 설명해야 할지, 그들이 이해해줄지 조금 걱정도 됐다.
        바리스타 학원도 다닐 준비를 하고, 기타 여러 가지를 준비해 놨는데, 다 취소됐다. 아쉽긴 하다. 특히 바리스타는 꽤 오래전부터 해보고 싶었던 거라 마음 한편이 허전하다. 언젠가 기회가 되면 다시 도전해봐야겠다는 생각만 남았다.
        인생이 참 묘하다. 계획대로 되지 않는 게 당연한 건데, 막상 이렇게 되면 당황스럽다. 그래도 나쁘지 않은 당황스러움이다.
        그렇게 취뽀?를 하고 다시 회사를 다니면서 내가 지난 1년간 얼마나 사회와 IT, 스타트업씬과 멀어졌나 느껴졌다.
        1년 만에 세상은 많이 바뀌어 있었다. 나도 바쁘게 살아왔다고, 제품도 많이 만들고, 코딩도 많이 했다고 생각했지만, 다시 적응하는 데 오래 걸릴 것 같은 기분이 들었다. 세상은 저 멀리 나 몰래 가버리고 있었다.
        기술 스택도 바뀌었고, 개발 방법도 많이 바뀌었고, 트렌드도 바뀌었고, 사람들이 이야기하는 주제들도 달라져 있었다. 혼자 작은 프로젝트들을 하면서는 몰랐던 것들이, 조직 안에서 일하려니 한꺼번에 보이기 시작했다.
        다시 따라잡으려면 당분간 뛰어야 할 것 같다. 아니, 뜀박질을 해야 할 것 같다.
      </content:encoded>
    </item>
    <item>
      <title>진짜로 코딩의 판도는 바뀌었다. 개발자는 어떻게 해야 할까?</title>
      <link>https://velog.io/@teo/ai-agent-prolog</link>
      <guid>https://velog.io/@teo/ai-agent-prolog</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;blockquote&gt;
        &lt;p&gt;&amp;#39;진짜 한번 해볼까? 한번 코드를 내가 직접 작성하지 않고 어디까지 가능할지를 확인해봐야겠다! 한계를 정확히 알아줘야지&amp;#39;&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;두달전 재미로 시작하게 된 사이드 프로젝트에서 시작한 에이전트 기반 코딩은 단순하게 &amp;quot;채팅만으로 어디까지 코딩할 수 있을까?&amp;quot;로 시작해서 지금은 에이전트 기반 코딩의 시대가 도래했다는 것을 체감했고 개발의 방식이 완전히 바뀌었습니다.&lt;/p&gt;
        &lt;p&gt;이제는 AI에게 일을 시켰을때 검증을 걱정하지 않을 정도로 하는 수준이 오면서 개발하는 방식이 완전히 바뀌었다. 어셈블러에서 C++로 오듯 코드에서 자연어 수준으로 넘어가는 것을 느낍니다. 코드를 직접 수정하지 않고서도 대부분의 개발이 가능한 수준, 아니 그 이상이 되었습니다.&lt;/p&gt;
        &lt;p&gt;에이전트가 GitHub 이슈를 스스로 해결하는 벤치마크(SWE-bench)에서 2023년 초기 성공률은 2%였습니다. 2%짜리 주사위를 반반 확률로 한 번이라도 성공하려면 35번을 던져야 해요. 바이브 코딩이 개발자의 빈축을 산 이유죠.&lt;/p&gt;
        &lt;p&gt;지금은 어떨까요? 같은 벤치마크의 검증된 문제셋(SWE-bench Verified) 기준으로 79%입니다. 한 번 던지면 79%. 못해도 네 번이면 99%. 거의 성공하고 틀리면 &amp;quot;안되는데? 다시 해봐.&amp;quot; 한번 더 시키면 그만인 수준이 되었습니다.&lt;/p&gt;
        &lt;h3 id=&quot;그렇다면-앞으로-개발자는-뭘-해야-할까요&quot;&gt;그렇다면 앞으로 개발자는 뭘 해야 할까요?&lt;/h3&gt;
        &lt;p&gt;하지만 모든 문제가 79%일 수 없습니다. 실제 현업 수준의 복잡한 문제를 모은 별도의 벤치마크(SWE-bench Pro)에서는 최고 모델도 23%라고 합니다. 3번 정도 돌리면 반반의 확률로 성공하는 수준이군요. 그것도 매번 접근 방식을 바꿔가며 돌렸을 때 이야기입니다. 같은 방식으로 반복하면 오히려 더 깊은 수렁에 빠지면서 같은 실패를 반복할 가능성이 높아요. 이따금 우리가 에이전트를 돌리다 겪는 모습입니다. 그래서 가끔 개발자가 방향을 잡아줘야 하죠. 그러면 개발자는 이렇게 조금씩 방향만 잡아주면 되는 사람일까요? &lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;&amp;quot;어? 이게 왜 되지?&amp;quot;&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;개발자에게 가장 무서운건 버그가 분명 있었고 나는 분명 그 버그를 수정한 적이 없었는데 그냥 되는 경우입니다. 개발자에게는 차라리 깨끗한 실패와 에러가 낫습니다. 코드 수정의 실패는 단순한 실패가 아니기 때문입니다. 분석이나 보고서는 실패하면 버리면 끝이에요. 원본이 그대로니까.&lt;/p&gt;
        &lt;p&gt;하지만 코드 수정은? 파일 여러 개를 건드려놓고 일부는 맞고 일부는 틀리고 테스트는 통과하는데 사이드이펙트가 숨어있을 수도 있고 리뷰가 &amp;quot;됐다/안됐다&amp;quot;가 아니라 코드 리뷰가 됩니다. 그것도 내가 짠 코드가 아니라 남이 짠 코드의 리뷰.&lt;/p&gt;
        &lt;p&gt;대규모의 유지보수에 많은 인력이 들어가는 이유는 한번 잘못된 설계로 진행하면 그 누적된 문제를 복구하고 고치는 비용이 너무 비싸기 때문이죠. AI도 마찬가지예요. 특히나 잘못된 구조를 정석이라고 믿고 고치다보면 노이즈가 컨텍스트를 방해합니다. AI의 시행착오는 비용입니다.&lt;/p&gt;
        &lt;h3 id=&quot;개발자-ai의-시행착오의-비용을-줄여주는-사람&quot;&gt;&amp;quot;개발자, AI의 시행착오의 비용을 줄여주는 사람&amp;quot;&lt;/h3&gt;
        &lt;p&gt;그러면 이 시대에 개발자의 역할은 뭘까요? 세 가지를 한번 생각해봤습니다.&lt;/p&gt;
        &lt;p&gt;1 문제를 쪼개는 사람 — 23%짜리 어려운 문제를 79%짜리 여러 개로 분해하는 것. 에이전트가 한 번에 성공할 수 있는 단위로 만들어주는 겁니다.&lt;/p&gt;
        &lt;p&gt;2 실패를 빠르게 판별하는 사람 — 에이전트의 결과물이 쓸 만한지, 버려야 하는지, 부분 성공의 함정에 빠진 건 아닌지. 이 판단을 빠르게 내릴수록 시행착오의 비용이 줄어듭니다.&lt;/p&gt;
        &lt;p&gt;3 성공률 자체를 높이는 환경을 설계하는 사람 — 좋은 테스트, 명확한 인터페이스, 잘 분리된 모듈. 코드베이스의 아키텍처가 곧 에이전트의 성공률을 결정하는 변수가 됩니다.&lt;/p&gt;
        &lt;p&gt;사실 이건 좋은 시니어가 주니어를 키울 때 하는 일과 많이 겹칩니다. 하지만 결정적 차이가 하나 있어요.&lt;/p&gt;
        &lt;h3 id=&quot;에이전트는-욕망이-없고-성장하지-않습니다&quot;&gt;&amp;quot;에이전트는 욕망이 없고, 성장하지 않습니다.&amp;quot;&lt;/h3&gt;
        &lt;p&gt;주니어는 냅둬도 알아서 성장합니다. 잘하고 싶다는 욕망이 있으니까요. 물론 좋은 시니어가 옆에 있으면 더 빠르지만, 본인의 의지로 알아서 커갑니다. 에이전트는? 절대적으로 가만히 있어요. 프롬프트를 다듬고 규칙을 정리하면 성공률은 올라가지만, 그건 에이전트가 성장한 게 아니라 환경을 설계한 사람의 역량이 올라간 겁니다.&lt;/p&gt;
        &lt;p&gt;그래서 역설적으로, 에이전트 시대에 사람의 가치가 더 선명해집니다. 문제를 쪼개려면 제품이 어디로 가야 하는지 알아야 하고, 실패를 판별하려면 좋은 코드에 대한 감각이 있어야 하고, 환경을 설계하려면 미래에 어떤 변경이 올지 예측해야 합니다. 이건 전부 경험과 의지에서 나오는 것들이고, 자동화가 안 되는 영역입니다.&lt;/p&gt;
        &lt;p&gt;저는 지금 제 클론을 만들고 있습니다. 에이전트는 똑똑한데 일은 못하는 사원이에요. 지식은 있는데 일하는 감각이 없는 거죠. 문제를 어떻게 쪼개는지, 실패를 어떻게 판단하는지, 어떤 구조가 좋은 구조인지 — 제가 일하는 방식을 하나하나 알려주고 있는데, 이게 신입사원 키우는 재미와 똑같습니다.&lt;/p&gt;
        &lt;p&gt;에이전트가 아직 23%인 지금이 오히려 가르치는 법을 익히기 좋은 때라고 생각합니다. 79%가 되면 다들 그냥 갖다 쓰겠지만, 지금 가르치는 법을 익혀둔 사람은 그때 훨씬 더 잘 쓸 수 있을 테니까요.&lt;/p&gt;
        &lt;p&gt;저도 이제 막 눈을 뜬 직후라 아직은 대단하게 정리되지는 못했지만 조만간 정리된 아티클을 만들어서 공유하려고 합니다. 우선 제가 발견한거 하나를 공유드립니다.&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;&amp;quot;스킬을 등록하는 스킬을 등록해&amp;quot;
        &amp;quot;... 를 스킬로 등록해&amp;quot;&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;콜롬부스의 달걀. 아는 사람에게는 너무 당연한 데, 이걸 처음 입력하는 순간이 진짜 시작이 됩니다. 이 첫 단추가 여러분들이 에이전트를 쓰는 관점을 바꾸는데 도움이 되기를 바랍니다.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>[Swift][Macro] 환경별 Swift 매크로 분기 처리: 환경에 따라 다른 매크로 호출</title>
      <link>https://minsOne.github.io/conditional-swift-macros-generating-development-code-vs-production-dummy-macros</link>
      <guid>https://minsOne.github.io/conditional-swift-macros-generating-development-code-vs-production-dummy-macros</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>
        &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt;
        &lt;html&gt;&lt;body&gt;
        &lt;p&gt;Swift 매크로를 사용하다보면 개발 환경에서 생성된 코드가 운영 환경에서는 불필요한 경우가 발생할 수 있습니다. 특정 Protocol을 구현한 Mock 객체를 생성하는 매크로를 사용한다고 가정해봅시다. &lt;a href=&quot;https://github.com/Matejkob/swift-spyable&quot;&gt;swift-spyable&lt;/a&gt;, &lt;a href=&quot;https://github.com/Kolos65/Mockable&quot;&gt;Mockable&lt;/a&gt; 등의 매크로를 이용해서 Mock 객체를 쉽게 생성할 수 있습니다.&lt;/p&gt;
        
        &lt;p&gt;이들 매크로의 코드는 전처리기를 이용해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#if DEBUG ... #endif&lt;/code&gt; 구문을 사용해서 개발 환경에서만 생성되도록 할 수 있습니다.&lt;/p&gt;
        
        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@Mockable&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;cp&quot;&gt;#if DEBUG&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyServiceMock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;doSomethingCallCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;doSomethingCallCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;
        &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
        
        &lt;p&gt;하지만 이러한 방식은 생성된 매크로 코드를 다른 모듈에서 인식을 할 수 없는 단점이 있습니다.(예: Mock 객체를 다른 모듈에서 사용해야 하는 경우, 인식이 되지 않음. 단순 코드 작성하면 동작하나, 자동완성이 되지 않음.)&lt;/p&gt;
        
        &lt;p&gt;개발 환경에서는 생성된 코드를 통해 테스트를 진행하고, 운영 환경에서는 코드가 생성되지 않도록 하는 방법은 없을까요?&lt;/p&gt;
        
        &lt;h2 id=&quot;매크로-인터페이스-분기-처리&quot;&gt;매크로 인터페이스 분기 처리&lt;/h2&gt;
        
        &lt;p&gt;매크로 템플릿을 통해 생성하면 기본 매크로인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stringify&lt;/code&gt; 를 만들 수 있습니다.&lt;/p&gt;
        
        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@freestanding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;macro&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;cp&quot;&gt;#externalMacro(module: &quot;MyMacroMacros&quot;, type: &quot;StringifyMacro&quot;)&lt;/span&gt;
        &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
        
        &lt;p&gt;외부에서는 매크로를 호출하지만, 실제로는 매크로 모듈의 매크로를 호출하는 방식입니다. 즉, 여기서는 매크로 모듈에 전처리기를 이용해서 분기 처리를 할 수 있습니다.&lt;/p&gt;
        
        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#if DEBUG&lt;/span&gt;
        
        &lt;span class=&quot;kd&quot;&gt;@freestanding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;macro&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;externalMacro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;MyMacroMacros&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;StringifyMacro&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;cp&quot;&gt;#else&lt;/span&gt;
        
        &lt;span class=&quot;kd&quot;&gt;@freestanding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;macro&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;externalMacro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;MyMacroMacros&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;DummyMacro&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;
        &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
        
        &lt;p&gt;이와 같이 매크로 인터페이스를 분기 처리하면, 환경에 관계없이 동일하게 매크로를 호출할 수 있습니다.&lt;/p&gt;
        
        &lt;h3 id=&quot;dummymacro의-역할&quot;&gt;DummyMacro의 역할&lt;/h3&gt;
        
        &lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DummyMacro&lt;/code&gt;는 운영 환경에서 매크로가 불필요한 작업을 수행하지 않도록 설계합니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stringify&lt;/code&gt; 매크로의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DummyMacro&lt;/code&gt;는 단순히 입력받은 값을 그대로 반환하기만 하도록 구현할 수 있습니다.&lt;/p&gt;
        
        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MyMacroMacros/DummyMacro.swift&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DummyMacro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ExpressionMacro&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;expansion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;some&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FreestandingMacroExpansionSyntax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;some&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MacroExpansionContext&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ExprSyntax&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 단순히 입력 인자를 그대로 반환하거나 결과값만 전달&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argumentList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
        
        &lt;p&gt;이렇게 하면 운영 환경의 바이너리에는 복잡한 Mock 생성 로직이나 디버깅용 코드가 포함되지 않으며, 매크로 확장으로 인한 빌드 시간 오버헤드도 최소화할 수 있습니다.&lt;/p&gt;
        
        &lt;h2 id=&quot;결론-관심사의-분리와-깔끔한-코드&quot;&gt;결론: 관심사의 분리와 깔끔한 코드&lt;/h2&gt;
        
        &lt;p&gt;이 방식의 핵심 이점은 다음과 같습니다.&lt;/p&gt;
        
        &lt;ol&gt;
        &lt;li&gt;
        &lt;strong&gt;관심사의 분리&lt;/strong&gt;: 매크로를 사용하는 쪽에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#if DEBUG&lt;/code&gt;를 일일이 관리할 필요가 없습니다. 환경에 따른 동작 결정은 매크로 인터페이스 정의 단계에서 한 번만 처리됩니다.&lt;/li&gt;
        &lt;li&gt;
        &lt;strong&gt;깨끗한 코드&lt;/strong&gt;: 호출부 코드가 복잡해지지 않아 가독성이 높아지고 유지보수가 쉬워집니다.&lt;/li&gt;
        &lt;li&gt;
        &lt;strong&gt;DX(개발 경험) 향상&lt;/strong&gt;: 모듈 간 참조 시 발생하는 인식 문제나 자동완성 누락 문제를 매크로 수준에서 해결하여 더 쾌적한 개발 환경을 제공합니다.&lt;/li&gt;
        &lt;/ol&gt;
        
        &lt;/body&gt;&lt;/html&gt;
      </content:encoded>
    </item>
    <item>
      <title>펑터를 넘어서, 모나드까지</title>
      <link>https://evan-moon.github.io/2026/02/07/monads-in-typescript/</link>
      <guid>https://evan-moon.github.io/2026/02/07/monads-in-typescript/</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>이번 포스팅에서는 이전에 다뤘던 펑터의 개념에 이어 모나드에 대한 설명을 이어가보려고 한다. 아무래도 모나드라고 하면 가장 먼저 떠오르는 것은 “모나드는 내부함자 범주의 모노이드 대상 어쩌고”하는 설명인데, 사실 이것은 모나드를 가장 잘 설명하는 문장이면서도 가장 설명을 못하는 문장이기도 하다. 모나드를 이해하는 순간 모나드를 설명할 수 없게 되어버린다는 모나드의 저주라고 불리는 유명한 밈이 존재할만큼, 수학을 잘 모르는 입장에서는 참 이해하기 난해한 대상이기는 하다. 이에 필자도 야심차게 모나드를 설명하기 위한 도전을 한번 해보려고 한다. (물론 실패할 수도 있다…)</content:encoded>
    </item>
    <item>
      <title>Beyond Functors, All the Way to Monads</title>
      <link>https://evan-moon.github.io/2026/02/07/monads-in-typescript/en/</link>
      <guid>https://evan-moon.github.io/2026/02/07/monads-in-typescript/en/</guid>
      <pubDate>Fri, 13 Feb 2026 01:54:12 GMT</pubDate>
      <content:encoded>In this post, I’ll continue from the concept of functors I covered previously and move on to explaining monads. When people hear “monad,” the first thing that usually comes to mind is the infamous explanation: “A monad is a monoid in the category of endofunctors, blah blah blah.” While this is technically the most accurate description of a monad, it’s also the most unhelpful one. There’s even a well-known meme called the “monad curse” — the idea that the moment you understand monads, you lose the ability to explain them. For those of us who aren’t deeply versed in mathematics, monads are indeed a notoriously elusive concept. With that in mind, I’m going to take my own ambitious crack at explaining monads. (Of course, I might fail…)</content:encoded>
    </item>
  </channel>
</rss>