<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>dev RSS - Level Up Coding</title>
    <link>https://levelup.gitconnected.com/</link>
    <description>Level Up Coding RSS í”¼ë“œ</description>
    <lastBuildDate>Sat, 14 Feb 2026 18:29:07 GMT</lastBuildDate>
    <item>
      <title>5 Principles for Writing Testable TS Code You Canâ€™t Ignore</title>
      <link>https://levelup.gitconnected.com/5-principles-for-writing-testable-ts-code-you-cant-ignore-5180d8d7c5e2?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/5-principles-for-writing-testable-ts-code-you-cant-ignore-5180d8d7c5e2?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:55 GMT</pubDate>
      <content:encoded>&lt;div class=&quot;medium-feed-item&quot;&gt;&lt;p class=&quot;medium-feed-image&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/5-principles-for-writing-testable-ts-code-you-cant-ignore-5180d8d7c5e2?source=rss----5517fd7b58a6---4&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2496/1*kw2ks7v9Edc3PM4K2u6WXg.png&quot; width=&quot;2496&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;medium-feed-snippet&quot;&gt;In this article, we&amp;#x2019;ll walk through:&lt;/p&gt;&lt;p class=&quot;medium-feed-link&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/5-principles-for-writing-testable-ts-code-you-cant-ignore-5180d8d7c5e2?source=rss----5517fd7b58a6---4&quot;&gt;Continue reading on Level Up Coding Â»&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content:encoded>
    </item>
    <item>
      <title>Systems Thinking in an AI Era</title>
      <link>https://levelup.gitconnected.com/systems-thinking-in-an-ai-era-f37ab8144763?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/systems-thinking-in-an-ai-era-f37ab8144763?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:53 GMT</pubDate>
      <content:encoded>&lt;h4&gt;Why understanding what we build stillÂ matters&lt;/h4&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*tnoIXIzaCVZeKqyP&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@melotic?utm_source=medium&amp;amp;utm_medium=referral&quot;&gt;Justin Zhu&lt;/a&gt; onÂ &lt;a href=&quot;https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;I just finished reading &lt;a href=&quot;https://www.goodreads.com/book/show/3828902-thinking-in-systems&quot;&gt;&lt;em&gt;Thinking in Systems&lt;/em&gt;&lt;/a&gt; by Donella Meadows, and itâ€™s one of those books that quietly rewires how you see theÂ world.&lt;/p&gt;&lt;p&gt;The book was published in 2008 based on notes she wrote in the 1990s, but what struck me most was how current the problems she described remain, even in 2026. As someone building software in the AI era, this really resonated withÂ me.&lt;/p&gt;&lt;p&gt;AI can write a lot of code for us now. It can even speed up learning. But it doesnâ€™t replace the judgment required to understand the systems weâ€™re building. That responsibility is stillÂ ours.&lt;/p&gt;&lt;h3&gt;An Inevitable Failure&lt;/h3&gt;&lt;p&gt;In late January 2026, Moltbook launched an AI-only social network. The founder proudly announced he â€œdidnâ€™t write a single line of code.â€ Within days, security researchers discovered a breach exposing 1.5 million API tokens, private messages, and email addresses. Security experts werenâ€™t shocked. The vulnerability was predictable: the system optimized for speed and virality, not security or verification.&lt;/p&gt;&lt;p&gt;Complex systems rarely fail because of bad intent. They behave exactly as theyâ€™re designed to. That idea feels uncomfortably relevant in modern technology. Outcomes that feel shocking or tragic are often the result of systems doing exactly what theyâ€™re optimized to do, even if no one inside the system would describe that as theÂ goal.&lt;/p&gt;&lt;p&gt;Why do these failures feel familiar instead of surprising? They follow patterns. Systems thinking is the framework for seeingÂ them.&lt;/p&gt;&lt;h3&gt;What Systems Thinking ActuallyÂ Is&lt;/h3&gt;&lt;p&gt;Systems thinking changes the question. Instead of asking &lt;em&gt;â€œwho messed up?â€&lt;/em&gt; it asks, &lt;em&gt;â€œwhat is this system set up toÂ do?â€&lt;/em&gt;&lt;/p&gt;&lt;p&gt;One way to answer that question is to watch for repetition. When the same things keep happening, thatâ€™s often the system revealing how it actuallyÂ works.&lt;/p&gt;&lt;p&gt;Once you start looking at systems this way, what happens stops feeling random. You begin to see how incentives, feedback loops, and goals shape behavior, no matter who is involved. And once you see that, you start seeing the same patterns everywhere. Thatâ€™s especially true in software. And with AI in the mix, those patterns are showing up faster and at a much largerÂ scale.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Escalation&lt;/strong&gt;&lt;/h4&gt;&lt;blockquote&gt;â€œIf nothing is done to break the loop, the process usually ends with one or both of the competitors breakingÂ down.â€&lt;/blockquote&gt;&lt;p&gt;&lt;em&gt;Escalation systems&lt;/em&gt; reward keeping up, not slowing down. Competition pushes systems towards extremes. Models get bigger, faster, and more powerful. Competitors respond or risk irrelevance. Training costs rise, energy usage increases, and complexity explodes. No one can easily opt out without feeling like theyâ€™re fallingÂ behind.&lt;/p&gt;&lt;p&gt;Long-term risks stay abstract and delayed. Short-term gains are immediate and visible. The system rewards speed and novelty over restraint.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Seeking the wrongÂ goal&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Systems optimize what you measure, so indicators become the goal. If a behavior persists over time, thereâ€™s likely a mechanism creating it, usually a feedback loop. That loop reveals what the system is actually designed toÂ do.&lt;/p&gt;&lt;p&gt;Feedback loops can only affect future behavior. They canâ€™t deliver a signal fast enough to correct the behavior that created the current problem. By the time you see the problem, the conditions that created it are alreadyÂ set.&lt;/p&gt;&lt;p&gt;This is why the â€œmove fast and break thingsâ€ mentality actually does break things. The feedback arrives after youâ€™ve alreadyÂ moved.&lt;/p&gt;&lt;p&gt;Take tech debt. Under constant pressure to ship, cleanup gets pushed to â€œlater.â€ More pressure, less time, more debt. The cycle continues.&lt;/p&gt;&lt;p&gt;We see this in workplaces that reward urgency but create burnout, in products that chase engagement at the expense of trust, and in teams that add process instead of fixing system problems.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Distance from Consequences&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Scale and abstraction make harm easier to ignore, and AI increases that distance. We delegate decisions, implementations, and even reasoning without seeing how all those choices play out downstream.&lt;/p&gt;&lt;p&gt;In the Moltbook example, when things broke, the consequences werenâ€™t abstract. Users were exposed. Security teams scrambled. The distance between the builder and the system mattered.&lt;/p&gt;&lt;p&gt;Thatâ€™s what understanding the system gives us. A way to stay connected to the consequences.&lt;/p&gt;&lt;h3&gt;Old Problems, NewÂ Velocity&lt;/h3&gt;&lt;p&gt;Once you recognize these patterns, something else becomes clear: none of this isÂ new.&lt;/p&gt;&lt;p&gt;Meadows described these same system dynamics decades ago. What persists isnâ€™t a lack of solutions, but a tendency to treat systemic issues as isolated events. We treat symptoms instead of making structural changes, and then act surprised when the same problems resurface.&lt;/p&gt;&lt;p&gt;Systems thinking reframes failure. It treats recurring issues not as one-off crises, but as predictable outcomes. Problems feel permanently â€œunsolvedâ€ because they arenâ€™t meant to be fixed once. Theyâ€™re systems to understand and manage overÂ time.&lt;/p&gt;&lt;p&gt;In software, these dynamics are easy to recognize once you start paying attention. Work that always feels urgent. Decisions are made quickly because there isnâ€™t time to slow down. That kind of pace can feel productive, especially under pressure. But over time, it destabilizes the system and leaves no room to examine whatâ€™s actually causingÂ issues.&lt;/p&gt;&lt;p&gt;AI didnâ€™t invent these patterns, but it does compress them. What once took months now happens in days. What used to affect a single team can quickly spill across an organization and beyond. If AI is going to scale our systems this fast, understanding what weâ€™re building has to come before dealing with the consequences.&lt;/p&gt;&lt;h3&gt;What Systems ThinkingÂ Changes&lt;/h3&gt;&lt;p&gt;Systems thinking shifts your attention. It pushes you to ask questions like:&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;What is this system actually optimized for?&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;The answer isnâ€™t what we say. Itâ€™s what the behavior reveals. If a companyâ€™s mission statement says â€œqualityâ€ but promotions reward speed, then the system is optimized for speed. If AI usage is being monitored and quantified, the system rewards usage, not necessarily quality or learning.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;What are the high-leverage points?&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Most changes we make are low-leverage, like tweaking parameters, adding people, piling on process. High-leverage changes are much more uncomfortable. They require changing goals, incentives, and paradigms.&lt;/p&gt;&lt;p&gt;This could look like changing what you measure, not just how much. Changing what behavior gets rewarded. Questioning what â€œsuccessâ€ looksÂ like.&lt;/p&gt;&lt;p&gt;This is hard because paradigms defend themselves. Teams may resist new metrics because the old metrics defined their value. This is emotional work, not just technical.&lt;/p&gt;&lt;p&gt;Modern software is a socio-technical system: code, infrastructure, people, processes, and now, AI. This is why technical fixes often fail without human context. Nothing happens in isolation, and responsibility doesnâ€™t disappear just because systems get abstracted or automated.&lt;/p&gt;&lt;h3&gt;What We Choose Not ToÂ Optimize&lt;/h3&gt;&lt;blockquote&gt;â€œLiving successfully in a world of systems requires more than our ability to calculate. It requires our full humanityâ€Šâ€”â€Šour rationality, our intuition, our compassion, our vision, and our morality.â€&lt;/blockquote&gt;&lt;p&gt;We live in a culture obsessed with what we can measure, but some things donâ€™t show up in dashboards, like trust, meaning, quality, and relationships.&lt;/p&gt;&lt;p&gt;Systems thinking isnâ€™t about optimizing efficiency. Itâ€™s about protecting what matters while building at scale. Speed, output, and metrics are means, notÂ ends.&lt;/p&gt;&lt;h3&gt;What ComesÂ Next&lt;/h3&gt;&lt;p&gt;We are undeniably at an inflection point. AI is accelerating how quickly ideas turn into systems, and how quickly those systems shape real lives. That speed changes theÂ stakes.&lt;/p&gt;&lt;p&gt;The work ahead isnâ€™t just technical. Itâ€™s paying attention to the patterns weâ€™ve learned to normalize. To question what our systems reward. To notice what gets lost when speed becomes theÂ goal.&lt;/p&gt;&lt;p&gt;When AI writes the code, weâ€™re responsible for the systems it creates. Understanding them isnâ€™t optional.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Further Reading&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Donella H. Meadows, &lt;a href=&quot;https://www.goodreads.com/book/show/3828902-thinking-in-systems&quot;&gt;&lt;em&gt;Thinking in Systems: A Primer&lt;/em&gt;&lt;/a&gt;&lt;em&gt;Â (&lt;/em&gt;2008).&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f37ab8144763&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://levelup.gitconnected.com/systems-thinking-in-an-ai-era-f37ab8144763&quot;&gt;Systems Thinking in an AI Era&lt;/a&gt; was originally published in &lt;a href=&quot;https://levelup.gitconnected.com&quot;&gt;Level Up Coding&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content:encoded>
    </item>
    <item>
      <title>Python Advanced: 11 Performance Patterns for Data Engineers</title>
      <link>https://levelup.gitconnected.com/python-advanced-11-performance-patterns-for-data-engineers-6e40e5231c68?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/python-advanced-11-performance-patterns-for-data-engineers-6e40e5231c68?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:51 GMT</pubDate>
      <content:encoded>&lt;div class=&quot;medium-feed-item&quot;&gt;&lt;p class=&quot;medium-feed-image&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/python-advanced-11-performance-patterns-for-data-engineers-6e40e5231c68?source=rss----5517fd7b58a6---4&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2600/1*S57qOqI-VL8KWQt96bnQ3Q.jpeg&quot; width=&quot;3932&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;medium-feed-snippet&quot;&gt;Practical speed techniques that let Python punch above its weight in real-world data pipelines.&lt;/p&gt;&lt;p class=&quot;medium-feed-link&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/python-advanced-11-performance-patterns-for-data-engineers-6e40e5231c68?source=rss----5517fd7b58a6---4&quot;&gt;Continue reading on Level Up Coding Â»&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content:encoded>
    </item>
    <item>
      <title>Stop Ignoring Outliers: 10 Data Cleaning Tricks I Wish I Knew Earlier (Pandas &amp; NumPy 2026)</title>
      <link>https://levelup.gitconnected.com/stop-ignoring-outliers-10-data-cleaning-tricks-i-wish-i-knew-earlier-pandas-numpy-2026-1dafcc786511?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/stop-ignoring-outliers-10-data-cleaning-tricks-i-wish-i-knew-earlier-pandas-numpy-2026-1dafcc786511?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:49 GMT</pubDate>
      <content:encoded>&lt;div class=&quot;medium-feed-item&quot;&gt;&lt;p class=&quot;medium-feed-image&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/stop-ignoring-outliers-10-data-cleaning-tricks-i-wish-i-knew-earlier-pandas-numpy-2026-1dafcc786511?source=rss----5517fd7b58a6---4&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2600/1*Q-qMOCN45E2mRS7F5_YyxA.jpeg&quot; width=&quot;3000&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;medium-feed-snippet&quot;&gt;A real story: A single broken value once destroyed a full company dashboard. A sensor misfired and logged:&lt;/p&gt;&lt;p class=&quot;medium-feed-link&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/stop-ignoring-outliers-10-data-cleaning-tricks-i-wish-i-knew-earlier-pandas-numpy-2026-1dafcc786511?source=rss----5517fd7b58a6---4&quot;&gt;Continue reading on Level Up Coding Â»&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content:encoded>
    </item>
    <item>
      <title>12 Pandas DataFrame Tricks That Will Matter Most in 2026</title>
      <link>https://levelup.gitconnected.com/12-pandas-dataframe-tricks-that-will-matter-most-in-2026-02db211451e7?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/12-pandas-dataframe-tricks-that-will-matter-most-in-2026-02db211451e7?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:47 GMT</pubDate>
      <content:encoded>&lt;div class=&quot;medium-feed-item&quot;&gt;&lt;p class=&quot;medium-feed-image&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/12-pandas-dataframe-tricks-that-will-matter-most-in-2026-02db211451e7?source=rss----5517fd7b58a6---4&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2600/1*EiMTvlfR2BvK0VqLf186Wg.jpeg&quot; width=&quot;4104&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;medium-feed-snippet&quot;&gt;Pandas keeps evolving, and the new era is all about: nullable dtypes, Arrow-powered I/O, cleaner aggregations, modern chainable workflows&amp;#x2026;&lt;/p&gt;&lt;p class=&quot;medium-feed-link&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/12-pandas-dataframe-tricks-that-will-matter-most-in-2026-02db211451e7?source=rss----5517fd7b58a6---4&quot;&gt;Continue reading on Level Up Coding Â»&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content:encoded>
    </item>
    <item>
      <title>Pandas 2026: The New Data Cleaning Playbook (with Real-World Examples)</title>
      <link>https://levelup.gitconnected.com/pandas-2026-the-new-data-cleaning-playbook-with-real-world-examples-3341cfa5af34?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/pandas-2026-the-new-data-cleaning-playbook-with-real-world-examples-3341cfa5af34?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:45 GMT</pubDate>
      <content:encoded>&lt;div class=&quot;medium-feed-item&quot;&gt;&lt;p class=&quot;medium-feed-image&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/pandas-2026-the-new-data-cleaning-playbook-with-real-world-examples-3341cfa5af34?source=rss----5517fd7b58a6---4&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2600/1*En9qtgwZWH-O50-TH0WsrQ.jpeg&quot; width=&quot;6000&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;medium-feed-snippet&quot;&gt;Data cleaning is still the unglamorous 80% of every data job. But in 2026, Pandas offers far better tools, better dtypes, Arrow support&amp;#x2026;&lt;/p&gt;&lt;p class=&quot;medium-feed-link&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/pandas-2026-the-new-data-cleaning-playbook-with-real-world-examples-3341cfa5af34?source=rss----5517fd7b58a6---4&quot;&gt;Continue reading on Level Up Coding Â»&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content:encoded>
    </item>
    <item>
      <title>8 Pandas Performance Hacks for 2026 (That Actually Work)</title>
      <link>https://levelup.gitconnected.com/8-pandas-performance-hacks-for-2026-that-actually-work-0c47fd9d8a61?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/8-pandas-performance-hacks-for-2026-that-actually-work-0c47fd9d8a61?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:43 GMT</pubDate>
      <content:encoded>&lt;div class=&quot;medium-feed-item&quot;&gt;&lt;p class=&quot;medium-feed-image&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/8-pandas-performance-hacks-for-2026-that-actually-work-0c47fd9d8a61?source=rss----5517fd7b58a6---4&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2600/1*0QjRI3Jq-YvpjSqsFC6N0A.jpeg&quot; width=&quot;6000&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;medium-feed-snippet&quot;&gt;Pandas is fast when used right&amp;#x200A;&amp;#x2014;&amp;#x200A;and painfully slow when used like it&amp;#x2019;s 2015. Here are the 8 performance upgrades that actually move the&amp;#x2026;&lt;/p&gt;&lt;p class=&quot;medium-feed-link&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/8-pandas-performance-hacks-for-2026-that-actually-work-0c47fd9d8a61?source=rss----5517fd7b58a6---4&quot;&gt;Continue reading on Level Up Coding Â»&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content:encoded>
    </item>
    <item>
      <title>10 Cool CodePen Demos (January 2026)</title>
      <link>https://levelup.gitconnected.com/10-cool-codepen-demos-january-2026-b1ef86b4d201?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/10-cool-codepen-demos-january-2026-b1ef86b4d201?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:41 GMT</pubDate>
      <content:encoded>&lt;div class=&quot;medium-feed-item&quot;&gt;&lt;p class=&quot;medium-feed-image&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/10-cool-codepen-demos-january-2026-b1ef86b4d201?source=rss----5517fd7b58a6---4&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2600/0*FMppw8Nnq3WAimCI&quot; width=&quot;6000&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;medium-feed-snippet&quot;&gt;A collection of 10 cool and exciting front-end demos shared on CodePen during January 2026&lt;/p&gt;&lt;p class=&quot;medium-feed-link&quot;&gt;&lt;a href=&quot;https://levelup.gitconnected.com/10-cool-codepen-demos-january-2026-b1ef86b4d201?source=rss----5517fd7b58a6---4&quot;&gt;Continue reading on Level Up Coding Â»&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content:encoded>
    </item>
    <item>
      <title>MySQL vs PostgreSQL: How B-Tree Indexes Store Your Data Differently</title>
      <link>https://levelup.gitconnected.com/mysql-vs-postgresql-how-b-tree-indexes-store-your-data-differently-809619a6c4b8?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/mysql-vs-postgresql-how-b-tree-indexes-store-your-data-differently-809619a6c4b8?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:39 GMT</pubDate>
      <content:encoded>&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*Lt-MpUs26Xscfiapc9Q1Sg.png&quot; /&gt;&lt;/figure&gt;&lt;p&gt;Indexes are one of the most fundamental tools in a database engineerâ€™s arsenal. Most developers know &lt;em&gt;what&lt;/em&gt; an index doesâ€Šâ€”â€Šbut fewer stop to think about what actually lives insideÂ one.&lt;/p&gt;&lt;p&gt;MySQL and PostgreSQL both default to B-tree indexes, and on the surface they behave the same way. But there is a critical architectural difference hiding at the leaf level that shapes how each database stores data, and how secondary indexes work as aÂ result.&lt;/p&gt;&lt;p&gt;In this article, weâ€™ll cover what an index is, how B-trees are constructed in both MySQL and PostgreSQL, and what that difference means when it comes to secondary indexes.&lt;/p&gt;&lt;h3&gt;What is anÂ Index?&lt;/h3&gt;&lt;p&gt;When you query a database table, the database engine has to find the rows that match your conditions. Without any help, it does this by scanning every single row in the tableâ€Šâ€”â€Ša process known as a full table scan. For small tables, this is fine. For tables with millions of rows, it becomes a serious performance problem.&lt;/p&gt;&lt;p&gt;An index is a separate data structure that the database maintains alongside your table. It organizes a copy of one or more columns in a way that makes lookups fast, without having to read every row. Think of it like the index at the back of a bookâ€Šâ€”â€Šinstead of reading every page to find a topic, you jump straight to the right pageÂ number.&lt;/p&gt;&lt;p&gt;When you create an index on a column, the database keeps that structure updated as rows are inserted, updated, or deleted. You trade a small overhead on writes for a significant gain on reads. Most of the time, that is a trade worthÂ making.&lt;/p&gt;&lt;h3&gt;B-Trees&lt;/h3&gt;&lt;p&gt;The most common data structure used for database indexes is the B-tree, and it is the default in both MySQL and PostgreSQL.&lt;/p&gt;&lt;p&gt;A B-tree is a self-balancing tree where data is stored in sorted order across multiple levels. At the top sits the root node, which points to a set of internal nodes, which in turn point down to the leaf nodes at the bottom. When the database looks up a value, it starts at the root and follows the right path down the treeâ€Šâ€”â€Šcomparing values at each level until it reaches theÂ leaf.&lt;/p&gt;&lt;p&gt;Because the tree stays balanced, the number of steps needed to find any value is predictable and small, even for very large datasets. This makes B-trees especially efficient for exact lookups, range queries, and sortedÂ reads.&lt;/p&gt;&lt;p&gt;To be precise, both MySQL and PostgreSQL actually use a variant called the &lt;strong&gt;B+ tree&lt;/strong&gt;. The distinction is subtle but important: in a B+ tree, all actual data references are stored exclusively at the leaf levelâ€Šâ€”â€Šinternal nodes only hold keys used for navigation. The leaf nodes are also linked together as a doubly-linked list, which makes range scans particularly efficient since the database can walk across leaves sequentially without climbing back up theÂ tree.&lt;/p&gt;&lt;p&gt;Where MySQL and PostgreSQL diverge is not in the shape of the treeâ€Šâ€”â€Šit is in what the leaf nodes actually contain. That is where things get interesting.&lt;/p&gt;&lt;h3&gt;MySQLâ€™s Clustered Index: The Table is theÂ Tree&lt;/h3&gt;&lt;p&gt;MySQLâ€™s default storage engine, InnoDB, uses what is called a &lt;strong&gt;clustered index&lt;/strong&gt;. This means that the primary key index and the actual table data are the same structureâ€Šâ€”â€Šthe table &lt;em&gt;is&lt;/em&gt; theÂ B-tree.&lt;/p&gt;&lt;p&gt;When you define a primary key, InnoDB organizes all rows physically on disk in the order of that key. As it builds the B-tree, the leaf nodes at the bottom of the tree do not just store a reference to the rowâ€Šâ€”â€Šthey store the &lt;strong&gt;entire row data&lt;/strong&gt; directly. Every column, every value, all sitting inside the leaf nodeÂ itself.&lt;/p&gt;&lt;p&gt;If you do not define a primary key, InnoDB will silently pick a unique column to use instead, or generate a hidden 6-byte row ID to serve as one. Either way, a clustered index will alwaysÂ exist.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*YDFVVTWyXushXDqSvLDmWw.png&quot; /&gt;&lt;/figure&gt;&lt;h4&gt;Performance implications&lt;/h4&gt;&lt;p&gt;The most direct benefit of the clustered index is read performance on primary key lookups. When you query by primary key, MySQL traverses the tree and arrives at the leaf node with everything already thereâ€Šâ€”â€Šthe full row is immediately available with no additional I/O.&lt;/p&gt;&lt;p&gt;Range queries also benefit significantly. Because rows are physically stored in primary key order, scanning a range of keys means reading contiguous pages on disk. This is much more efficient than jumping around to random locations, and it plays well with how modern storage systems prefetchÂ data.&lt;/p&gt;&lt;p&gt;However, the clustered index design comes with trade-offs on the write side. Because rows must stay in sorted order, inserting a row with a primary key that falls between two existing rows can force InnoDB to rearrange data. If the relevant page is full, InnoDB splits it into two pages to make roomâ€Šâ€”â€Ša process called a &lt;strong&gt;page split&lt;/strong&gt;. Page splits are expensive and, over time, can lead to fragmentation, where pages are only partially filled and the physical order of data on disk no longer matches the logical order of theÂ tree.&lt;/p&gt;&lt;p&gt;This is why using random or unordered primary keysâ€Šâ€”â€Šlike UUIDsâ€Šâ€”â€Šis generally discouraged in MySQL. Every insert lands at a more or less random position in the tree, causing frequent page splits and fragmentation. Sequential keys, like auto-incrementing integers, always append to the end of the tree, avoiding this problem entirely.&lt;/p&gt;&lt;h3&gt;PostgreSQLâ€™s Approach: Indexes as Pointers to theÂ Heap&lt;/h3&gt;&lt;p&gt;PostgreSQL takes a different approach. The table data and the indexes are completely separate structures. Rows are stored in what PostgreSQL calls a &lt;strong&gt;heap file&lt;/strong&gt;â€Šâ€”â€Šessentially a collection of pages where rows are written largely in insertion order, without any particular sorting.&lt;/p&gt;&lt;p&gt;When PostgreSQL builds a B-tree index, the leaf nodes do not contain the row data. Instead, they store a &lt;strong&gt;tuple identifier (TID)&lt;/strong&gt;â€Šâ€”â€Ša physical pointer that records exactly which page and which slot within that page holds the actual row. Think of it as a precise address pointing into theÂ heap.&lt;/p&gt;&lt;p&gt;When you query using an index, PostgreSQL traverses the B-tree to find the matching TID, then does a second lookup into the heap file to fetch the actual row. This extra step is often called a &lt;strong&gt;heapÂ fetch&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;This design means that in PostgreSQL, no index owns the data. The heap is the source of truth, and all indexesâ€Šâ€”â€Šincluding what you might think of as the â€œprimaryâ€ oneâ€Šâ€”â€Šare simply separate structures pointing back toÂ it.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*6WAUrZ6u6a3FbkHlmV69AQ.png&quot; /&gt;&lt;/figure&gt;&lt;h4&gt;What happens when you update aÂ row&lt;/h4&gt;&lt;p&gt;This is where PostgreSQLâ€™s architecture reveals one of its more significant performance implications. In PostgreSQL, when a row is updated, PostgreSQL &lt;strong&gt;writes a brand new version of the row&lt;/strong&gt; into the heap and marks the old version as dead. It does not modify the existing rowâ€Šâ€”â€Šit creates a newÂ one.&lt;/p&gt;&lt;p&gt;Now, here is where size matters. If the updated value is larger than the original, the new row version might not fit in the same heap page. PostgreSQL will write it into a different page entirely. This is not just a heap concernâ€Šâ€”â€Šit directly affects every index on thatÂ table.&lt;/p&gt;&lt;p&gt;Since the new row version lives at a different physical location, its TID has changed. And because every index leaf node stores a TID pointing to the physical location of the row, &lt;strong&gt;every single index on that table now needs to be updated&lt;/strong&gt; to point to the new location. If your table has five indexes, all five need to reflect the new TID. This makes wide tables with many indexes particularly sensitive to frequentÂ updates.&lt;/p&gt;&lt;p&gt;There is one optimization worth knowing about: &lt;strong&gt;HOT updates&lt;/strong&gt; (Heap Only Tuple). If the updated row fits on the same heap page and the updated column is not part of any index, PostgreSQL can perform a HOT updateâ€Šâ€”â€Šwriting the new row version on the same page and leaving all indexes untouched. The old and new versions are linked together on the page, and the indexes continue pointing to the original slot, which then redirects to the latest version. This is a significant optimization, but it only applies under those specific conditions.&lt;/p&gt;&lt;p&gt;Over time, dead row versions accumulate in the heap. PostgreSQL relies on a background process called &lt;strong&gt;VACUUM&lt;/strong&gt; to clean them up, reclaim space, and keep performance from degrading. Without regular vacuuming, tables with heavy update workloads can bloat considerably, and index scans become slower as they encounter more dead tuples along theÂ way.&lt;/p&gt;&lt;h3&gt;MySQL vs PostgreSQL Index Constructionâ€Šâ€”â€ŠKey Differences&lt;/h3&gt;&lt;p&gt;At first glance, MySQL and PostgreSQL indexes look and behave the same way. Both use B+-trees. Both support fast lookups and range scans. Both are created with the same SQL syntax. But once you look at what lives inside the leaf nodes, the two databases reveal fundamentally different philosophies about where data should live and who should ownÂ it.&lt;/p&gt;&lt;p&gt;In MySQL, the primary key index &lt;em&gt;is&lt;/em&gt; the table. Row data lives directly inside the leaf nodes, which means a primary key lookup is a single, self-contained operationâ€Šâ€”â€Štraverse the tree, reach the leaf, and the full row is already there. This tight coupling between the index and the data delivers excellent read performance on primary key queries, but it also means inserts must respect the physical order of the tree, making the choice of primary key a critical performance decision.&lt;/p&gt;&lt;p&gt;In PostgreSQL, the index and the data are always separate. Leaf nodes hold nothing but a pointerâ€Šâ€”â€Ša TIDâ€Šâ€”â€Što wherever the actual row lives in the heap. Every index lookup therefore requires two steps: find the TID in the tree, then go fetch the row from the heap. This adds overhead per lookup, but it also means PostgreSQLâ€™s storage model is more flexibleâ€Šâ€”â€Šno index has special ownership of the data, and all indexes are structurally equal.&lt;/p&gt;&lt;p&gt;This difference has a cascading effect on writes. In MySQL, updating a rowâ€™s primary key is an expensive operation because the row must physically move within the tree. In PostgreSQL, updating any row means writing a new version into the heap and potentially updating every index on the table to reflect the new TIDâ€Šâ€”â€Ša cost that grows with the number of indexes on theÂ table.&lt;/p&gt;&lt;p&gt;Neither approach is strictly better. MySQLâ€™s clustered index excels in read-heavy workloads with predictable primary key access patterns. PostgreSQLâ€™s heap-based model offers more flexibility, especially for write-heavy workloads and tables with complex indexing needsâ€Šâ€”â€Šthough it requires careful attention to vacuuming and HOT update conditions to stay performant.&lt;/p&gt;&lt;h3&gt;Secondary Indexes: When the Table Has More Than One WayÂ In&lt;/h3&gt;&lt;p&gt;A primary index gives you one fast path into your data. But real applications rarely query by primary key alone. You search by email, filter by status, sort by date. This is where secondary indexes come inâ€Šâ€”â€Šand where the architectural difference between MySQL and PostgreSQL becomes even more consequential.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;MySQLâ€Šâ€”â€ŠSecondary Indexes Point to the PrimaryÂ Key&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;In MySQL, a secondary index does not point directly to the row. Instead, the leaf nodes of a secondary index store the &lt;strong&gt;primary key value&lt;/strong&gt; of the matching row. When you query using a secondary index, MySQL first traverses the secondary index tree to find the primary key, then performs a second traversal down the clustered index to retrieve the full row. This is called a &lt;strong&gt;doubleÂ lookup&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;This design has a very intentional reason behind it. Because InnoDBâ€™s rows live inside the clustered index and can physically move over timeâ€Šâ€”â€Šfor example, during page splitsâ€Šâ€”â€Šstoring a direct physical pointer in every secondary index would be a maintenance nightmare. Every time a row moved, every secondary index pointing to it would need to be updated. By storing the primary key instead, MySQL insulates secondary indexes from those physical changes. The primary key acts as a stable, logicalÂ address.&lt;/p&gt;&lt;p&gt;The trade-off is performance. Every secondary index query involves two tree traversals instead of one. This is why choosing a small, compact primary key matters in MySQLâ€Šâ€”â€Ševery secondary index carries a copy of it. A large primary key, like a UUID string, inflates the size of every secondary index on theÂ table.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;PostgreSQLâ€Šâ€”â€ŠSecondary Indexes Point to theÂ Heap&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;In PostgreSQL, a secondary index works exactly the same way as a primary oneâ€Šâ€”â€Šbecause there is no structural distinction between them. Every index, whether built on the primary key column or any other column, stores TIDs pointing directly into the heap. There is no doubleÂ lookup.&lt;/p&gt;&lt;p&gt;On the surface this sounds like an advantage, and for single-row lookups it is. But it comes with the same update cost discussed earlier. When a row is updated and its new version lands at a different heap location, every index on the tableâ€Šâ€”â€Šprimary and secondary alikeâ€Šâ€”â€Šmust be updated to reflect the new TID. The more secondary indexes a table has, the more expensive write operations become.&lt;/p&gt;&lt;p&gt;There is one meaningful optimization: if all the columns needed to satisfy a query are present within the index itself, PostgreSQL can perform an &lt;strong&gt;index-only scan&lt;/strong&gt;, skipping the heap fetch entirely. This is a powerful tool for read performance, but it requires deliberate index design and depends on the visibility map being up to dateâ€Šâ€”â€Šyet another reason regular vacuuming matters in PostgreSQL.&lt;/p&gt;&lt;h3&gt;Conclusion&lt;/h3&gt;&lt;p&gt;MySQL and PostgreSQL are both mature, battle-tested databasesâ€Šâ€”â€Šand yet, under the surface, they make very different bets about how data should be stored and accessed.&lt;/p&gt;&lt;p&gt;MySQL bets on the clustered index. By merging the primary index and the table into a single structure, it optimizes for the most common case: fetching rows by primary key. Secondary indexes pay a small price for thisâ€Šâ€”â€Ša double lookupâ€Šâ€”â€Šbut the overall model is predictable and performs well for read-heavy, primary-key-centric workloads.&lt;/p&gt;&lt;p&gt;PostgreSQL bets on separation. The heap is the source of truth, and indexes are independent structures that point into it. This gives PostgreSQL more flexibility and a simpler, more uniform index model, but it shifts the burden onto writes and requires disciplined database maintenance to stay healthy overÂ time.&lt;/p&gt;&lt;p&gt;Neither design is universally superior. The right choice depends on your workload, your query patterns, and how much control you want over the trade-offs. But understanding what actually happens inside the treeâ€Šâ€”â€Šand what sits at the leaf levelâ€Šâ€”â€Šputs you in a far better position to make those decisions with confidence.&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=809619a6c4b8&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://levelup.gitconnected.com/mysql-vs-postgresql-how-b-tree-indexes-store-your-data-differently-809619a6c4b8&quot;&gt;MySQL vs PostgreSQL: How B-Tree Indexes Store Your Data Differently&lt;/a&gt; was originally published in &lt;a href=&quot;https://levelup.gitconnected.com&quot;&gt;Level Up Coding&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content:encoded>
    </item>
    <item>
      <title>Our Company Banned AI Coding Tools. Productivity Went Up 20%. Hereâ€™s Why.</title>
      <link>https://levelup.gitconnected.com/our-company-banned-ai-coding-tools-productivity-went-up-20-heres-why-077eb325eadf?source=rss----5517fd7b58a6---4</link>
      <guid>https://levelup.gitconnected.com/our-company-banned-ai-coding-tools-productivity-went-up-20-heres-why-077eb325eadf?source=rss----5517fd7b58a6---4</guid>
      <pubDate>Thu, 12 Feb 2026 23:40:37 GMT</pubDate>
      <content:encoded>&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*VqdY8tKz6l22CwpAggFbzA.png&quot; /&gt;&lt;/figure&gt;&lt;h4&gt;Security concerns killed Copilot. Developers complained. Then metrics showed theÂ truth.&lt;/h4&gt;&lt;p&gt;October 12, 2025. The email that made developers riot.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Subject:&lt;/strong&gt; Security Policy Update: AI Coding Assistants Prohibited&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Body:&lt;/strong&gt; Effective immediately, all cloud-based AI coding tools (GitHub Copilot, Cursor, Claude Code, etc.) are banned on company devices. Security and IP concerns.&lt;/p&gt;&lt;p&gt;The Slack channel exploded. 47 messages in 10Â minutes.&lt;/p&gt;&lt;p&gt;â€œThis will kill productivity.â€&lt;br&gt; â€œHow are we supposed to compete without AI?â€&lt;br&gt; â€œIâ€™m gonna be so slowÂ now.â€&lt;/p&gt;&lt;p&gt;One senior dev threatened toÂ quit.&lt;/p&gt;&lt;p&gt;I was the VP of Engineering who signed off on the ban. I expectedÂ mutiny.&lt;/p&gt;&lt;p&gt;Six months later, Iâ€™m looking at ourÂ metrics.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Productivity is upÂ 20%.&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;The Numbers NobodyÂ Expected&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Before the ban (July-September 2025):&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Pull requests per week:Â 127&lt;/li&gt;&lt;li&gt;Average PR size: 847Â lines&lt;/li&gt;&lt;li&gt;Code review time: 6.2 hours perÂ PR&lt;/li&gt;&lt;li&gt;Bug escape rate:Â 18%&lt;/li&gt;&lt;li&gt;P0 incidents: 12&lt;/li&gt;&lt;li&gt;Developer satisfaction score:Â 3.2/5&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;After the ban (November 2025-January 2026):&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Pull requests per week: 156Â (+23%)&lt;/li&gt;&lt;li&gt;Average PR size: 423 linesÂ (-50%)&lt;/li&gt;&lt;li&gt;Code review time: 3.8 hours per PRÂ (-39%)&lt;/li&gt;&lt;li&gt;Bug escape rate: 9%Â (-50%)&lt;/li&gt;&lt;li&gt;P0 incidents: 4Â (-67%)&lt;/li&gt;&lt;li&gt;Developer satisfaction score: 4.1/5Â (+28%)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We banned AI tools expecting productivity toÂ crash.&lt;/p&gt;&lt;p&gt;Instead, every metric improved.&lt;/p&gt;&lt;h3&gt;What ActuallyÂ Happened&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Week 1: TheÂ Panic&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Developers were legitimately slower. Theyâ€™d gotten used to AI autocomplete. Typing feltÂ painful.&lt;/p&gt;&lt;p&gt;Average commit time increased 40%. I started second-guessing the decision.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Week 3: The Adjustment&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Something weird happened. PRs got smaller. Instead of massive AI-generated refactors, developers shipped focusedÂ changes.&lt;/p&gt;&lt;p&gt;Code review became faster. Reviewers could actually understand whatÂ changed.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Week 6: TheÂ Pattern&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Bugs started dropping. Not gradually. Dramatically.&lt;/p&gt;&lt;p&gt;Before: AI would suggest â€œoptimizationsâ€ that looked good but broke edge cases.&lt;br&gt; After: Developers wrote defensive code because they thought through eachÂ line.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Week 12: TheÂ Data&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;We ran the analysis. Productivity was up across everyÂ metric.&lt;/p&gt;&lt;p&gt;The team that fought the ban the hardest? They improved theÂ most.&lt;/p&gt;&lt;h3&gt;The Real Reasons AI Was Slowing UsÂ Down&lt;/h3&gt;&lt;h3&gt;1. The TrustÂ Problem&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;With AI:&lt;/strong&gt;&lt;br&gt; Developer writes prompt â†’ AI generates 200 lines â†’ Developer scans it â†’ Looks good â†’ Ship it â†’ Bug in production&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Without AI:&lt;/strong&gt;&lt;br&gt; Developer writes 50 lines â†’ Thinks through edge cases â†’ Tests manually â†’ Ships it â†’Â Works&lt;/p&gt;&lt;p&gt;AI made us lazy reviewers of our ownÂ code.&lt;/p&gt;&lt;p&gt;We stopped asking â€œwhat could go wrong?â€ because AI code looked confident.&lt;/p&gt;&lt;h3&gt;2. The ContextÂ Problem&lt;/h3&gt;&lt;p&gt;Our codebase: 847,000 lines. 8 years old. Custom architecture. Tribal knowledge everywhere.&lt;/p&gt;&lt;p&gt;AI trained on: Public GitHub repos. Generic patterns. Nothing about our specificÂ system.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Example disaster:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;AI suggested this â€œoptimizationâ€:&lt;/p&gt;&lt;pre&gt;# AI&amp;#39;s confident suggestion&lt;br&gt;@cache_result(ttl=3600)&lt;br&gt;def get_user_balance(user_id):&lt;br&gt;    return database.query(f&amp;quot;SELECT balance FROM accounts WHERE user_id={user_id}&amp;quot;)&lt;/pre&gt;&lt;p&gt;Looks fine,Â right?&lt;/p&gt;&lt;p&gt;Except our system updates balances every 30 seconds during trading hours. The 1-hour cache meant users saw stale data for 59Â minutes.&lt;/p&gt;&lt;p&gt;Cost us $47,000 in incorrect transactions before we caughtÂ it.&lt;/p&gt;&lt;p&gt;AI didnâ€™t know our business rules. Developers who trusted it didnâ€™t question the suggestion.&lt;/p&gt;&lt;h3&gt;3. The â€œLooks Goodâ€Â Problem&lt;/h3&gt;&lt;p&gt;AI code passes one test: Does it look reasonable?&lt;/p&gt;&lt;p&gt;It fails another: Does it handle the 15 edge cases specific to ourÂ domain?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Real example:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;AI-generated payment processing code looked perfect. Handled happy path beautifully.&lt;/p&gt;&lt;p&gt;What itÂ missed:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Duplicate charge prevention (2 users got chargedÂ twice)&lt;/li&gt;&lt;li&gt;Currency conversion edge cases (1 user charged in wrong currency)&lt;/li&gt;&lt;li&gt;Timeout handling (3 users got â€œfailedâ€ message but wereÂ charged)&lt;/li&gt;&lt;li&gt;Race conditions (4 concurrent requests created 4Â charges)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Manual code wouldâ€™ve been slower to write. But we wouldâ€™ve thought through theseÂ cases.&lt;/p&gt;&lt;h3&gt;4. The Knowledge TransferÂ Problem&lt;/h3&gt;&lt;p&gt;Junior developer joins. Asks: â€œWhy does this function work thisÂ way?â€&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Before ban:&lt;/strong&gt;&lt;br&gt; Senior: â€œI donâ€™t know, AI wrote it. Let me checkâ€¦â€&lt;br&gt; &lt;em&gt;Checks code&lt;/em&gt;&lt;br&gt; â€œHonestly, Iâ€™m not sure. It worksÂ though.â€&lt;/p&gt;&lt;p&gt;&lt;strong&gt;After ban:&lt;/strong&gt;&lt;br&gt; Senior: â€œBecause we need to handle timezone conversions before comparing dates. Let me show you whyâ€¦â€&lt;br&gt; &lt;em&gt;Actually explains the businessÂ logic&lt;/em&gt;&lt;/p&gt;&lt;p&gt;AI code created knowledge silos. Only AI knew why itÂ worked.&lt;/p&gt;&lt;h3&gt;5. The Code Review TheaterÂ Problem&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Before ban:&lt;/strong&gt;&lt;br&gt; â€œLGTM ğŸ‘â€ (didnâ€™t actually read the 800 AI-generated lines)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;After ban:&lt;/strong&gt;&lt;br&gt; â€œWhy did you choose HashMap over TreeMap here?â€&lt;br&gt; â€œThis method is doing too much. Can we split it?â€&lt;br&gt; â€œWhat happens if the API timesÂ out?â€&lt;/p&gt;&lt;p&gt;Real code review cameÂ back.&lt;/p&gt;&lt;h3&gt;The One Thing That Surprised MeÂ Most&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Developer satisfaction wentÂ UP.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;I expected developers to hate the ban. They loved AI autocomplete.&lt;/p&gt;&lt;p&gt;But after 3 months, satisfaction scores jumped from 3.2 toÂ 4.1.&lt;/p&gt;&lt;p&gt;Why?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Before (with AI):&lt;/strong&gt; â€œI spent 2 hours fighting with Copilot suggestions. It kept suggesting broken code. Then spent 4 hours debugging the code I accepted.â€&lt;/p&gt;&lt;p&gt;&lt;strong&gt;After (without AI):&lt;/strong&gt; â€œCoding feels slower but Iâ€™m not debugging AI hallucinations. I ship features and theyÂ work.â€&lt;/p&gt;&lt;p&gt;Turns out, fighting with AI was more frustrating than writing code manually.&lt;/p&gt;&lt;h3&gt;What We Kept (AndÂ Why)&lt;/h3&gt;&lt;p&gt;We didnâ€™t ban ALL AI. We banned coding assistants.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;What we stillÂ use:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. ChatGPT for documentation&lt;/strong&gt;&lt;br&gt; â€œExplain this legacy Java codeâ€ â†’ Actually useful&lt;br&gt; Not generating code, just explaining it&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. AI for test generation&lt;/strong&gt;&lt;br&gt; Generate unit test templates â†’ Developer reviews and modifies&lt;br&gt; Speeds up the boring part, developer stillÂ thinks&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. Code review AI (self-hosted)&lt;/strong&gt;&lt;br&gt; Runs on our infrastructure, doesnâ€™t send code to cloud&lt;br&gt; Catches obvious issues (unused variables, SQL injection patterns)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4. AI for log analysis&lt;/strong&gt;&lt;br&gt; Perfect use case. AI reads thousands of log lines, highlights patterns&lt;br&gt; Human still debugs, AI just filtersÂ noise&lt;/p&gt;&lt;p&gt;The pattern: &lt;strong&gt;AI as assistant, notÂ author.&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;The Controversial Part&lt;/h3&gt;&lt;p&gt;Some developers still disagree with theÂ ban.&lt;/p&gt;&lt;p&gt;â€œIâ€™m faster with AI. I know how to use it properly.â€&lt;/p&gt;&lt;p&gt;Theyâ€™re right. Some developers ARE faster withÂ AI.&lt;/p&gt;&lt;p&gt;But hereâ€™s the thing: &lt;strong&gt;Weâ€™re not optimizing for individual speed. Weâ€™re optimizing for teamÂ quality.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;One developer shipping fast with AI-generated bugs costs the team more than five developers shipping slower with cleanÂ code.&lt;/p&gt;&lt;p&gt;We measured it. AI-generated code had 3.2x more bugs per line than human-written code.&lt;/p&gt;&lt;h3&gt;ğŸ“¬ What Iâ€™m WorkingÂ On&lt;/h3&gt;&lt;p&gt;While banning AI coding tools, I realized thereâ€™s ONE place AI actually helps: &lt;strong&gt;production incidents.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Not writing code. Explaining what wentÂ wrong.&lt;/p&gt;&lt;p&gt;Iâ€™m building &lt;strong&gt;ProdRescue AI&lt;/strong&gt;â€Šâ€”â€Šturns messy incident logs into clear postmortem reports in 90Â seconds.&lt;/p&gt;&lt;p&gt;No code generation. Just log analysis and reportÂ writing.&lt;/p&gt;&lt;p&gt;Early access is open:&lt;br&gt; ğŸ‘‰ &lt;strong&gt;Join the waitlist (2-minÂ form)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://prodrescue-ai.vercel.app/&quot;&gt;ProdRescue AI&lt;/a&gt;&lt;/p&gt;&lt;p&gt;This is AI used right: analyzing data, not generating code.&lt;/p&gt;&lt;h3&gt;What Other Companies AreÂ Doing&lt;/h3&gt;&lt;p&gt;Weâ€™re not alone. After sharing our results internally, I talked to 12 otherÂ CTOs.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3 companies banned AI coding tools completely&lt;/strong&gt; (same results as us)&lt;br&gt; &lt;strong&gt;5 companies restricted to senior engineers only&lt;/strong&gt; (juniors canâ€™t use AI)&lt;br&gt; &lt;strong&gt;4 companies still allow it&lt;/strong&gt; (but reconsidering after seeingÂ metrics)&lt;/p&gt;&lt;p&gt;The trend: Companies measuring productivity are pulling back onÂ AI.&lt;/p&gt;&lt;p&gt;Companies not measuring? Still pushing AI everywhere.&lt;/p&gt;&lt;h3&gt;The RealÂ Lesson&lt;/h3&gt;&lt;p&gt;AI coding tools solve the wrongÂ problem.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;The problem isnâ€™t:&lt;/strong&gt; â€œHow do I write code faster?â€&lt;br&gt; &lt;strong&gt;The problem is:&lt;/strong&gt; â€œHow do I write code that works in production?â€&lt;/p&gt;&lt;p&gt;AI optimizes for speed. Production requires reliability.&lt;/p&gt;&lt;p&gt;We chose reliability. Productivity followed.&lt;/p&gt;&lt;h3&gt;If Youâ€™re Dealing With Production Failures&lt;/h3&gt;&lt;p&gt;The ban taught us: Prevention beats debugging.&lt;/p&gt;&lt;p&gt;Writing careful code manually prevents more bugs than AI speedÂ creates.&lt;/p&gt;&lt;p&gt;If youâ€™re tired of production incidents, these resources mightÂ help:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ğŸ”§ &lt;/strong&gt;&lt;a href=&quot;https://devrimozcay.gumroad.com/l/rlmxr&quot;&gt;&lt;strong&gt;Production Engineering Toolkit&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; Real production failures and how to preventÂ them&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ğŸ“š &lt;/strong&gt;&lt;a href=&quot;https://devrimozcay.gumroad.com/l/rkdgug&quot;&gt;&lt;strong&gt;Backend Performance Rescue Kit&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; Find and fix the 20 bottlenecks killing yourÂ app&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ğŸ¯ &lt;/strong&gt;&lt;a href=&quot;https://devrimozcay.gumroad.com/l/xbihfx&quot;&gt;&lt;strong&gt;30 Real Incidents That Cost Companies Thousands&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; Full postmortems with prevention steps&lt;/p&gt;&lt;p&gt;More resources: &lt;a href=&quot;https://devrimozcay.gumroad.com/&quot;&gt;&lt;strong&gt;devrimozcay.gumroad.com&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;The Metrics After 6Â Months&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;January 2026 (Month 6 post-ban):&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Pull requests per week: 167 (+31% vs baseline)&lt;/li&gt;&lt;li&gt;Code review time: 3.2 hoursÂ (-48%)&lt;/li&gt;&lt;li&gt;Bug escape rate: 7%Â (-61%)&lt;/li&gt;&lt;li&gt;P0 incidents: 2Â (-83%)&lt;/li&gt;&lt;li&gt;Developer satisfaction: 4.3/5Â (+34%)&lt;/li&gt;&lt;li&gt;Time debugging: -12 hours per week per developer&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;The most surprising metric:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Developer velocity (features shipped per sprint) went upÂ 18%.&lt;/p&gt;&lt;p&gt;We were worried banning AI would slow feature development.&lt;/p&gt;&lt;p&gt;Turns out, fewer bugs means more time building features.&lt;/p&gt;&lt;h3&gt;What Iâ€™d Tell My PastÂ Self&lt;/h3&gt;&lt;p&gt;October 2025, before the ban, I wasÂ scared.&lt;/p&gt;&lt;p&gt;â€œWhat if productivity crashes? What if developers quit? What if we fall behind competitors?â€&lt;/p&gt;&lt;p&gt;Now I know: &lt;strong&gt;The metrics donâ€™tÂ lie.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;AI coding tools made us FEEL productive. They made us actuallyÂ slower.&lt;/p&gt;&lt;p&gt;Would I ban AI again?Â Yes.&lt;/p&gt;&lt;p&gt;Would I use AI for other things? Yes. (Log analysis, documentation, test generation)&lt;/p&gt;&lt;p&gt;The lesson: &lt;strong&gt;AI is a tool. Not all tools fit all problems.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;For code generation? We found a better tool: human developers whoÂ think.&lt;/p&gt;&lt;h3&gt;The Uncomfortable Truth&lt;/h3&gt;&lt;p&gt;This article will make peopleÂ angry.&lt;/p&gt;&lt;p&gt;â€œAI makes ME faster!â€ (Maybe. But does it make your team faster?)&lt;br&gt; â€œYou just donâ€™t know how to use AI!â€ (We had 6 months of data.)&lt;br&gt; â€œMy company would never ban AI!â€ (Thatâ€™s fine. Measure your metrics.)&lt;/p&gt;&lt;p&gt;Iâ€™m not saying AI coding tools are bad for everyone.&lt;/p&gt;&lt;p&gt;Iâ€™m saying: &lt;strong&gt;Measure before assuming.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;We assumed AI would help. Metrics showed itÂ hurt.&lt;/p&gt;&lt;p&gt;Maybe your metrics are different. Great! ShareÂ them.&lt;/p&gt;&lt;p&gt;But if youâ€™ve never measured productivity with vs without AI, youâ€™re guessing.&lt;/p&gt;&lt;p&gt;We stopped guessing. Started measuring.&lt;/p&gt;&lt;h3&gt;One Year LaterÂ (Update)&lt;/h3&gt;&lt;p&gt;Itâ€™s been a year since theÂ ban.&lt;/p&gt;&lt;p&gt;Developers who threatened to quit? Still here. They admit theyâ€™reÂ happier.&lt;/p&gt;&lt;p&gt;Metrics? Still better thanÂ before.&lt;/p&gt;&lt;p&gt;Competitors who went all-in on AI? Some are rolling back. Others are dealing with increased bugÂ rates.&lt;/p&gt;&lt;p&gt;The industry is learning: &lt;strong&gt;Fast code generation â‰  GoodÂ code.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;We learned early. Paid the price. GotÂ better.&lt;/p&gt;&lt;p&gt;Your company will decide forÂ itself.&lt;/p&gt;&lt;p&gt;Just measure the real metrics. Not â€œdeveloper happiness with AIÂ tools.â€&lt;/p&gt;&lt;p&gt;Measure: Bugs in production. Time debugging. Code quality. Feature velocity.&lt;/p&gt;&lt;p&gt;Then decide.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;â€” The developers who fought the ban hardest? Theyâ€™re now the biggest advocates. They didnâ€™t realize how much time they spent debugging AI code until theyÂ stopped.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;â€” We still ban AI coding tools. We still measure metrics. Productivity is still up 20%. I donâ€™t see us reversing this decision.&lt;/strong&gt;&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=077eb325eadf&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://levelup.gitconnected.com/our-company-banned-ai-coding-tools-productivity-went-up-20-heres-why-077eb325eadf&quot;&gt;Our Company Banned AI Coding Tools. Productivity Went Up 20%. Hereâ€™s Why.&lt;/a&gt; was originally published in &lt;a href=&quot;https://levelup.gitconnected.com&quot;&gt;Level Up Coding&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content:encoded>
    </item>
  </channel>
</rss>