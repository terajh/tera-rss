<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>dev RSS - Velog</title>
    <link>https://velog.io</link>
    <description>Velog RSS 피드</description>
    <lastBuildDate>Sun, 15 Feb 2026 06:52:52 GMT</lastBuildDate>
    <item>
      <title>tiktok video downloader</title>
      <link>https://velog.io/@downloadtiktok1/tiktok-video-downloader</link>
      <guid>https://velog.io/@downloadtiktok1/tiktok-video-downloader</guid>
      <pubDate>Sun, 15 Feb 2026 06:22:05 GMT</pubDate>
      <content:encoded>&lt;p&gt;SnapTik is a fast and free &lt;a href=&quot;https://tiktokvideodownloader.id/&quot;&gt;TikTok downloader&lt;/a&gt; that lets you save videos in HD, Full HD, or 4K MP4 without watermarks.This TikTok downloader works instantly on any device with no installation required.&lt;/p&gt;</content:encoded>
    </item>
    <item>
      <title>프로그래머스 97일</title>
      <link>https://velog.io/@korjje617/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-97%EC%9D%BC</link>
      <guid>https://velog.io/@korjje617/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-97%EC%9D%BC</guid>
      <pubDate>Sun, 15 Feb 2026 06:21:25 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;a href=&quot;https://school.programmers.co.kr/learn/courses/30/lessons/120825&quot;&gt;https://school.programmers.co.kr/learn/courses/30/lessons/120825&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;문자-반복-출력하기&quot;&gt;문자 반복 출력하기&lt;/h3&gt;
        &lt;p&gt;문자열 my_string과 정수 n이 매개변수로 주어질 때, &lt;/p&gt;
        &lt;p&gt;my_string에 들어있는 각 문자를 n만큼 반복한 문자열을 return 하도록 &lt;/p&gt;
        &lt;p&gt;solution 함수를 완성해보세요.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/korjje617/post/461be544-f372-4496-9ece-9f59d588085b/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;이건 반복문 문제이긴 한데
        반복문을 대체할 수 있는 재귀함수로 풀어볼까 한다&lt;/p&gt;
        &lt;p&gt;재귀함수의 조건&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;종료 조건 (base case)&lt;/li&gt;
        &lt;li&gt;현재 단계 처리&lt;/li&gt;
        &lt;li&gt;현재 결과 반환 + 문제를 줄여서 자기 자신 호출&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;재귀함수의 기본 형태&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static String function(매개변수) {
        
        if (종료조건) {
        return 종료값;
        }
        
        // 현재 단계 처리
        
        return 현재결과 + 줄어든 문제;
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;필요할 것 같은 문법은&lt;/p&gt;
        &lt;p&gt;substring : 문자열을 앞에서부터 잘라준다
        문자열.charAt(순서) : 문자열의 (순서) 위치에 있는 문자를 추출
        문자열.repeat(반복할 횟수) : 반복할 횟수만큼 문자열 값 반복
        String.valueOf(변수명) : 해당 변수를 문자열로 변환&lt;/p&gt;
        &lt;p&gt;문자를 반복하려면 문자열을 할 수 밖에 없다...&lt;/p&gt;
        &lt;hr&gt;
        &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;
        
        class Solution {
        public String solution(String my_string, int n) {
        return answer(my_string, n);
        }
        
        private String answer (String my_string, int n) {
        if (/*종료조건*/) {
        return &amp;quot;???&amp;quot;;
        }
        
        return &amp;quot;aaa&amp;quot;;
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;일단 솔루션에는 answer 메서드를 실행한 값을 반환한다고 하고
        answer 메서드는 String 반환으로 만들어줬다
        아직 뭐 짤지 몰라서 ??? 랑 aaa 문자열 반환하는걸로 했다&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;일단 재귀쪽에서 해야할건&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;문자열의 첫번째 문자를 추출한다
        문자를 문자열로 바꾼다
        n만큼 반복시킨다
        처음 문자열의 첫번째 문자를 잘라낸다&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;그럼 종료 조건은 my_string 길이가 0이 될 때다&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;여기서 하나 또 까먹었던 점
        문자열 길이를 구할 떈
        문자열.length()
        소괄호가 필요하다&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;
        
        class Solution {
        public String solution(String my_string, int n) {
        return answer(my_string, n);
        }
        
        private String answer (String my_string, int n) {
        if (my_string.length() == 0) {
        return &amp;quot;???&amp;quot;;
        }
        
        return &amp;quot;aaa&amp;quot;;
        }
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;일단 테스트에서 aaa 값이 나온다
        아직 오류는 없다는 뜻&lt;/p&gt;
        &lt;p&gt;그 다음에 문자 추출하고, 문자열로 바꿔서, 반복한다&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;
        
        class Solution {
        public String solution(String my_string, int n) {
        return answer(my_string, n);
        }
        
        private String answer (String my_string, int n) {
        if (my_string.length() == 0) {
        return &amp;quot;???&amp;quot;;
        }
        
        char strBit = my_string.charAt(0);
        String repeat = String.valueOf(strBit).repeat(n);
        
        return repeat;
        }
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;strBit 로 문자열 0번째에 있는 문자를
        문자열로 바꿔서 반복하고 repeat 변수에 넣어줬다&lt;/p&gt;
        &lt;p&gt;결과 : hhh 반복&lt;/p&gt;
        &lt;p&gt;뭐가 제대로 실행이 되고있긴 하다&lt;/p&gt;
        &lt;p&gt;이제 다음에 할 건 my_string 의 0번째 값을 잘라내주는거&lt;/p&gt;
        &lt;p&gt;현재결과 + 줄어든 문제 ?? 이건 무슨 뜻이지 싶어서 검색해봤는데
        재귀함수는 결과를 계속 쌓아가는 구조
        그러니까 현재 나온 결과를 계속 더해서 보내줘야 결과가 쌓인다
        잘 모르겠는데 일단 천천히 생각을 좀 해보자&lt;/p&gt;
        &lt;p&gt;문자열 + (정수 실수 문자 기타등등) = 통으로 문자열이 된다
        &lt;code&gt;&amp;quot;a&amp;quot; + 1 = &amp;quot;a1&amp;quot;&lt;/code&gt;
        repeat 는 문자열이다&lt;/p&gt;
        &lt;p&gt;return repeat + answer 라고 한다면?
        문자열 repeat 변수에 answer 의 결과가 계속 추가되는 구조다&lt;/p&gt;
        &lt;p&gt;그럼 repeat + answer(my_string.substring(1), n)
        이렇게 되는걸까???? &lt;/p&gt;
        &lt;p&gt;my_string 의 첫번째 자리를 계속 잘라내기?
        이거 답 구하면 총체적으로 정리를 한번 해야겠다 풀면서 생각 쓰느라 너무 중구난방이다&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;
        
        class Solution {
        public String solution(String my_string, int n) {
        return answer(my_string, n);
        }
        
        private String answer (String my_string, int n) {
        if (my_string.length() == 0) {
        return &amp;quot;???&amp;quot;;
        }
        
        char strBit = my_string.charAt(0);
        String repeat = String.valueOf(strBit).repeat(n);
        
        return repeat + answer(my_string.substring(1), n);
        }
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;일단 실행먼저 해보니까 결과가 
        &amp;quot;hhheeellllllooo???&amp;quot;&lt;/p&gt;
        &lt;p&gt;물음표를 떼야되겠네&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/korjje617/post/ec04582d-d239-4884-820d-996e455b24e9/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;이게 된다고? 이게 됐다고??&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/korjje617/post/d1dc6a64-2cc4-4412-95d4-87cd970d8576/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;이걸 통과했다&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;이제 정리를 좀 해보자&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;
        
        class Solution {
        
        // 외부에서 호출되는 메서드
        // 재귀 함수(answer)를 호출하여 최종 결과를 반환
        public String solution(String my_string, int n) {
        return answer(my_string, n);
        }
        
        // 실제로 재귀를 수행하는 메서드
        private String answer(String my_string, int n) {
        
        // 1. 종료 조건 (더 이상 처리할 문자가 없을 때)
        // 문자열 길이가 0이면 빈 문자열 반환
        if (my_string.length() == 0) {
        return &amp;quot;&amp;quot;;
        }
        
        // 2. 현재 단계 처리
        // 문자열의 첫 번째 문자 추출
        char strBit = my_string.charAt(0);
        
        // 추출한 문자를 n번 반복하여 문자열 생성
        String repeat = String.valueOf(strBit).repeat(n);
        
        // 3. 재귀 호출
        // 첫 글자를 제외한 나머지 문자열을 다시 처리
        // 현재 반복 결과 + 나머지 재귀 결과를 이어 붙여 반환
        return repeat + answer(my_string.substring(1), n);
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;한번 해본건데 생각보다 괜찮은 것 같다
        시간복잡도 아예 신경 안쓰고 코드 길이도 신경 안쓰고
        반복문을 사용하지 않고 반복하는 법을 훈련하고 싶어서
        예전에 재귀함수로 푼 사람이 떠올라서 나도 한번 해봤다...&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Z8slot Digital Platform Review: Observational Mastery and Consistent Engagement</title>
      <link>https://velog.io/@contenthubsuite/Z8slot-Digital-Platform-Review-Observational-Mastery-and-Consistent-Engagement</link>
      <guid>https://velog.io/@contenthubsuite/Z8slot-Digital-Platform-Review-Observational-Mastery-and-Consistent-Engagement</guid>
      <pubDate>Sun, 15 Feb 2026 06:20:49 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;a href=&quot;https://z8slot.win&quot;&gt;Z8slot&lt;/a&gt; stands out as an online gaming platform that combines stable technical performance with dynamic, feature-rich content. Its interface is streamlined and easy to navigate, allowing players to browse categories, access new titles, and revisit favorites without distraction. Reliable performance across desktop and mobile devices ensures smooth gameplay, which is particularly important for players engaged in extended sessions where timing, observation, and strategic engagement are key.&lt;/p&gt;
        &lt;p&gt;The platform’s library emphasizes games designed with layered interactive mechanics. Titles frequently include cascading combinations, multiplier sequences, expanding symbols, and structured bonus rounds. These features create variable pacing, requiring players to remain attentive and adaptable. Community guidance often suggests reviewing in-game instructions and understanding feature behavior prior to longer sessions. Familiarity with mechanics such as trigger conditions and sequence patterns allows users to develop strategic approaches, enhancing both engagement and overall session satisfaction.&lt;/p&gt;
        &lt;p&gt;Observation is central to success on Z8slot. Some games gradually build intensity before entering enhanced rounds, while others maintain consistent interactive features. Recognizing these patterns enables players to anticipate feature activation and better align their timing with game mechanics. Focusing on a single title during a session, rather than rapidly switching between games, encourages mastery, improves timing awareness, and supports deliberate engagement.&lt;/p&gt;
        &lt;p&gt;Session management is a key strategy emphasized by the Z8slot community. Players often define objectives such as exploring new releases, mastering favorite titles, or participating in themed challenges. Establishing time boundaries ensures balanced participation, while post-session reflection helps players assess outcomes, track feature frequency, and refine strategies for future play. This disciplined approach promotes consistency and sustained engagement across multiple sessions.&lt;/p&gt;
        &lt;p&gt;Z8slot also offers seasonal events, leaderboard campaigns, and special challenges that provide structured objectives. These activities encourage purposeful participation while promoting exploration of diverse game mechanics. Players benefit from the combination of interactive features and goal-oriented activities, which enhances both engagement and strategic thinking.&lt;/p&gt;
        &lt;p&gt;The community aspect further enriches the experience. Players frequently exchange observations on feature behavior, session strategies, and pacing techniques. Discussions often focus on predicting cascading sequences, timing multipliers, and optimizing bonus interactions. This shared knowledge allows users to approach gameplay more thoughtfully, refining their strategies based on collective insights.&lt;/p&gt;
        &lt;p&gt;In summary, Z8slot provides a comprehensive online gaming environment where technical reliability, layered mechanics, and strategic engagement intersect. By emphasizing observation, preparation, and focused participation, the platform enables players to approach sessions with awareness and deliberate decision-making. Whether exploring new titles, mastering interactive features, or participating in structured challenges, Z8slot delivers an immersive, rewarding, and skill-enhancing online gaming experience.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Superwin Digital Experience: Advanced Mechanics and Focused Play</title>
      <link>https://velog.io/@contenthubsuite/Superwin-Digital-Experience-Advanced-Mechanics-and-Focused-Play</link>
      <guid>https://velog.io/@contenthubsuite/Superwin-Digital-Experience-Advanced-Mechanics-and-Focused-Play</guid>
      <pubDate>Sun, 15 Feb 2026 06:19:48 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;a href=&quot;https://ph-superwin.com&quot;&gt;Superwin&lt;/a&gt; has built a reputation among online gaming communities as a platform that merges stability, engaging content, and strategic depth. The interface is designed with clarity, allowing players to navigate categories effortlessly, access new releases, and revisit favorite titles without confusion. Fast and responsive performance across desktop and mobile devices ensures smooth gameplay, which is especially important for players who prefer extended sessions where attention to timing and features is crucial. The platform’s stability enables users to focus on strategic engagement rather than technical distractions.&lt;/p&gt;
        &lt;p&gt;The platform offers a diverse library of feature-rich games, emphasizing interactive mechanics that reward observation and patience. Many titles incorporate cascading sequences, multiplier chains, expanding symbols, and structured bonus rounds that unfold based on specific conditions. These features introduce dynamic pacing, requiring players to adapt and remain attentive. Experienced users often recommend studying in-game information panels before longer sessions, as understanding how features trigger and progress allows for a more deliberate approach. Familiarity with these mechanics supports both effective timing and improved engagement.&lt;/p&gt;
        &lt;p&gt;Strategic awareness is a central aspect of Superwin gameplay. Some games build anticipation gradually before activating feature-rich rounds, while others maintain frequent interactive moments. Observing gameplay patterns in the early rounds helps players identify pacing, volatility, and feature frequency. Focusing on a single game for an extended session encourages deeper understanding of mechanics, strengthens timing awareness, and facilitates more deliberate decision-making. Rapid switching between titles is generally less effective than concentrated play when seeking to master a game’s structure.&lt;/p&gt;
        &lt;p&gt;Session planning is another cornerstone of the Superwin experience. Many players define objectives at the start of each visit, whether testing new releases, participating in leaderboard events, or exploring specific categories. Setting clear time boundaries ensures that sessions remain structured, promoting balance and minimizing unstructured play. Post-session reflection is equally important; reviewing feature activations, analyzing outcomes, and noting pacing allows players to refine strategies and improve future sessions.&lt;/p&gt;
        &lt;p&gt;The platform also incorporates seasonal events, thematic challenges, and leaderboard competitions, which provide measurable objectives and motivate purposeful participation. These structured activities encourage exploration of different game mechanics while maintaining engagement over extended sessions. Players benefit from the combination of interactive features and defined goals, which enhances both challenge and enjoyment.&lt;/p&gt;
        &lt;p&gt;Community engagement adds further value to the Superwin experience. Players share insights on feature mechanics, session strategies, and pacing techniques. Topics frequently discussed include predicting cascading sequences, timing multipliers effectively, and optimizing bonus interactions. This collaborative knowledge base allows users to approach gameplay more strategically and learn from shared observations.&lt;/p&gt;
        &lt;p&gt;In conclusion, Superwin delivers a comprehensive online gaming experience that emphasizes stability, layered mechanics, and structured engagement. By encouraging observation, preparation, and strategic play, the platform supports both immersive entertainment and skill development. Whether exploring new releases, mastering favorite titles, or participating in seasonal campaigns, Superwin provides a digital environment that promotes thoughtful, focused, and rewarding gameplay.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>[프로그래머스] 스택/큐 - 다리를 지나는 트럭</title>
      <link>https://velog.io/@mark77234/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8A%A4%ED%83%9D%ED%81%90-%EB%8B%A4%EB%A6%AC%EB%A5%BC-%EC%A7%80%EB%82%98%EB%8A%94-%ED%8A%B8%EB%9F%AD</link>
      <guid>https://velog.io/@mark77234/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8A%A4%ED%83%9D%ED%81%90-%EB%8B%A4%EB%A6%AC%EB%A5%BC-%EC%A7%80%EB%82%98%EB%8A%94-%ED%8A%B8%EB%9F%AD</guid>
      <pubDate>Sun, 15 Feb 2026 06:19:30 GMT</pubDate>
      <content:encoded>
        &lt;h2 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h2&gt;
        &lt;p&gt;트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.&lt;/p&gt;
        &lt;p&gt;예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.&lt;/p&gt;
        &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
        &lt;th&gt;경과 시간&lt;/th&gt;
        &lt;th&gt;다리를 지난 트럭&lt;/th&gt;
        &lt;th&gt;다리를 건너는 트럭&lt;/th&gt;
        &lt;th&gt;대기 트럭&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
        &lt;td&gt;0&lt;/td&gt;
        &lt;td&gt;[]&lt;/td&gt;
        &lt;td&gt;[]&lt;/td&gt;
        &lt;td&gt;[7,4,5,6]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;1~2&lt;/td&gt;
        &lt;td&gt;[]&lt;/td&gt;
        &lt;td&gt;[7]&lt;/td&gt;
        &lt;td&gt;[4,5,6]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;3&lt;/td&gt;
        &lt;td&gt;[7]&lt;/td&gt;
        &lt;td&gt;[4]&lt;/td&gt;
        &lt;td&gt;[5,6]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;4&lt;/td&gt;
        &lt;td&gt;[7]&lt;/td&gt;
        &lt;td&gt;[4,5]&lt;/td&gt;
        &lt;td&gt;[6]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;5&lt;/td&gt;
        &lt;td&gt;[7,4]&lt;/td&gt;
        &lt;td&gt;[5]&lt;/td&gt;
        &lt;td&gt;[6]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;6~7&lt;/td&gt;
        &lt;td&gt;[7,4,5]&lt;/td&gt;
        &lt;td&gt;[6]&lt;/td&gt;
        &lt;td&gt;[]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;8&lt;/td&gt;
        &lt;td&gt;[7,4,5,6]&lt;/td&gt;
        &lt;td&gt;[]&lt;/td&gt;
        &lt;td&gt;[]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/tbody&gt;&lt;/table&gt;
        &lt;p&gt;solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.&lt;/p&gt;
        &lt;h3 id=&quot;제한-조건&quot;&gt;제한 조건&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;bridge_length는 1 이상 10,000 이하입니다.&lt;/li&gt;
        &lt;li&gt;weight는 1 이상 10,000 이하입니다.&lt;/li&gt;
        &lt;li&gt;truck_weights의 길이는 1 이상 10,000 이하입니다.&lt;/li&gt;
        &lt;li&gt;모든 트럭의 무게는 1 이상 weight 이하입니다.&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h3 id=&quot;입출력-예&quot;&gt;입출력 예&lt;/h3&gt;
        &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
        &lt;th&gt;bridge_length&lt;/th&gt;
        &lt;th&gt;weight&lt;/th&gt;
        &lt;th&gt;truck_weights&lt;/th&gt;
        &lt;th&gt;return&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
        &lt;td&gt;2&lt;/td&gt;
        &lt;td&gt;10&lt;/td&gt;
        &lt;td&gt;[7,4,5,6]&lt;/td&gt;
        &lt;td&gt;8&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;100&lt;/td&gt;
        &lt;td&gt;100&lt;/td&gt;
        &lt;td&gt;[10]&lt;/td&gt;
        &lt;td&gt;101&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;100&lt;/td&gt;
        &lt;td&gt;100&lt;/td&gt;
        &lt;td&gt;[10,10,10,10,10,10,10,10,10,10]&lt;/td&gt;
        &lt;td&gt;110&lt;/td&gt;
        &lt;/tr&gt;
        &lt;/tbody&gt;&lt;/table&gt;
        &lt;hr&gt;
        &lt;p&gt;와 이 문제 개어려웠음
        내 맘대로 풀다 나락갔음 근데 좀 아까웠 ㅋ&lt;/p&gt;
        &lt;p&gt;내 오답 코드를 같이 봅시다&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;p&gt;난 일단 지나간 트럭, 다리에 있는 트럭, 아직 지나지 않은 트럭 이렇게 3가지 큐를 선언하고&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;지나간 트럭 큐의 길이가 지나지 않았던 트럭들의 길이와 동일해질때까지 while문 조건을 걸었다.&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;지나지 않은 트럭 큐가 살아있는 동안 다리의 무게 + 움직일 트럭 첫번째랑 제한 무게 비교 + 다리길이가 넘어가는지를 검사하고 불충족할경우 while문 탈출시킴&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;조건 성립한 경우에는 다리에 트럭을 추가하고 시간 +1&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;트럭이 모두 움직였을 경우(조건문 불충족해서 다리를 건너야 하는 경우) 난 다리에 있는 트럭들을 한번에 탈출시킨다고 다리 길이를 시간에 더해버렸다.&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;그리고 다리에 남아있는 큐 다 없애고 지나간 트럭들 큐에 붙여주고(extend) 그리고 남아있는 트럭 큐가 존재하면 다리로 이동까지 시켜줌&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;이러면 테스트 입출력은 통과해서 난 맞춘 줄 알았는데 실패뜸&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 다리의 총 길이, 다리가 견딜 수 있는 무게, 트럭 무게들 -&amp;gt; 경과된 시간
        # 다리 한 칸당 1초
        from collections import deque
        
        
        def solution(bridge_length, weight, truck_weights):
        trucks = len(truck_weights)
        stay = deque(truck_weights)
        bridge = deque()
        passed = deque()
        time = 0
        
        while len(passed) != trucks:
        while stay:
        
        if (sum(bridge) + stay[0]) &amp;gt; weight or len(bridge) &amp;gt;= bridge_length:
        break
        bridge.append(stay.popleft())
        time += 1
        
        time += bridge_length
        passed.extend(bridge)
        bridge.clear()
        if stay:
        bridge.append(stay.popleft())
        
        return time
        
        
        # print(&amp;quot;지난:&amp;quot;, passed, &amp;quot;다리:&amp;quot;, bridge, &amp;quot;대기:&amp;quot;, stay, &amp;quot;시간:&amp;quot;, time)
        
        print(solution(100, 100, [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]))
        &lt;/code&gt;&lt;/pre&gt;
        &lt;pre&gt;&lt;code&gt;테스트 1 〉    실패 (0.01ms, 9.23MB)
        테스트 2 〉    통과 (0.01ms, 9.3MB)
        테스트 3 〉    통과 (0.01ms, 9.29MB)
        테스트 4 〉    실패 (0.11ms, 9.24MB)
        테스트 5 〉    실패 (0.23ms, 9.2MB)
        테스트 6 〉    실패 (0.18ms, 9.3MB)
        테스트 7 〉    통과 (0.01ms, 9.3MB)
        테스트 8 〉    실패 (0.01ms, 9.37MB)
        테스트 9 〉    실패 (0.17ms, 9.26MB)
        테스트 10 〉    실패 (0.01ms, 9.29MB)
        테스트 11 〉    실패 (0.01ms, 9.25MB)
        테스트 12 〉    실패 (0.03ms, 9.28MB)
        테스트 13 〉    실패 (0.03ms, 9.27MB)
        테스트 14 〉    통과 (0.01ms, 9.29MB)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;모든 트럭이 한 번에 들어가는 케이스에서만 가능한거였음&lt;/p&gt;
        &lt;p&gt;그래서 정답코드를 봤다&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;bridge 큐에는 다리 길이만큼 무게가 0인 값을 넣어줌, trucks 큐에는 트럭들 리스트를 넣어줌&lt;/li&gt;
        &lt;li&gt;다리가 계속 움직인다고 생각하고(1초씩) current_weight 변수에 다리의 첫번째 인덱스를 항상 pop시켜준다&lt;/li&gt;
        &lt;li&gt;trucks큐가 존재하는 경우 다리의 무게 + 움직일 트럭의 무게랑 제한무게 비교해주고 조건문 성립할 경우 -&amp;gt; 다리로 트럭옮겨주고 current_weight에 무게 추가 +&lt;/li&gt;
        &lt;li&gt;조건문 성립 안할경우 다리에 [0] 무게 0 다리공간 추가 +&lt;/li&gt;
        &lt;li&gt;그리고 bridge가 살아있는 동안 계속 1초씩증가&lt;/li&gt;
        &lt;li&gt;bridge 비워지면 종료, time 반환&lt;/li&gt;
        &lt;/ul&gt;
        &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
        def solution(bridge_length, weight, truck_weights):
        bridge = deque([0] * bridge_length)
        trucks = deque(truck_weights)
        time = 0
        current_weight = 0
        
        while bridge:
        time += 1
        current_weight -= bridge.popleft()
        
        if trucks:
        if current_weight + trucks[0] &amp;lt;= weight:
        truck = trucks.popleft()
        bridge.append(truck)
        current_weight += truck
        else:
        bridge.append(0)
        
        return time&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;아니 이 생각을 왜 못했지&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>백준 16234번 인구 이동 JAVA</title>
      <link>https://velog.io/@cabbz3000/%EB%B0%B1%EC%A4%80-16234%EB%B2%88-%EC%9D%B8%EA%B5%AC-%EC%9D%B4%EB%8F%99-JAVA</link>
      <guid>https://velog.io/@cabbz3000/%EB%B0%B1%EC%A4%80-16234%EB%B2%88-%EC%9D%B8%EA%B5%AC-%EC%9D%B4%EB%8F%99-JAVA</guid>
      <pubDate>Sun, 15 Feb 2026 06:19:24 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16234&quot;&gt;링크텍스트&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/cabbz3000/post/eb5ada80-814e-4d89-b09f-0b1d300e4ea8/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;h4 id=&quot;설명&quot;&gt;설명&lt;/h4&gt;
        &lt;blockquote&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;&lt;strong&gt;풀이 흐름 설명&lt;/strong&gt;&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;시간복잡도: &lt;code&gt;O(N²)&lt;/code&gt;, 공간복잡도: &lt;code&gt;O(N²)&lt;/code&gt;&lt;/p&gt;
        &lt;h4 id=&quot;회독&quot;&gt;회독&lt;/h4&gt;
        &lt;blockquote&gt;
        &lt;ul&gt;
        &lt;li&gt;[ x ] 1회 &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/blockquote&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 2회 &lt;/li&gt;
        &lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 3회&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h4 id=&quot;코드&quot;&gt;코드&lt;/h4&gt;
        &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.io.*;
        import java.util.*;
        
        public class Main {
        static int n,l,r;
        static int [][] arr;
        static boolean [][] check;
        static int [] dx = {-1,1,0,0};
        static int [] dy = {0,0,-1,1};
        public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        n = Integer.parseInt(st.nextToken());
        l = Integer.parseInt(st.nextToken());
        r = Integer.parseInt(st.nextToken());
        
        arr = new int[n][n];
        
        for(int i=0;i&amp;lt;n;i++){
        st = new StringTokenizer(br.readLine());
        for(int j=0;j&amp;lt;n;j++){
        arr[i][j] = Integer.parseInt(st.nextToken());
        }
        }
        
        System.out.println(simulate());
        }
        
        static int simulate(){
        int days = 0;
        
        while(true){
        check = new boolean[n][n];
        boolean move = false;
        
        for(int i=0;i&amp;lt;n;i++){
        for(int j=0;j&amp;lt;n;j++){
        if(!check[i][j]){
        if(bfs(i,j)) move = true;
        }
        }
        }
        
        if(!move) break;
        days++;
        }
        
        return days;
        }
        
        static boolean bfs(int x, int y){
        Queue&amp;lt;int[]&amp;gt; q = new ArrayDeque&amp;lt;&amp;gt;();
        List&amp;lt;int []&amp;gt; union = new ArrayList&amp;lt;&amp;gt;();
        
        q.offer(new int[]{x,y});
        check[x][y] = true;
        union.add(new int[]{x,y});
        
        int sum = arr[x][y];
        
        while(!q.isEmpty()){
        int [] now = q.poll();
        
        int xx = now[0];
        int yy = now[1];
        
        for(int i=0;i&amp;lt;4;i++){
        int cx = xx + dx[i];
        int cy = yy + dy[i];
        
        if(cx&amp;lt;0 || cx&amp;gt;=n || cy&amp;lt;0 || cy&amp;gt;=n || check[cx][cy]) continue;
        
        int diff = Math.abs(arr[xx][yy]-arr[cx][cy]);
        
        if(diff&amp;gt;=l &amp;amp;&amp;amp; diff&amp;lt;=r){
        check[cx][cy] = true;
        q.offer(new int[]{cx,cy});
        union.add(new int[]{cx,cy});
        sum+=arr[cx][cy];
        }
        }
        }
        
        if(union.size()==1) return false;
        
        int avg = sum/union.size();
        for(int [] pos : union){
        arr[pos[0]][pos[1]] = avg;
        }
        
        return true;
        }
        }&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/cabbz3000/post/01214225-f5f5-40ab-9be6-a50cecc5d5ce/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>람다</title>
      <link>https://velog.io/@101maltese/%EB%9E%8C%EB%8B%A4</link>
      <guid>https://velog.io/@101maltese/%EB%9E%8C%EB%8B%A4</guid>
      <pubDate>Sun, 15 Feb 2026 06:18:09 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;얘는 왜 봐도봐도 적응이 안 될까.. 정리해서 확실하게 이해해보겠습니다&lt;/p&gt;
        &lt;h1 id=&quot;람다란&quot;&gt;람다란?&lt;/h1&gt;
        &lt;p&gt;&amp;quot;귀찮게 이름 만들고 형식 다 갖추지 말고, 그냥 핵심 기능(코드)만 전달하자!&amp;quot;는 철학에서 시작됨&lt;/p&gt;
        &lt;ol&gt;
        &lt;li&gt;람다는 &amp;#39;익명 함수&amp;#39;이다.
        보통 우리가 함수(메서드)를 만들려면 이름도 지어줘야 하고, 반환 타입도 써야 하고, 클래스 안에 넣어야 함. 람다는 이 모든 절차를 생략하고 화살표 하나로 끝낸다.
        ```
        //람다의 기본 공식
        (매개변수) -&amp;gt; { 실행할 코드}&lt;/li&gt;
        &lt;/ol&gt;
        &lt;ul&gt;
        &lt;li&gt;() : 요리 재료(입력값)&lt;/li&gt;
        &lt;li&gt;-&amp;gt; : &amp;quot;이 재료를 가지고 이렇게 요리해!&amp;quot;(화살표)&lt;/li&gt;
        &lt;li&gt;{} : 실제 요리법(실행문)
        ```&lt;/li&gt;
        &lt;/ul&gt;
        &lt;ol start=&quot;2&quot;&gt;
        &lt;li&gt;RowMapper 코드로 비교해보기&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;람다가 없던 옛날 방식(익명 클래스)&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;new RowMapper&amp;lt;Member&amp;gt; {
        @Override
        public Member mapRow(ResultSet rs, int rowNum) throws SQLException{
        Member member = new Member();
        member.setId(rs.getLong(&amp;quot;id&amp;quot;);
        return member;
        }
        };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;람다 방식(현대식), 핵심 로직은 같은데 껍데기 코드가 싹 사라짐&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;(rs, rowNum) -&amp;gt; {
        Member member = new Member();
        member.setId(rs.getLong(&amp;quot;id&amp;quot;));
        return member;
        }&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot;&gt;
        &lt;li&gt;&lt;p&gt;왜 람다를 쓰는가?&lt;/p&gt;
        &lt;ol&gt;
        &lt;li&gt;코드가 짧아진다: 위 예시처럼 불필요한 타이핑이 줄어듦.&lt;/li&gt;
        &lt;li&gt;함수를 &amp;#39;물건&amp;#39;처럼 전달할 수 있다: 원래 자바에서 함수는 단독으로 존재할 수 없지만, 람다를 쓰면 함수 자체를 메서드의 파라미터(인자)로 휙 던져줄 수 있음.&lt;/li&gt;
        &lt;li&gt;스트림과 찰떡궁합: 스트림은 &amp;quot;데이터를 어떻게 요리할지&amp;quot;에 대한 전략을 계속 전달받아야 하는데, 그때 람다가 그 전략서 역할을 함.&lt;/li&gt;
        &lt;/ol&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;람다를 읽는 법
        코드를 보다가 -&amp;gt;를 만나면 속으로 이렇게 읽어보세요.&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;&amp;quot;앞에 있는 재료를(rs, rowNum) 받아서, 화살표 뒤에 있는 로직을 실행해라!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;&lt;strong&gt;-추가 궁금증 해소&lt;/strong&gt;&lt;/p&gt;
        &lt;ol&gt;
        &lt;li&gt;데이터는 어디에 저장되어 있나요? (ResultSet)
        RowMapper가 실행되기 직전, DB에서 갓 꺼내온 데이터는 ResultSet이라는 객체에 담겨 있습니다. 이 녀석은 엑셀 표 같은 구조예요.&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;구조: 행(Row)과 열(Column)로 이루어진 표 형태.&lt;/p&gt;
        &lt;p&gt;특징: 자바 객체가 아니라서 member.getName()처럼 바로 꺼내 쓸 수 없고, rs.getString(&amp;quot;name&amp;quot;)처럼 컬럼 이름을 일일이 불러서 꺼내야 합니다.
        2. RowMapper의 실제 형태: &amp;quot;변환 가이드북&amp;quot;
        질문하신 코드에서 RowMapper는 인터페이스라는 형태로 존재합니다. 내부를 들여다보면 딱 하나의 메서드만 정의되어 있어요.&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;@FunctionalInterface
        public interface RowMapper&amp;lt;T&amp;gt; {
        // &amp;quot;ResultSet(표)을 받아서 T(객체)로 바꿔라&amp;quot;라는 규칙만 있음!
        T mapRow(ResultSet rs, int rowNum) throws SQLException;
        }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;즉, RowMapper는 데이터를 담고 있는 변수가 아니라, &amp;quot;표(ResultSet)의 한 줄을 받아서 객체(Member)로 조립해 반환하는 함수&amp;quot; 그 자체입니다.&lt;/p&gt;
        &lt;ol start=&quot;3&quot;&gt;
        &lt;li&gt;데이터의 흐름 (저장에서 변환까지)
        데이터가 어떤 단계를 거쳐 우리 손에 들어오는지 순서를 보세요.&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;DB: 데이터가 하드디스크에 저장되어 있음.&lt;/p&gt;
        &lt;p&gt;ResultSet (표): JdbcTemplate이 DB에서 데이터를 긁어와서 표 형태로 잠시 들고 있음.&lt;/p&gt;
        &lt;p&gt;RowMapper (조립기): JdbcTemplate이 표의 한 줄을 읽을 때마다 RowMapper를 호출함.&lt;/p&gt;
        &lt;p&gt;Member (객체): RowMapper가 표의 데이터를 바탕으로 Java 객체를 새로 찍어냄.&lt;/p&gt;
        &lt;p&gt;List (최종 저장소): JdbcTemplate이 찍어낸 객체들을 모아서 최종적으로 List&lt;Member&gt;에 저장함.&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;-JdbcTemplate 수강 중에 의문이 생겼던 부분&lt;/strong&gt;
        이 코드에서 매개변수인 rs, rowNum은 어디서 받아온 거야??&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;private RowMapper&amp;lt;Member&amp;gt; memberRowMapper() {
        // rs는 ResultSet(표), rowNum은 행 번호를 뜻합니다.
        return (rs, rowNum) -&amp;gt; {
        Member member = new Member(); // 1. 새 멤버 객체를 만든다.
        member.setId(rs.getLong(&amp;quot;id&amp;quot;)); // 2. 표의 &amp;quot;id&amp;quot; 칸 값을 꺼내 객체에 넣는다.
        member.setName(rs.getString(&amp;quot;name&amp;quot;)); // 3. 표의 &amp;quot;name&amp;quot; 칸 값을 꺼내 객체에 넣는다.
        return member; // 4. 완성된 객체 반환!
        };
        } &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JdbcTemplate 프레임워크가 내부적으로 넣어준 것&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;rs와 rowNum은 JdbcTemplate이 DB를 조회하는 과정에서 직접 생성해서 넘겨줍니다.
        우리는 그 값을 받아서 어떻게 쓸지만 람다식 안에 적어두는 것입니다.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;그렇군.. 좋은 프레임워크네요&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Lodislot Online Platform: Adaptive Mechanics and Strategic Participation</title>
      <link>https://velog.io/@contenthubsuite/Lodislot-Online-Platform-Adaptive-Mechanics-and-Strategic-Participation</link>
      <guid>https://velog.io/@contenthubsuite/Lodislot-Online-Platform-Adaptive-Mechanics-and-Strategic-Participation</guid>
      <pubDate>Sun, 15 Feb 2026 06:18:07 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;a href=&quot;https://lodislot-ph.net&quot;&gt;Lodislot&lt;/a&gt; is an online gaming platform recognized for its combination of intuitive design, stable performance, and interactive depth. Its interface is arranged for clarity, making it easy for players to browse categories, access featured titles, and explore new releases efficiently. Fast loading times and responsive controls across desktop and mobile devices ensure that gameplay remains smooth and uninterrupted, enabling users to focus entirely on mechanics, timing, and strategic engagement.&lt;/p&gt;
        &lt;p&gt;The platform’s game library emphasizes layered, interactive features. Titles frequently include cascading sequences, multiplier boosts, expanding symbols, and structured bonus rounds that reward careful observation. Community recommendations stress the importance of understanding each game’s activation rules and feature mechanics before committing to longer sessions. By observing how features unfold and familiarizing themselves with interactive elements, players can develop a deliberate approach that maximizes engagement and enhances the overall gaming experience.&lt;/p&gt;
        &lt;p&gt;Strategic observation is central to Lodislot’s philosophy. Some games gradually build momentum before entering feature-rich rounds, while others offer consistent interactive moments throughout the session. Players often suggest monitoring early gameplay to identify patterns, pacing, and volatility. Focusing on a single game for a sustained session allows players to gain deeper insight into mechanics, anticipate feature activation, and make informed decisions. This concentrated approach supports steady skill development and encourages attentive participation.&lt;/p&gt;
        &lt;p&gt;Session management is a key consideration for Lodislot users. Many players define objectives at the start of each session, such as exploring a new category, testing a specific title, or participating in leaderboard-style events. Establishing clear time boundaries ensures that play remains structured, while post-session reflection helps users evaluate outcomes and refine strategies for future sessions. This disciplined approach encourages consistent engagement and supports a thoughtful gaming experience.&lt;/p&gt;
        &lt;p&gt;Lodislot also promotes engagement through themed events, seasonal campaigns, and competitive challenges. These initiatives provide measurable objectives and motivate players to participate purposefully while broadening their familiarity with different game mechanics. The combination of interactive features and structured events helps maintain interest over time and encourages players to approach sessions with strategy and focus.&lt;/p&gt;
        &lt;p&gt;The platform’s community adds another layer of value. Players often share insights on feature mechanics, pacing techniques, and session strategies. Discussions may cover topics such as predicting bonus sequences, optimizing multipliers, and timing feature activations effectively. This collaborative exchange enhances individual player knowledge and encourages informed, strategic participation.&lt;/p&gt;
        &lt;p&gt;In summary, Lodislot offers a well-rounded online gaming platform where stability, layered mechanics, and strategic planning converge. By emphasizing observation, preparation, and deliberate engagement, the platform allows players to maximize the value of their sessions. Whether mastering individual titles, participating in seasonal events, or refining pacing strategies, Lodislot delivers an immersive, rewarding digital experience that balances entertainment with thoughtful gameplay.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>비선형 자료구조 - HEAP ( 우선순위  )</title>
      <link>https://velog.io/@wjdtn747/%EB%B9%84%EC%84%A0%ED%98%95-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-HEAP-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84</link>
      <guid>https://velog.io/@wjdtn747/%EB%B9%84%EC%84%A0%ED%98%95-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-HEAP-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84</guid>
      <pubDate>Sun, 15 Feb 2026 06:17:40 GMT</pubDate>
      <content:encoded>
        &lt;blockquote&gt;
        &lt;p&gt;&lt;strong&gt;&lt;code&gt;Heap&lt;/code&gt; 자료구조&lt;/strong&gt;&lt;br&gt;                &lt;img src=&quot;https://velog.velcdn.com/images/wjdtn747/post/bb929579-3098-4fa6-adf8-32e9300fab37/image.jpg&quot; alt=&quot;&quot;&gt;
        。부모노드의 &lt;code&gt;key value&lt;/code&gt;가 자식노드 값보다 항상 크거나 동일한 조건( &lt;code&gt;부모노드값&lt;/code&gt; $\ge$ &lt;code&gt;자식노드값&lt;/code&gt; )을 만족하는 &lt;code&gt;완전이진트리&lt;/code&gt;
        ▶ 트리를 구성하는 노드 中 루트가 가장 큰 &lt;code&gt;key value&lt;/code&gt;를 가진다.
        &lt;span&gt;
        。&lt;code&gt;완전이진트리&lt;/code&gt;를 기준으로 구현되어있으므로 &lt;code&gt;HEAP&lt;/code&gt;을 &lt;code&gt;1차원배열&lt;/code&gt;로 구현 및 &lt;code&gt;인덱스연산&lt;/code&gt;이 가능하다.
        &lt;span&gt;
        。부모간 대소관계가 구현되어있지만, 형제( &lt;code&gt;Sibling&lt;/code&gt; )간 대소관계가 정의되있지 않으므로 &lt;strong&gt;부분순서트리( &lt;code&gt;Partial Ordered Tree&lt;/code&gt; )&lt;/strong&gt;라고 한다.
        &lt;span&gt;
        。부모와 자식노드 간 관계가 일정할 경우, &lt;code&gt;key value&lt;/code&gt;의 대소관계가 역전( &lt;code&gt;부모노드값&lt;/code&gt; $\le$ &lt;code&gt;자식노드값&lt;/code&gt; )되어도 &lt;code&gt;Heap&lt;/code&gt; 자료구조가 될 수 있음
        ▶ 해당 경우 트리를 구성하는 노드 中 루트가 가장 작은 &lt;code&gt;key value&lt;/code&gt;를 가짐&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;blockquote&gt;
        &lt;p&gt;&lt;strong&gt;&lt;code&gt;우선순위 큐&lt;/code&gt; ( Priority Queue )&lt;/strong&gt;
        。&lt;code&gt;데이터&lt;/code&gt; 입력순서와 상관없이 &lt;strong&gt;우선순위가 높은 데이터가 우선적으로 출력&lt;/strong&gt;되는 &lt;code&gt;Heap&lt;/code&gt; 자료구조
        ▶ &lt;code&gt;데이터&lt;/code&gt; 입력 시 내부 &lt;code&gt;자료구조&lt;/code&gt;에서 &lt;code&gt;우선순위 조건&lt;/code&gt; 기준으로 배열되여 항상 &lt;code&gt;우선순위&lt;/code&gt;의 최솟값 또는 최댓값을 우선 출력
        &lt;span&gt;
        。&lt;code&gt;자료구조&lt;/code&gt; 자체는 다르지만 &lt;code&gt;Queue&lt;/code&gt;와 유사하게 동작하므로 &lt;code&gt;우선순위큐&lt;/code&gt;라고 한다.
        ▶ 내부구조가 &lt;code&gt;Heap&lt;/code&gt;으로 구성되어있으므로 &lt;code&gt;시간복잡도&lt;/code&gt; : $O(Nlog(N))$
        &lt;span&gt;
        。&lt;code&gt;우선순위큐&lt;/code&gt;에 &lt;code&gt;데이터&lt;/code&gt; 삽입 시 해당 &lt;code&gt;데이터&lt;/code&gt;는 &lt;code&gt;우선순위 값&lt;/code&gt; 기준 &lt;code&gt;Heap&lt;/code&gt; 자료구조가 성립하는 &lt;code&gt;인덱스&lt;/code&gt;로 배열
        ▶ &lt;code&gt;front&lt;/code&gt;에 항상 우선순위 기준의 &lt;code&gt;최댓값&lt;/code&gt; 또는 &lt;code&gt;최솟값&lt;/code&gt;이 위치
        &lt;img src=&quot;https://velog.velcdn.com/images/wjdtn747/post/7c2aff09-2e96-456b-9cb3-618fd2b6b525/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((o1,o2) -&amp;gt; {
        int i1 = Math.abs(o1);
        int i2 = Math.abs(o2);
        if ( i1 == i2 ) {
        return o1 &amp;gt; o2 ? 1 : -1; // 절댓값이 동일할 경우 음수 우선정렬
        } else {
        return i1 - i2; 최솟값을 우선순위로 도출
        }
        });&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;▶ &lt;code&gt;데이터&lt;/code&gt;의 입력 순서와는 관련없이 최솟값이 우선순위로 출력&lt;/p&gt;
        &lt;/blockquote&gt;
      </content:encoded>
    </item>
    <item>
      <title>좋은 개발자가 되기 위해_버려야 하는 습관들</title>
      <link>https://velog.io/@obebe_00/%EC%A2%8B%EC%9D%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%B4%EB%B2%84%EB%A0%A4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%8A%B5%EA%B4%80%EB%93%A4</link>
      <guid>https://velog.io/@obebe_00/%EC%A2%8B%EC%9D%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%B4%EB%B2%84%EB%A0%A4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%8A%B5%EA%B4%80%EB%93%A4</guid>
      <pubDate>Sun, 15 Feb 2026 06:16:46 GMT</pubDate>
      <content:encoded>
        &lt;blockquote&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;&lt;a href=&quot;https://pixicstudio.medium.com/15-bad-programming-habits-you-need-to-stop-now-so-you-actually-become-a-better-developer-c7d8dfceae89&quot;&gt;https://pixicstudio.medium.com/15-bad-programming-habits-you-need-to-stop-now-so-you-actually-become-a-better-developer-c7d8dfceae89&lt;/a&gt;
        좋은 개발자가 되기 위해 버려야 하는 15가지 나쁜 습관들&lt;/p&gt;
        &lt;p&gt;&amp;#39;&lt;strong&gt;좋은&lt;/strong&gt; 개발자&amp;#39;라는 추상적인 목표를 위해 여러 글들을 읽어보고있습니다.
        그러던 중 좋은 글을 읽게 되어 관련 내용을 정리해서 기록해보고자 해요.&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;15가지의 나쁜 습관들을 알려주었는데, 한 차례 소개해보자면&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;Not using version control, or using it like trash
        👉 버전 관리를 사용하지 않거나, 엉망으로 사용하는 것
        Horrible naming — single-letter nonsense
        👉 끔찍한 네이밍 — 의미 없는 한 글자 변수 남발
        No automated tests or fragile tests
        👉 자동화 테스트가 없거나, 쉽게 깨지는 불안정한 테스트
        Skipping code reviews or ignoring feedback
        👉 코드 리뷰를 건너뛰거나 피드백을 무시하는 것
        Frequent copy-paste duplication
        👉 잦은 복사-붙여넣기로 인한 중복 코드
        Premature optimization mania
        👉 시기상조의 최적화 집착
        Letting technical debt rot your codebase
        👉 기술 부채를 방치해 코드베이스를 썩게 만드는 것
        Zero documentation, README is empty
        👉 문서가 전혀 없고, README조차 비어 있는 상태
        Garbage commit messages that have no meanings
        👉 의미 없는 쓰레기 커밋 메시지
        Manual builds and deployments living in the past
        👉 여전히 수동 빌드와 배포에 의존하는 구식 방식
        Overengineering — doing too much before it’s needed
        👉 과설계 — 필요하기도 전에 과하게 구현하는 것
        Swallowing errors and terrible logging
        👉 에러를 숨기거나, 형편없는 로깅 처리
        Refusing to learn and staying stagnant
        👉 배우기를 거부하고 정체되는 태도
        Working nonstop until you burn out
        👉 번아웃이 올 때까지 멈추지 않고 일하는 것
        Ignoring security — hardcoded secrets and no validation
        👉 보안을 무시하는 것 — 하드코딩된 비밀키, 입력값 검증 없음&lt;/p&gt;
        &lt;p&gt;원문은 영어였는데 번역이 잘 되었겠죠?&lt;/p&gt;
        &lt;hr&gt;
        &lt;h2 id=&quot;📒-정리&quot;&gt;📒 정리&lt;/h2&gt;
        &lt;p&gt;위에서 말한 15가지의 &lt;strong&gt;Bad Habits&lt;/strong&gt;를 몇 가지로 분류해서 정리해볼게요.&lt;/p&gt;
        &lt;h3 id=&quot;📂-a-코드-품질-관련-습관&quot;&gt;📂 A. 코드 품질 관련 습관&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;p&gt;의미 없는 변수명&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;주석에 의존하는 코드&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;중복 코드 방치&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;거대한 함수&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;테스트하지 않는 코드&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;h3 id=&quot;📂-b-태도와-협업-관련-습관&quot;&gt;📂 B. 태도와 협업 관련 습관&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;p&gt;코드 리뷰를 두려워하거나 무시하는 태도&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;문서화를 귀찮아하는 습관&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;배움 없이 복붙만 하는 습관&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;h3 id=&quot;📂-c-성장-방해-습관&quot;&gt;📂 C. 성장 방해 습관&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;p&gt;리팩토링 미루기&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;“작동하면 됐다” 마인드&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;새로운 시도 회피&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;hr&gt;
        &lt;h2 id=&quot;✔️공감-point&quot;&gt;✔️공감 Point&lt;/h2&gt;
        &lt;p&gt;A에서 공감되었던 부분은 &amp;#39;의미 없는 변수명&amp;#39;, &amp;#39;중복 코드 방치&amp;#39;입니다.
        최근 네이밍에 대해 공부했지만 그 전에는 그저 느낌이 가는대로~~ 변수명을 썼었어요.
        이제는 그러면 안되겠죠? 공부도 했으니 적용해보아야죠!.!&lt;/p&gt;
        &lt;p&gt;중복 코드 방치 &amp;rarr; 최근 css 작성할 때 많이 느끼는 포인트입니다.
        일단 하나씩 그리다보니 나중가면 겹치는 부분이 많더라구요?
        예를 들어, 각 element들에 전부 같은 속성을 넣는다던지... ^_^
        시간이 좀 걸리더라도 이걸 깔끔하게 하는 연습을 하면 좋을 것 같아요.&lt;/p&gt;
        &lt;p&gt;B에서 공감되었던 부분은 &amp;#39;문서화를 귀찮아하는 습관&amp;#39;입니다.
        게으름의 대명사였던 제가 블로그를 쓰려고 노력하는 이유도 위와 같은 이유인데요..ㅎㅎ
        프로젝트들만 해왔지 &lt;strong&gt;정리를 하나도 안해놨습니다!!!!!!!&lt;/strong&gt;
        정리를 해야 내가 무엇을 했었고, 무엇을 배웠고, 향후 포트폴리오에도 깔끔하게 적을 수 있는데요.
        이제 &amp;#39;귀찮음이 이겼어&amp;#39;라는 변명은 통하지 않으니 &lt;strong&gt;꼭! 꼭!&lt;/strong&gt; 정리해서 기록하도록 해보아요😎&lt;/p&gt;
        &lt;p&gt;C에서 공감되었던 부분은 &amp;#39;리펙토링 미루기&amp;#39;, &amp;#39;작동하면 됐다&amp;#39; 입니다. &amp;#39;새로운 시도 회피&amp;#39;도 넣을 뻔 했지만 박치기 공룡 포지션으로 박치기는 많이 해봤으니 빼둘게요. (너무 나쁜 습관만 가지고있는 것 같잖아요?)
        리펙토링을 미룬다... 귀찮음이 크죠 이왕 이렇게 된거 이전 프로젝트 리펙토링도 해보아야겠어요. 리펙토링도 방법이 있을까요? 좋은 리펙토링에 대한 글도 읽어보고 정리해볼게요!
        작동하면 됐다 &amp;rarr; 이거 짤로도 많이 봤는데요. &lt;strong&gt;우선 작동했으니 건드리지마&lt;/strong&gt;
        네, 대학생까지만해도 매우매우 공감하고 실천해왔습니다. 일단 됐잖아?
        근데 회사가서도 그러면 안되겠죠? 그 전에, 협업에서도 그러면 안되니 고쳐보아요
        작동하면 됐다를 안하려면 어떻게 해야할까요~~?
        작동 방식을 이해하고 내가 제대로 했는지를 판단할 수 있어야할거에요.
        이 부분은 AI를 어떻게 쓸 것이며, 개발자가 앞으로 AI와 함께 나아가야하는 방향인데요.
        쓰다보니 궁금해져서 가볍게 관련 링크를 첨부할게요&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;&lt;a href=&quot;https://velog.io/@teo/ai-agent-prolog&quot;&gt;https://velog.io/@teo/ai-agent-prolog&lt;/a&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;정리해서 올리기에는 제가 무지한 부분이 많습니다. 그래서 링크만 첨부했어요.
        그래도 느낌은 오시죠?
        내 분야에 대해 알고있어야 AI가 제대로 하는지, 어떻게 order를 내려야하는지 그런느낌인듯합니다.&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;이 글을 읽으시는 분들도 공감되는 부분이 있다면 극복해내서 한층 더 성장한 개발자가 되면 좋겠습니다.&lt;/p&gt;
        &lt;p&gt;여러분 모두 화이팅입니다!
        새해 복 많이 받으세요&lt;del&gt;~&lt;/del&gt;🙆‍♂️🙇‍♂️&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Ubuntu Docker 설치하기</title>
      <link>https://velog.io/@kimtaeyeong1229/Ubuntu-Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0</link>
      <guid>https://velog.io/@kimtaeyeong1229/Ubuntu-Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0</guid>
      <pubDate>Sun, 15 Feb 2026 06:16:35 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/kimtaeyeong1229/post/cbfc3612-1e01-47cd-9af5-041b0f39bed0/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;이 아티클에는 Ubuntu에 Docker를 설치하는 방법이 정리되어 있으며, 환경 구성은 다음과 같습니다:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;Ubuntu 22.04&lt;/li&gt;
        &lt;li&gt;rtx3060&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h1 id=&quot;목차&quot;&gt;목차&lt;/h1&gt;
        &lt;hr&gt;
        &lt;ol&gt;
        &lt;li&gt;Docker 설치&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;sudo&lt;/code&gt; 권한 없이 Docker 사용하기 (선택적)&lt;/li&gt;
        &lt;li&gt;Nvidia Docker 설치 (선택적)&lt;/li&gt;
        &lt;li&gt;참조&lt;/li&gt;
        &lt;/ol&gt;
        &lt;h1 id=&quot;1-docker-설치&quot;&gt;1. Docker 설치&lt;/h1&gt;
        &lt;hr&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/install/ubuntu/&quot;&gt;Install using the apt repository&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;위는 Ubuntu에 Docker를 설치하는 공식 사이트입니다, 접속 후 우측에 있는 사이드 피크에서 &lt;strong&gt;“Install using the apt repository”&lt;/strong&gt;를 선택하고 설치를 진행합니다:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/kimtaeyeong1229/post/f14861fd-0471-4d94-ac30-3438095a7e1c/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;h1 id=&quot;2-sudo-권한-없이-docker-사용하기-선택적&quot;&gt;2. &lt;code&gt;sudo&lt;/code&gt; 권한 없이 Docker 사용하기 (선택적)&lt;/h1&gt;
        &lt;hr&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/install/linux-postinstall/&quot;&gt;Post-installation steps&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;위는 sudo 권한 없이 Docker를 사용하기 위해 제공되는 공식 사이트입니다, 접속 후 우측에 있는 사이드 피크에서 &lt;strong&gt;“Manage Docker as a non-root user”&lt;/strong&gt;를 선택하시고 설치를 진행합니다:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/kimtaeyeong1229/post/01e57e11-0ef0-4d98-8039-c06e65a6ce29/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;h1 id=&quot;3-nvidia-docker-설치-선택적&quot;&gt;3. Nvidia Docker 설치 (선택적)&lt;/h1&gt;
        &lt;hr&gt;
        &lt;ol&gt;
        &lt;li&gt;&lt;p&gt;&lt;strong&gt;GPG키와 저장소 추가&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \
        &amp;amp;&amp;amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \
        &amp;amp;&amp;amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list&lt;/code&gt;&lt;/pre&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;&lt;strong&gt;nvidia-docker 설치&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y nvidia-docker2&lt;/code&gt;&lt;/pre&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;&lt;strong&gt;docker 재시작&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo systemctl restart docker&lt;/code&gt;&lt;/pre&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;&lt;strong&gt;docker 명령어로 gpu 사용가능하게 컨테이너 띄우기&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; docker run --rm --gpus all ubuntu:22.04 nvidia-smi&lt;/code&gt;&lt;/pre&gt;
        &lt;h1 id=&quot;4-참조&quot;&gt;4. 참조&lt;/h1&gt;
        &lt;/li&gt;
        &lt;/ol&gt;
        &lt;hr&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://data-science-hi.tistory.com/203&quot;&gt;https://data-science-hi.tistory.com/203&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      </content:encoded>
    </item>
    <item>
      <title>555pub Digital Gaming Experience: Structured Engagement and Feature Mastery</title>
      <link>https://velog.io/@contenthubsuite/555pub-Digital-Gaming-Experience-Structured-Engagement-and-Feature-Mastery</link>
      <guid>https://velog.io/@contenthubsuite/555pub-Digital-Gaming-Experience-Structured-Engagement-and-Feature-Mastery</guid>
      <pubDate>Sun, 15 Feb 2026 06:15:46 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/contenthubsuite/post/6022fcc3-83da-4a76-9128-b4351a988f0e/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://555pub.online&quot;&gt;555pub&lt;/a&gt; has earned a strong reputation among online gaming enthusiasts by offering a platform that balances technical stability, interactive depth, and structured participation. The interface is designed with clarity in mind, allowing users to navigate categories efficiently, access new titles, and revisit favorites without confusion. Unlike some platforms that prioritize flashy visuals over functionality, 555pub emphasizes smooth performance and responsive controls across desktop and mobile devices, ensuring uninterrupted sessions. This reliability provides a foundation for focused gameplay, encouraging players to engage thoughtfully and strategically.&lt;/p&gt;
        &lt;p&gt;The platform’s game library emphasizes titles with layered mechanics, including cascading sequences, multiplier systems, stacked symbols, and structured bonus rounds. These features introduce dynamic pacing and require attentive observation. Players often highlight the importance of reviewing in-game instructions and understanding activation rules before engaging in extended sessions. By analyzing how bonuses trigger, how multipliers progress, and how feature sequences unfold, users can develop a strategic approach that enhances both engagement and overall session satisfaction.&lt;/p&gt;
        &lt;p&gt;Observation and timing are central to 555pub’s gameplay philosophy. Some games gradually build toward enhanced rounds, while others provide frequent interactive moments. Recognizing these patterns helps players anticipate feature activation, manage pacing, and make informed decisions. Many experienced users recommend focusing on one game for an extended session, rather than rapidly switching between titles, to cultivate familiarity with mechanics and develop effective timing strategies. This deliberate approach reinforces awareness and supports sustained engagement.&lt;/p&gt;
        &lt;p&gt;Session planning is also a key component of the 555pub experience. Players frequently define objectives, such as testing a new release, exploring a particular game category, or participating in leaderboard-style challenges. Establishing time boundaries ensures balance, while post-session reflection allows users to review outcomes, analyze feature frequency, and adjust strategies for future sessions. This structured approach promotes disciplined participation and continuous improvement, enhancing the overall online gaming experience.&lt;/p&gt;
        &lt;p&gt;555pub further encourages engagement through seasonal events, themed campaigns, and community-driven competitions. These activities provide measurable goals that motivate players to participate intentionally while broadening their familiarity with diverse game mechanics. Success in such events often relies on careful observation, timing awareness, and strategic pacing, reinforcing the platform’s emphasis on deliberate and thoughtful play.&lt;/p&gt;
        &lt;p&gt;The community aspect of 555pub also contributes to the platform’s appeal. Players exchange insights on feature mechanics, session management, and pacing strategies. Discussions often focus on predicting cascading sequences, optimizing multipliers, and identifying efficient ways to engage with bonus rounds. This collaborative environment fosters learning and allows users to refine their gameplay approach, benefiting from collective knowledge while enhancing individual experiences.&lt;/p&gt;
        &lt;p&gt;Overall, 555pub provides an online gaming environment where technical reliability, layered mechanics, and structured engagement intersect. By emphasizing preparation, observation, and strategic participation, the platform encourages players to approach gameplay thoughtfully and deliberately. Whether exploring new releases, mastering favorite titles, or participating in seasonal challenges, 555pub delivers a comprehensive digital experience that promotes both enjoyment and skill development.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Superwin Digital Arena: Feature Depth and Adaptive Gameplay</title>
      <link>https://velog.io/@contenthubsuite/Superwin-Digital-Arena-Feature-Depth-and-Adaptive-Gameplay</link>
      <guid>https://velog.io/@contenthubsuite/Superwin-Digital-Arena-Feature-Depth-and-Adaptive-Gameplay</guid>
      <pubDate>Sun, 15 Feb 2026 06:14:21 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/contenthubsuite/post/88ae2bf2-edc9-466a-a277-8812ed458e0d/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://superwin-ph.net&quot;&gt;Superwin&lt;/a&gt; is an online gaming platform that appeals to players who value consistency, interactive mechanics, and strategic engagement. Its interface is designed for intuitive navigation, allowing users to browse categories, locate featured games, and explore new releases with ease. The platform’s responsive performance across desktop and mobile devices ensures that sessions remain uninterrupted, enabling players to focus on gameplay rather than technical issues. This stability is particularly beneficial for longer sessions where attention to timing, features, and pacing is critical.&lt;/p&gt;
        &lt;p&gt;The platform’s library emphasizes feature-rich games designed with layered mechanics that reward observation and thoughtful participation. Many titles include cascading combinations, multiplier sequences, expanding symbols, and structured bonus rounds. These systems create dynamic pacing, requiring players to remain attentive to maximize engagement. Community recommendations often stress the importance of reviewing in-game information panels before engaging fully. Understanding activation rules, feature triggers, and pacing variations allows players to refine their approach and develop effective strategies for longer sessions.&lt;/p&gt;
        &lt;p&gt;Strategic observation is a cornerstone of the Superwin experience. Some titles gradually build intensity before triggering enhanced rounds, while others maintain frequent interactive elements. Observing early gameplay is critical to identifying patterns, understanding volatility, and predicting feature behavior. Concentrating on one game during a session allows players to familiarize themselves with mechanics, improve timing awareness, and make deliberate decisions rather than relying on rapid switching between titles.&lt;/p&gt;
        &lt;p&gt;Session management plays an equally important role. Many players set clear objectives, such as exploring newly released content, mastering a favorite title, or participating in leaderboard events. Establishing time boundaries ensures sessions remain balanced, while post-session reflection helps players evaluate outcomes, analyze feature frequency, and adjust strategies for future gameplay. This reflective approach encourages disciplined participation and sustained improvement.&lt;/p&gt;
        &lt;p&gt;Superwin further engages its community through seasonal campaigns, themed events, and competitive challenges. These initiatives introduce measurable objectives, motivating players to approach sessions with intention. Rotating between different game types during these events enhances familiarity with varied mechanics while maintaining engagement. The combination of interactive features and structured campaigns fosters a sense of progression and accomplishment.&lt;/p&gt;
        &lt;p&gt;Community collaboration enhances the overall experience. Players frequently share insights on feature behavior, timing strategies, and session management. Discussions often include analyzing cascading sequences, predicting bonus activations, and refining pacing techniques. This collective knowledge allows players to approach sessions more strategically and contributes to a collaborative learning environment within the platform.&lt;/p&gt;
        &lt;p&gt;Overall, Superwin offers a comprehensive online gaming experience that combines stable performance, interactive mechanics, and strategic planning. By encouraging preparation, observation, and structured engagement, the platform provides a balanced environment for players seeking both entertainment and thoughtful gameplay. Whether exploring new releases, mastering familiar titles, or participating in seasonal challenges, Superwin delivers a rewarding digital experience that promotes skill development and sustained engagement.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>The Future of Social Media Management with SMM Vault Systems</title>
      <link>https://velog.io/@smmpanelone1/The-Future-of-Social-Media-Management-with-SMM-Vault-Systems</link>
      <guid>https://velog.io/@smmpanelone1/The-Future-of-Social-Media-Management-with-SMM-Vault-Systems</guid>
      <pubDate>Sun, 15 Feb 2026 06:13:47 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;The future of social media marketing lies in automation and organization. As competition increases, marketers must adopt smarter systems. An &lt;a href=&quot;https://smmpanelone.com/blog/smmvault&quot;&gt;&lt;strong&gt;SMM Vault&lt;/strong&gt;&lt;/a&gt; represents the next step in structured digital growth.
        Traditional marketing methods often involve multiple tools and platforms. This creates confusion and inefficiency. An SMM Vault consolidates everything into one powerful system.
        Automation is becoming essential. With a centralized vault system, orders can be processed quickly and campaigns managed efficiently. This saves time and reduces operational stress.
        At SMM Panel One, we are committed to providing a modern SMM Vault experience that supports businesses, influencers, and agencies. Our platform is built for reliability, speed, and structured growth.
        As algorithms become more complex, marketers need better tracking and analytics. An SMM Vault allows easy monitoring of performance metrics and helps adjust strategies in real time.
        In the coming years, businesses that use organized systems will outperform those relying on manual processes. The SMM Vault concept ensures scalability, security, and sustainable success.
        If you want to future-proof your social media strategy, adopting an SMM Vault approach through SMM Panel One is a smart move. Structured growth is the foundation of long-term digital dominance.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>JL111 Online Gaming Hub: Feature Mastery and Session Strategy</title>
      <link>https://velog.io/@contenthubsuite/JL111-Online-Gaming-Hub-Feature-Mastery-and-Session-Strategy</link>
      <guid>https://velog.io/@contenthubsuite/JL111-Online-Gaming-Hub-Feature-Mastery-and-Session-Strategy</guid>
      <pubDate>Sun, 15 Feb 2026 06:13:12 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/contenthubsuite/post/92ccf7f3-5dd7-47d7-9427-d666617275e8/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://jl111.tw&quot;&gt;JL111&lt;/a&gt; has established itself as a robust online gaming platform, attracting players who value a combination of technical stability, interactive features, and structured engagement. The platform’s interface is designed for clarity, allowing users to browse categories efficiently, access newly released titles, and revisit familiar games with ease. Unlike platforms that rely on cluttered layouts or complex menus, JL111 emphasizes simplicity without compromising functionality. The platform’s responsive performance across desktop and mobile devices ensures uninterrupted sessions, allowing players to focus entirely on gameplay and strategic planning rather than technical delays or connectivity issues.&lt;/p&gt;
        &lt;p&gt;A defining feature of JL111 is its extensive library of games built around layered interactive mechanics. Many titles incorporate cascading sequences, multiplier chains, expanding symbols, and structured bonus rounds that activate under specific conditions. These mechanics introduce varied pacing, making attention and timing critical to a successful experience. Community discussions emphasize the importance of studying game guides before engaging in longer sessions, as understanding feature behavior and activation rules allows players to optimize their approach. Observing how multipliers progress or how bonus rounds unfold helps users develop a rhythm-based strategy, improving overall engagement and session effectiveness.&lt;/p&gt;
        &lt;p&gt;Strategic observation is central to the JL111 experience. Some games gradually build momentum before entering feature-heavy sequences, while others provide consistent opportunities for interaction throughout the session. Experienced players recommend monitoring early gameplay to identify patterns, volatility, and pacing. Concentrating on a single title rather than switching rapidly between games enables deeper understanding of mechanics, better timing awareness, and more deliberate decisions. This approach encourages thoughtful engagement and promotes steady skill development within the platform’s ecosystem.&lt;/p&gt;
        &lt;p&gt;Session management is equally emphasized. Players often define objectives at the start of each session, whether exploring a newly released title, participating in an event challenge, or analyzing a specific game’s mechanics. Establishing clear time boundaries ensures balance and helps prevent unstructured play. Post-session reflection is also recommended, as reviewing outcomes, noting feature activation frequency, and assessing pacing provides actionable insights for future strategies. By integrating these practices, JL111 promotes disciplined, informed, and sustainable gameplay.&lt;/p&gt;
        &lt;p&gt;JL111’s platform further enhances engagement through seasonal events, leaderboard challenges, and limited-time campaigns. These structured activities encourage purposeful participation while providing measurable goals. Rotating between different game types during events broadens familiarity with varied mechanics and maintains interest across extended sessions. Success in these activities requires timing, observation, and feature awareness, reinforcing the importance of preparation and strategic focus.&lt;/p&gt;
        &lt;p&gt;Community interaction also plays a crucial role in the JL111 experience. Players frequently share insights on feature behavior, pacing strategies, and session management techniques. Discussions cover topics such as predicting cascading sequences, optimizing multipliers, and balancing extended sessions with structured play. This collaborative environment fosters a learning culture, allowing users to refine their approach while benefiting from collective knowledge.&lt;/p&gt;
        &lt;p&gt;Ultimately, JL111 represents a balanced online gaming platform where technical reliability, layered features, and thoughtful participation intersect. By emphasizing preparation, observation, and structured engagement, the platform encourages players to approach gameplay strategically. Whether exploring new titles, mastering existing favorites, or participating in seasonal challenges, JL111 offers an immersive, rewarding, and skill-enhancing digital experience that prioritizes both enjoyment and thoughtful interaction.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>JLpub Online Gaming Platform: Organized Features and Consistent Engagement</title>
      <link>https://velog.io/@contenthubsuite/JLpub-Online-Gaming-Platform-Organized-Features-and-Consistent-Engagement</link>
      <guid>https://velog.io/@contenthubsuite/JLpub-Online-Gaming-Platform-Organized-Features-and-Consistent-Engagement</guid>
      <pubDate>Sun, 15 Feb 2026 06:11:34 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/contenthubsuite/post/b4666a6d-2c5b-483c-8de6-322172f7d0a1/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://ph-jlpub.com&quot;&gt;JLpub&lt;/a&gt; has positioned itself as a reliable and thoughtfully designed online gaming platform, catering to players who value clarity, structure, and interactive depth. The platform’s interface prioritizes intuitive navigation, allowing users to move seamlessly between categories, locate featured games, and discover new releases efficiently. Unlike platforms that overwhelm players with excessive options, JLpub’s layout emphasizes clarity, offering an organized approach to browsing while maintaining visual appeal. This structure reduces friction, allowing players to focus fully on gameplay and strategy. Additionally, the platform’s performance is stable across both desktop and mobile devices, ensuring uninterrupted sessions regardless of the device used, which is especially important for players engaging in extended play.&lt;/p&gt;
        &lt;p&gt;One of JLpub’s strengths lies in its curated selection of feature-rich games. Titles are designed to include layered mechanics, such as cascading sequences, multiplier chains, expanding elements, and structured bonus rounds. These features create dynamic pacing that encourages players to stay attentive and engaged throughout the session. Unlike platforms that emphasize purely random outcomes, JLpub’s interactive systems reward careful observation and thoughtful timing. Community recommendations frequently stress the importance of reviewing game guides and information panels before committing to longer sessions. Understanding the rules for bonus activation, multipliers, and feature sequences allows players to develop strategic approaches, enhancing both engagement and session effectiveness.&lt;/p&gt;
        &lt;p&gt;A defining element of JLpub’s platform is its focus on rhythm and session awareness. Different games have unique pacing: some gradually build momentum before entering feature-rich rounds, while others maintain frequent interactive opportunities. Observing gameplay patterns during early rounds is considered a key strategy by experienced users, as it allows players to identify volatility, predict feature triggers, and refine timing. Focusing on a single game for an extended period often results in deeper understanding, better decision-making, and a more rewarding experience than rapidly switching between titles. This deliberate approach fosters sustained engagement and encourages players to develop expertise in the games they enjoy.&lt;/p&gt;
        &lt;p&gt;Session management is a central theme for JLpub players. Many define specific objectives, such as testing a new title, exploring a particular category, or participating in special event missions. Establishing clear time boundaries ensures that sessions remain structured and balanced. Post-session reflection is also encouraged; reviewing game outcomes, noting feature frequency, and assessing pacing allows players to refine future strategies. This reflective approach promotes a consistent, thoughtful engagement style, rather than haphazard or impulsive gameplay.&lt;/p&gt;
        &lt;p&gt;JLpub further enhances engagement through seasonal campaigns, leaderboard challenges, and thematic events. These activities introduce measurable objectives that encourage purposeful participation and broaden exposure to different mechanics and game styles. Success in such campaigns often requires a combination of timing, observation, and strategic focus, reinforcing the platform’s emphasis on awareness and structured play. Players report that these features increase both the challenge and enjoyment of the platform, promoting long-term engagement and skill development.&lt;/p&gt;
        &lt;p&gt;Another notable aspect of JLpub is its community-driven insights. Players frequently exchange observations on feature mechanics, session strategies, and pacing techniques. Discussions often focus on optimizing timing for bonus sequences, understanding cascading interactions, or choosing titles based on personal playstyle preferences. The shared knowledge strengthens the individual experience, allowing users to approach gameplay more strategically and with confidence.&lt;/p&gt;
        &lt;p&gt;In conclusion, JLpub offers a comprehensive online gaming platform that balances technical reliability, layered interactive features, and community collaboration. By emphasizing preparation, observation, and structured engagement, the platform encourages players to approach gameplay thoughtfully. Whether exploring new releases, mastering a favorite title, or participating in event-based challenges, JLpub provides a well-rounded, immersive, and rewarding online experience that supports both entertainment and strategic growth.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>잘못된 날짜 하나가 서버를 멈췄다</title>
      <link>https://velog.io/@se-zero/%EC%9E%98%EB%AA%BB%EB%90%9C-%EB%82%A0%EC%A7%9C-%ED%95%98%EB%82%98%EA%B0%80-%EC%84%9C%EB%B2%84%EB%A5%BC-%EB%A9%88%EC%B7%84%EB%8B%A4</link>
      <guid>https://velog.io/@se-zero/%EC%9E%98%EB%AA%BB%EB%90%9C-%EB%82%A0%EC%A7%9C-%ED%95%98%EB%82%98%EA%B0%80-%EC%84%9C%EB%B2%84%EB%A5%BC-%EB%A9%88%EC%B7%84%EB%8B%A4</guid>
      <pubDate>Sun, 15 Feb 2026 06:11:22 GMT</pubDate>
      <content:encoded>
        &lt;h2 id=&quot;운영을-시작하자마자-발생한-장애&quot;&gt;운영을 시작하자마자 발생한 장애&lt;/h2&gt;
        &lt;p&gt;동아리 모집 시즌이 다가오면서 드디어 배포할 시점이 되었다.
        기능 구현은 모두 완료했고, 팀원들과 내부 QA도 충분히 진행한 뒤 동아리실의 물리적 서버에 배포를 마쳤다.&lt;/p&gt;
        &lt;p&gt;배포 다음 날 아침, 팀원에게 연락을 받았다.&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;“공지사항 작성하다가 날짜를 과거로 입력했는데, 서버가 2분 정도 다운됐다가 다시 올라왔어요.”&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;정확한 에러 메시지는 없었다.
        단지 “2분 정도 서버가 다운되었다”는 이야기뿐이었다.&lt;/p&gt;
        &lt;p&gt;실제 모집을 앞둔 시점이었기 때문에, 같은 문제가 다시 발생하면 안 되는 상황이었다.
        나는 곧바로 서버 로그를 확인하며 원인을 추적하기 시작했다.&lt;/p&gt;
        &lt;p&gt;먼저 Docker 상태를 살펴봤다.
        혹시 컨테이너가 크래시 나서 재시작된 것은 아닐까 생각했기 때문이다.&lt;/p&gt;
        &lt;p&gt;하지만 확인 결과, &lt;strong&gt;RestartCount는 0이었다.&lt;/strong&gt;
        서버는 재시작되지 않았다.
        즉, 프로세스가 죽었다가 살아난 것이 아니었다.&lt;/p&gt;
        &lt;p&gt;그렇다면 왜 팀원은 “서버가 다운되었다”고 느꼈을까?
        문제의 원인을 파악하기 위해 로그를 더 깊이 들여다보기 시작했다.&lt;/p&gt;
        &lt;h2 id=&quot;예상치-못한-원인-잘못된-날짜-입력&quot;&gt;예상치 못한 원인: 잘못된 날짜 입력&lt;/h2&gt;
        &lt;p&gt;로그를 확인해보니 문제는 공지사항 작성 요청에서 발생하고 있었다.&lt;/p&gt;
        &lt;p&gt;팀원이 입력한 날짜 값은 &lt;code&gt;&amp;quot;2000.99.99&amp;quot;&lt;/code&gt;였다.
        형식이 잘못된 날짜 문자열이었다.&lt;/p&gt;
        &lt;p&gt;프론트엔드에서 별도의 검증 없이 이 값이 그대로 백엔드로 전달되었고,
        백엔드에서는 이를 new Date()로 변환하고 있었다.&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;new Date(&amp;quot;2000.99.99&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;이 코드는 유효한 Date 객체를 생성하지 못한다.
        결과는 &lt;code&gt;Invalid Date&lt;/code&gt;였다.&lt;/p&gt;
        &lt;p&gt;문제는 이 값이 그대로 데이터베이스에 저장되려 했다는 점이다.
        TypeORM 내부에서는 Date 객체를 ISO 문자열 형태로 변환한 뒤 &lt;code&gt;timestamp&lt;/code&gt; 컬럼에 전달한다.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;Invalid Date&lt;/code&gt;가 변환되는 과정에서 생성된 값은 다음과 같은 형태였다.&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;0NaN-NaN-NaNTNaN:NaN:NaN...&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;PostgreSQL은 이를 정상적인 timestamp로 해석할 수 없었고,
        결국 &lt;code&gt;QueryFailedError&lt;/code&gt;가 발생했다.&lt;/p&gt;
        &lt;p&gt;여기까지는 단순한 입력 검증 문제처럼 보였다.
        잘못된 날짜가 들어갔고, 데이터베이스에서 에러가 발생한 것이다.&lt;/p&gt;
        &lt;p&gt;하지만 로그를 더 살펴보면서 이상한 점을 발견했다.&lt;/p&gt;
        &lt;p&gt;이 에러는 단순히 “요청 하나가 실패한 것”으로 끝나지 않았다.
        해당 시점 이후 약 2분 동안, 서버는 어떤 요청에도 응답하지 못했다.&lt;/p&gt;
        &lt;p&gt;문제는 날짜 자체가 아니었다.
        이 에러가 발생한 이후, 서버가 어떻게 동작했는지가 핵심이었다.&lt;/p&gt;
        &lt;h2 id=&quot;서버는-왜-죽지-않고-멈췄을까&quot;&gt;서버는 왜 죽지 않고 멈췄을까?&lt;/h2&gt;
        &lt;p&gt;Docker를 확인했을 때 RestartCount는 0이었다.
        프로세스는 살아있었다. 그런데도 약 2분간 아무 요청에도 응답하지 못했다.&lt;/p&gt;
        &lt;p&gt;이 현상을 이해하려면 Node.js의 실행 구조를 먼저 봐야 한다.&lt;/p&gt;
        &lt;p&gt;Node.js는 단일 스레드 기반의 Event Loop 구조로 동작한다.
        하나의 요청 처리 과정에서 블로킹이 발생하면, 그 순간 다른 모든 요청도 함께 대기 상태에 빠지게 된다.&lt;/p&gt;
        &lt;p&gt;날짜 입력으로 인해 &lt;code&gt;QueryFailedError&lt;/code&gt;가 발생했고, NestJS의 &lt;code&gt;ExceptionsHandler&lt;/code&gt;는 이 에러를 그대로 로깅했다.
        문제는 이 에러 로그의 크기였다.&lt;/p&gt;
        &lt;p&gt;에러 객체에는 다음 정보가 포함되어 있었다.&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;실행된 SQL query&lt;/li&gt;
        &lt;li&gt;전달된 parameters&lt;/li&gt;
        &lt;li&gt;driverError 상세 정보&lt;/li&gt;
        &lt;li&gt;전체 스택 트레이스&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;일반적인 HTTP 로그가 수백 바이트 수준이었다면,
        &lt;strong&gt;이 에러 로그는 수 KB&lt;/strong&gt;에 달했다.&lt;/p&gt;
        &lt;p&gt;우리 서버는 Winston을 통해 로그를 Logstash로 TCP 전송하고 있었다.
        짧은 시간 안에 큰 크기의 로그가 여러 번 전송되면서, Logstash 측에서 처리 속도를 따라가지 못했고 TCP 버퍼에 백프레셔가 발생했다.&lt;/p&gt;
        &lt;p&gt;이때 &lt;code&gt;socket.write()&lt;/code&gt;는 &lt;code&gt;false&lt;/code&gt;를 반환하게 된다.
        즉, “더 이상 받을 수 없으니 잠시 멈춰라”는 신호다.&lt;/p&gt;
        &lt;p&gt;문제는 이 상황을 고려하지 않고 로그 전송을 동기적으로 기다리고 있었다는 점이다.&lt;/p&gt;
        &lt;p&gt;결과적으로,&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;DB 에러 발생
        → 대형 에러 로그 생성
        → Logstash TCP 버퍼 포화
        → write() 지연
        → Event Loop 대기
        → 모든 요청 처리 중단&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;서버는 크래시하지 않았다.
        하지만 Event Loop가 로그 전송 대기에 묶이면서, 모든 요청이 함께 멈춰버렸다.&lt;/p&gt;
        &lt;p&gt;사용자 입장에서는 “서버가 다운된 것”처럼 보였지만,
        실제로는 &lt;strong&gt;프로세스가 살아있는 Hang&lt;/strong&gt; 상태였다.&lt;/p&gt;
        &lt;h2 id=&quot;단순-패치가-아닌-구조적-개선&quot;&gt;단순 패치가 아닌 구조적 개선&lt;/h2&gt;
        &lt;p&gt;이번 문제를 해결하는 가장 쉬운 방법은 날짜 검증을 추가하는 것이었다.
        실제로 프론트엔드와 백엔드 모두에 날짜 유효성 검사를 추가했다.&lt;/p&gt;
        &lt;p&gt;하지만 여기서 멈추면 안 된다고 생각했다.&lt;/p&gt;
        &lt;p&gt;잘못된 입력은 언제든 다시 들어올 수 있다.
        그리고 또 다른 종류의 예외가 발생할 수도 있다.
        중요한 것은 “이번 에러”를 막는 것이 아니라,
        비슷한 유형의 장애가 서버 전체로 확산되지 않도록 구조를 바꾸는 것이었다.&lt;/p&gt;
        &lt;p&gt;나는 다음과 같은 방향으로 개선을 진행했다.&lt;/p&gt;
        &lt;h3 id=&quot;1-입력-검증-강화&quot;&gt;1. 입력 검증 강화&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;프론트엔드 레벨에서 날짜 형식 검증 로직 추가&lt;/li&gt;
        &lt;li&gt;NestJS ValidationPipe를 활용한 DTO 계층 검증 적용&lt;/li&gt;
        &lt;li&gt;Service 레벨에서도 Invalid Date 여부를 명시적으로 체크&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h3 id=&quot;2-로그-전송을-논블로킹-구조로-변경&quot;&gt;2. 로그 전송을 논블로킹 구조로 변경&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;write()&lt;/code&gt;의 반환값을 확인하여 백프레셔(Backpressure) 관리&lt;/li&gt;
        &lt;li&gt;버퍼가 가득 찬 경우 대기(Blocking)하지 않고 해당 로그를 스킵&lt;/li&gt;
        &lt;li&gt;전송 실패가 서버 전체 가용성에 영향을 주지 않도록 오류 격리&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h3 id=&quot;3-외부-의존성-격리&quot;&gt;3. 외부 의존성 격리&lt;/h3&gt;
        &lt;ul&gt;
        &lt;li&gt;Logstash/Elasticsearch의 지연이나 장애가 API 응답에 영향을 주지 않도록 결합도 완화&lt;/li&gt;
        &lt;li&gt;로그 전송을 비동기(Async)로 처리하여 메인 비즈니스 로직의 병목 현상 방지&lt;/li&gt;
        &lt;li&gt;로그 전송 오류가 발생해도 이를 무시하고, 메인 비즈니스 로직은 중단 없이 실행되도록 처리&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h2 id=&quot;이번-장애를-통해-배운-것&quot;&gt;이번 장애를 통해 배운 것&lt;/h2&gt;
        &lt;p&gt;이번 경험을 통해 몇 가지를 분명히 깨달았다.&lt;/p&gt;
        &lt;p&gt;첫째, 작은 입력 하나가 시스템 전체에 영향을 줄 수 있다는 점이다.
        &lt;code&gt;&amp;quot;2000.99.99&amp;quot;&lt;/code&gt;라는 단순한 문자열이 데이터베이스 에러를 만들었고,
        그 에러는 로그 시스템을 거쳐 서버 전체를 멈추게 했다.
        입력 검증은 단순한 UX 문제가 아니라, 시스템 안정성과 직결된 문제였다.&lt;/p&gt;
        &lt;p&gt;둘째, Node.js 환경에서의 블로킹은 생각보다 치명적이라는 점이다.
        프로세스가 죽지 않아도, Event Loop가 묶이면 서버는 사실상 다운된 것과 다름없다.
        Crash보다 Hang이 더 위험할 수 있다는 것을 몸소 경험했다.&lt;/p&gt;
        &lt;p&gt;셋째, 관찰(Observability)을 위한 시스템은 가용성(Availability)을 침해해서는 안 된다는 점이다.
        로그는 중요하지만, 로그 전송 실패 때문에 서비스가 멈춰서는 안 된다.
        외부 의존성은 반드시 격리되어야 한다는 원칙을 다시 한 번 확인했다.&lt;/p&gt;
        &lt;p&gt;무엇보다도 이번 경험은
        “기능이 동작한다”와 “운영 환경에서 안정적으로 동작한다”는 전혀 다른 문제라는 사실을 깨닫게 해주었다.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Situs Toto Resmi dengan Bonus Harian Menarik</title>
      <link>https://velog.io/@taxipeb599/Situs-Toto-Resmi-dengan-Bonus-Harian-Menarik</link>
      <guid>https://velog.io/@taxipeb599/Situs-Toto-Resmi-dengan-Bonus-Harian-Menarik</guid>
      <pubDate>Sun, 15 Feb 2026 06:11:13 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;Situs Toto dikenal sebagai saluran togel online dan toto slot terpercaya yang menawarkan akses melalui link resmi dengan pilihan pasaran yang lengkap. Di era digital saat ini, kebutuhan akan platform permainan yang aman dan transparan semakin meningkat. Oleh karena itu, banyak pemain memilih situs yang memiliki reputasi baik, sistem keamanan modern, serta layanan profesional agar pengalaman bermain menjadi lebih nyaman dan bebas dari risiko.&lt;/p&gt;
        &lt;p&gt;Kepercayaan menjadi faktor utama dalam memilih platform togel online. Situs Toto hadir dengan sistem enkripsi terbaru yang menjaga keamanan data serta transaksi pengguna. Dengan teknologi ini, setiap aktivitas bermain berlangsung secara aman dan privasi pemain tetap terlindungi. Hal tersebut membuat pemain merasa lebih tenang saat melakukan deposit, memasang taruhan, hingga melakukan penarikan dana.&lt;/p&gt;
        &lt;p&gt;Salah satu keunggulan utama &lt;a href=&quot;https://villageofbrokaw.com/&quot;&gt;situs toto&lt;/a&gt; adalah ketersediaan pasaran yang lengkap. Pemain dapat memilih berbagai jenis pasaran populer sehingga memiliki lebih banyak opsi strategi dan peluang. Variasi permainan ini tidak hanya memberikan pengalaman yang lebih seru, tetapi juga memungkinkan pemain menyesuaikan gaya bermain sesuai preferensi masing-masing.&lt;/p&gt;
        &lt;p&gt;Selain pilihan permainan yang beragam, kemudahan akses juga menjadi nilai tambah. Link resmi yang selalu diperbarui memastikan pemain dapat masuk ke platform tanpa hambatan. Hal ini sangat penting untuk menjaga kenyamanan pengguna, terutama bagi mereka yang ingin bermain dengan cepat tanpa harus mencari akses alternatif yang berisiko.&lt;/p&gt;
        &lt;p&gt;Situs Toto juga dikenal dengan proses transaksi yang cepat dan efisien. Berbagai metode pembayaran tersedia untuk memudahkan pemain, mulai dari transfer bank hingga layanan pembayaran digital. Sistem yang stabil memungkinkan deposit dan penarikan dilakukan dalam waktu singkat, sehingga pemain dapat fokus menikmati permainan tanpa kendala teknis.&lt;/p&gt;
        &lt;p&gt;Layanan pelanggan profesional menjadi salah satu indikator kualitas sebuah platform. Situs Toto menyediakan dukungan yang responsif untuk membantu pengguna kapan saja. Tim support yang siap memberikan solusi membuat pemain merasa lebih dihargai dan meningkatkan rasa percaya terhadap platform.&lt;/p&gt;
        &lt;p&gt;Bonus dan promosi juga menjadi daya tarik tersendiri. Situs terpercaya biasanya menawarkan berbagai promo menarik seperti bonus pendaftaran, cashback, dan program loyalitas. Penawaran ini memberikan nilai tambah bagi pemain, sekaligus meningkatkan peluang untuk mendapatkan pengalaman bermain yang lebih menguntungkan.&lt;/p&gt;
        &lt;p&gt;Bagi pemain baru, Situs Toto menawarkan antarmuka yang sederhana dan mudah dipahami. Navigasi yang jelas memudahkan pengguna untuk menemukan permainan, melihat hasil, serta mengelola akun. Kemudahan ini membuat platform cocok digunakan baik oleh pemula maupun pemain berpengalaman.&lt;/p&gt;
        &lt;p&gt;Keunggulan lain dari Situs Toto adalah komitmen terhadap transparansi permainan. Sistem yang adil memastikan setiap hasil permainan berjalan secara objektif tanpa manipulasi. Dengan demikian, pemain dapat menikmati hiburan yang jujur dan profesional.&lt;/p&gt;
        &lt;p&gt;Bergabung dengan Situs Toto memberikan kesempatan untuk merasakan pengalaman bermain togel online dan toto slot dalam satu platform yang lengkap. Kombinasi antara keamanan, kemudahan akses, pasaran beragam, serta layanan profesional menjadikan platform ini pilihan yang tepat bagi siapa saja yang mencari situs terpercaya.&lt;/p&gt;
        &lt;p&gt;Secara keseluruhan, Situs Toto bukan hanya sekadar tempat bermain, tetapi juga platform yang menghadirkan pengalaman digital yang aman, praktis, dan menyenangkan. Dengan akses link resmi dan fitur lengkap, pemain dapat merasakan sendiri keunggulan yang ditawarkan serta menikmati permainan dengan rasa percaya diri yang lebih tinggi.&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>[SwiftUI/UIKit] Handwriting recognition 필기체 인식 (2)</title>
      <link>https://velog.io/@sheep_jh/SwiftUIUIKit-Handwriting-recognition-%ED%95%84%EA%B8%B0%EC%B2%B4-%EC%9D%B8%EC%8B%9D-2</link>
      <guid>https://velog.io/@sheep_jh/SwiftUIUIKit-Handwriting-recognition-%ED%95%84%EA%B8%B0%EC%B2%B4-%EC%9D%B8%EC%8B%9D-2</guid>
      <pubDate>Sun, 15 Feb 2026 06:11:03 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;이전 글에서 UIScribbleInteraction에 대해 알아봤고 이번 글에서는 &lt;strong&gt;UIIndirectScribbleInteraction&lt;/strong&gt;에 대해 알아보겠다.&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;h3 id=&quot;uiindirectscribbleinteraction&quot;&gt;UIIndirectScribbleInteraction&lt;/h3&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;UITextField나처럼 정식적인 텍스트 입력 UI가 아닌 곳에서도 사용자가 손글씨를 써서 텍스트를 입력할 수 있도록 지원해주는 클래스다.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;주요 역할&lt;/code&gt;
        &lt;strong&gt;간접 입력(Indirect Input) 처리&lt;/strong&gt;: 실제 텍스트 입력 필드는 아니지만, 특정 영역을 &amp;quot;글씨 쓰기가 가능한 영역&amp;quot;으로 정의하고 Scribble 엔진과 연결해 준다.&lt;/p&gt;
        &lt;hr&gt;
        &lt;h3 id=&quot;주요-델리게이트-메서드-uiindirectscribbleinteractiondelegate&quot;&gt;주요 델리게이트 메서드 (UIIndirectScribbleInteractionDelegate)&lt;/h3&gt;
        &lt;p&gt;&lt;strong&gt;1. 포커스 관리&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func indirectScribbleInteraction(any UIInteraction, isElementFocused: Self.ElementIdentifier) -&amp;gt; Bool
        func indirectScribbleInteraction(any UIInteraction, focusElementIfNeeded: Self.ElementIdentifier, referencePoint: CGPoint, completion: ((any UIResponder &amp;amp; UITextInput)?) -&amp;gt; Void)
        func indirectScribbleInteraction(any UIInteraction, shouldDelayFocusForElement: Self.ElementIdentifier) -&amp;gt; Bool&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;code&gt;isElementFocused&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;p&gt;역할: 특정 요소가 현재 포커스 상태인지 물어볼 때 사용&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;반환: 포커스 되어 있다면 true, 아니면 false.&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;&lt;code&gt;focusElementIfNeeded&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;p&gt;역할: 시스템이 특정 요소를 활성화(Focus)하라고 요청할 때 호출됨&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;핵심: 여기서 실제 텍스트 입력을 담당할 객체(UITextInput을 채택한 객체)를 completion 클로저를 통해 전달해야 함 (최신문법은 밑에 async으로)&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;&lt;code&gt;shouldDelayFocusForElement&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;역할: 포커스 잡는 것을 잠시 미룰지 결정. 기본적으로는 바로 포커스가 잡히지만, 특정 상황에서 지연이 필요할 때 true를 반환&lt;/li&gt;
        &lt;/ul&gt;
        &lt;hr&gt;
        &lt;p&gt;&lt;strong&gt;2. Scribble 상태 추적&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func indirectScribbleInteraction(any UIInteraction, willBeginWritingInElement: Self.ElementIdentifier)
        func indirectScribbleInteraction(any UIInteraction, didFinishWritingInElement: Self.ElementIdentifier)&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;code&gt;willBeginWritingInElement&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;역할: 사용자가 Apple Pencil로 글씨를 쓰기 시작할 때 호출됨&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;&lt;code&gt;didFinishWritingInElement&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;역할: 사용자가 글씨 쓰기를 마쳤을 때 호출됨&lt;/li&gt;
        &lt;/ul&gt;
        &lt;hr&gt;
        &lt;p&gt;&lt;strong&gt;3. 요소 및 프레임 찾기&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func indirectScribbleInteraction(any UIInteraction, frameForElement: Self.ElementIdentifier) -&amp;gt; CGRect
        func indirectScribbleInteraction(any UIInteraction, requestElementsIn: CGRect, completion: ([Self.ElementIdentifier]) -&amp;gt; Void)&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;code&gt;frameForElement&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;역할: 특정 ID를 가진 요소의 &lt;strong&gt;실제 위치와 크기(CGRect)&lt;/strong&gt;를 시스템에 알려줍&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;&lt;code&gt;requestElementsIn&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;역할: 지정된 영역(CGRect) 안에 있는 모든 텍스트 입력 요소의 ID들을 배열로 묶어서 반환함 (최신문법은 밑에 async으로)&lt;/li&gt;
        &lt;/ul&gt;
        &lt;hr&gt;
        &lt;p&gt;&lt;strong&gt;4. 최신 비동기 메서드 (Swift Concurrency)&lt;/strong&gt;&lt;/p&gt;
        &lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func indirectScribbleInteraction(any UIInteraction, focusElementIfNeeded: Self.ElementIdentifier, referencePoint: CGPoint) async -&amp;gt; (any UIResponder &amp;amp; UITextInput)?
        func indirectScribbleInteraction(any UIInteraction, requestElementsIn: CGRect) async -&amp;gt; [Self.ElementIdentifier]&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;code&gt;focusElementIfNeeded (async)&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;역할: 시스템이 전달해준 ID에 해당하는 실제 입력창 객체(UITextInput)를 찾아 반환&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;&lt;code&gt;requestElementsIn (async)&lt;/code&gt;&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;역할: 지정된 영역(CGRect) 안에 있는 모든 텍스트 입력 요소의 ID들을 배열로 묶어서 반환함&lt;/li&gt;
        &lt;/ul&gt;
        &lt;blockquote&gt;
        &lt;h3 id=&quot;코드-예제&quot;&gt;코드 예제&lt;/h3&gt;
        &lt;/blockquote&gt;
        &lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;// MARK: - 1. SwiftUI에서 사용하기 위한 Representable
        struct IndirectScribbleView: UIViewControllerRepresentable {
        func makeUIViewController(context: Context) -&amp;gt; ScribbleFullExampleViewController {
        return ScribbleFullExampleViewController()
        }
        
        func updateUIViewController(_ uiViewController: ScribbleFullExampleViewController, context: Context) {}
        }
        
        import UIKit
        
        class ScribbleFullExampleViewController: UIViewController {
        
        private let targetTextField = UITextField()
        private let scribbleCanvas = UIView()
        private let elementID = &amp;quot;custom-memo-area&amp;quot;
        
        override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        
        let interaction = UIIndirectScribbleInteraction(delegate: self)
        scribbleCanvas.addInteraction(interaction)
        }
        }
        
        // MARK: - UIIndirectScribbleInteractionDelegate
        extension ScribbleFullExampleViewController: UIIndirectScribbleInteractionDelegate {
        
        // MARK: - [1. 요소 및 프레임 찾기]
        // 시스템이 어느 영역에서 Scribble을 작동시킬지 탐색하는 단계 (2개 메서드)
        
        /// 1-1. [요소 탐색] 사용자가 펜슬로 터치/탐색 중인 rect 안에 어떤 입력 요소(ID)가 있는지 보고합니다.
        func indirectScribbleInteraction(_ interaction: UIInteraction,
        requestElementsIn rect: CGRect,
        completion: @escaping ([String]) -&amp;gt; Void) {
        print(&amp;quot;\n--- 🔍 STEP 1: 요소 탐색 ---&amp;quot;)
        print(&amp;quot;📍 위치: (x: \(Int(rect.origin.x)), y: \(Int(rect.origin.y))), 크기: \(Int(rect.width))x\(Int(rect.height))&amp;quot;)
        completion([elementID])
        }
        
        /// 1-2. [프레임 제공] 특정 ID를 가진 요소의 실제 활성 영역(CGRect)을 시스템에 알려줍니다.
        func indirectScribbleInteraction(_ interaction: UIInteraction,
        frameForElement elementIdentifier: String) -&amp;gt; CGRect {
        let frame = scribbleCanvas.bounds
        print(&amp;quot;📍 1-2. frameForElement: [\(elementIdentifier)] 영역 확정&amp;quot;)
        return frame
        }
        
        
        // MARK: - [2. 포커스 관리]
        // 실제 입력창(TextField)과 펜슬 입력 영역을 연결하는 단계 (3개 메서드)
        
        /// 2-1. [상태 확인] 특정 요소가 현재 포커스(First Responder) 상태인지 확인합니다.
        func indirectScribbleInteraction(_ interaction: UIInteraction,
        isElementFocused elementIdentifier: String) -&amp;gt; Bool {
        let focused = targetTextField.isFirstResponder
        print(&amp;quot;📍 2-1. isElementFocused: \(focused)&amp;quot;)
        return focused
        }
        
        /// 2-2. [활성화 요청] 실제 입력을 받을 객체(UITextInput)를 지정합니다.
        func indirectScribbleInteraction(_ interaction: UIInteraction,
        focusElementIfNeeded elementIdentifier: String,
        referencePoint: CGPoint,
        completion: @escaping ((any UIResponder &amp;amp; UITextInput)?) -&amp;gt; Void) {
        print(&amp;quot;\n--- 🎯 STEP 2: 포커스 활성화 ---&amp;quot;)
        print(&amp;quot;📍 터치 지점: \(Int(referencePoint.x)), \(Int(referencePoint.y))&amp;quot;)
        
        targetTextField.becomeFirstResponder()
        completion(targetTextField)
        }
        
        /// 2-3. [지연 결정] 포커스 시점을 늦춰야 할지 결정합니다.
        func indirectScribbleInteraction(_ interaction: UIInteraction,
        shouldDelayFocusForElement elementIdentifier: String) -&amp;gt; Bool {
        print(&amp;quot;📍 2-3. shouldDelayFocus: false (즉시 실행)&amp;quot;)
        return false
        }
        
        
        // MARK: - [3. Scribble 상태 추적]
        // 글쓰기 시작과 끝에 맞춰 UI 피드백을 주는 단계 (2개 메서드)
        
        /// 3-1. [쓰기 시작] 사용자가 Apple Pencil로 글씨를 쓰기 시작할 때 호출됩니다.
        func indirectScribbleInteraction(_ interaction: UIInteraction,
        willBeginWritingInElement elementIdentifier: String) {
        print(&amp;quot;\n--- ✍️ STEP 3: 쓰기 시작 ---&amp;quot;)
        updateCanvasUI(isWriting: true)
        }
        
        /// 3-2. [쓰기 종료] 입력 및 텍스트 변환이 모두 끝난 시점입니다.
        func indirectScribbleInteraction(_ interaction: UIInteraction,
        didFinishWritingInElement elementIdentifier: String) {
        print(&amp;quot;--- ✅ STEP 4: 쓰기 종료 ---\n&amp;quot;)
        updateCanvasUI(isWriting: false)
        }
        
        private func updateCanvasUI(isWriting: Bool) {
        UIView.animate(withDuration: 0.2) {
        self.scribbleCanvas.layer.borderColor = isWriting ? UIColor.systemBlue.cgColor : UIColor.clear.cgColor
        self.scribbleCanvas.layer.borderWidth = isWriting ? 3 : 0
        self.scribbleCanvas.backgroundColor = isWriting ? .systemGray5 : .systemGray6
        }
        }
        }
        
        // MARK: - Layout Setup
        extension ScribbleFullExampleViewController {
        private func setupUI() {
        view.backgroundColor = .white
        
        scribbleCanvas.backgroundColor = .systemGray6
        scribbleCanvas.layer.cornerRadius = 20
        scribbleCanvas.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(scribbleCanvas)
        
        let label = UILabel()
        label.text = &amp;quot;여기에 펜슬로 써보세요&amp;quot;
        label.font = .systemFont(ofSize: 14, weight: .medium)
        label.textColor = .systemGray
        label.translatesAutoresizingMaskIntoConstraints = false
        scribbleCanvas.addSubview(label)
        
        targetTextField.borderStyle = .roundedRect
        targetTextField.placeholder = &amp;quot;결과창&amp;quot;
        targetTextField.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(targetTextField)
        
        NSLayoutConstraint.activate([
        scribbleCanvas.centerXAnchor.constraint(equalTo: view.centerXAnchor),
        scribbleCanvas.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: -50),
        scribbleCanvas.widthAnchor.constraint(equalToConstant: 350),
        scribbleCanvas.heightAnchor.constraint(equalToConstant: 250),
        
        label.centerXAnchor.constraint(equalTo: scribbleCanvas.centerXAnchor),
        label.centerYAnchor.constraint(equalTo: scribbleCanvas.centerYAnchor),
        
        targetTextField.topAnchor.constraint(equalTo: scribbleCanvas.bottomAnchor, constant: 40),
        targetTextField.centerXAnchor.constraint(equalTo: view.centerXAnchor),
        targetTextField.widthAnchor.constraint(equalToConstant: 300)
        ])
        }
        }
        &lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/sheep_jh/post/1a90a8d9-dd7e-47b5-a6dc-e5a8e053e13b/image.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;이전에는 텍스트 필드 안에만 scribble을 적용할 수 있었다면, 이 예제를 통해서 다른 영역에 글씨를 쓰더라도 해당 텍스트 필드로 잘 입력되는 것을 볼 수 있었다.
        &lt;br&gt;
        &lt;br&gt;&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;h3 id=&quot;🍎-참고&quot;&gt;🍎 참고&lt;/h3&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiindirectscribbleinteraction-1nfjm&quot;&gt;https://developer.apple.com/documentation/uikit/uiindirectscribbleinteraction-1nfjm&lt;/a&gt;&lt;/p&gt;
      </content:encoded>
    </item>
    <item>
      <title>Codwin Digital Arena: Immersive Online Gaming and Strategic Engagement</title>
      <link>https://velog.io/@contenthubsuite/Codwin-Digital-Arena-Immersive-Online-Gaming-and-Strategic-Engagement</link>
      <guid>https://velog.io/@contenthubsuite/Codwin-Digital-Arena-Immersive-Online-Gaming-and-Strategic-Engagement</guid>
      <pubDate>Sun, 15 Feb 2026 06:10:28 GMT</pubDate>
      <content:encoded>
        &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/contenthubsuite/post/c1bc793c-16fc-4b76-8cc3-706550d13775/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;https://codwin.vip&quot;&gt;Codwin&lt;/a&gt; has steadily emerged as a prominent platform for online gaming enthusiasts who appreciate both technical reliability and thoughtfully structured content. Unlike platforms that prioritize flashy visuals over functionality, Codwin focuses on creating a seamless experience where players can explore diverse titles without facing interruptions or confusing navigation. The platform’s interface is intuitive, featuring clearly defined categories, easy-to-access menus, and responsive controls that perform equally well on desktop and mobile devices. This consistency allows users to focus entirely on gameplay and strategy rather than worrying about lag or technical delays, creating a more immersive environment for both casual players and those seeking structured sessions.&lt;/p&gt;
        &lt;p&gt;One of the most appealing aspects of Codwin is its extensive library of feature-rich games. The platform emphasizes interactive mechanics that reward observation and careful engagement rather than impulsive actions. Many titles include cascading sequences, multiplier enhancements, stacked elements, and layered bonus rounds that activate under specific conditions. Each game is designed to maintain player interest over extended sessions, using dynamic pacing and varying interactive opportunities to encourage thoughtful participation. Community discussions often recommend that players familiarize themselves with game instructions and feature activation rules before beginning longer sessions. By understanding how cascading sequences trigger or how multipliers influence outcomes, users can develop strategies that maximize their engagement and allow for a more measured, deliberate approach.&lt;/p&gt;
        &lt;p&gt;Codwin’s approach to gameplay emphasizes the importance of rhythm and timing. Some games gradually build momentum before entering enhanced interactive rounds, while others deliver frequent feature opportunities. Recognizing the patterns of each title is key to creating a focused experience. Many experienced players recommend observing early gameplay to determine pacing, volatility, and how features unfold over multiple rounds. Concentrating on one game during a session, rather than rapidly switching between titles, allows players to deepen their understanding of mechanics and develop predictive strategies for feature timing.&lt;/p&gt;
        &lt;p&gt;In addition to game mechanics, session management plays a central role in the Codwin experience. Players are encouraged to define objectives for each visit, whether that involves exploring newly released content, completing event challenges, or analyzing specific features. Establishing time limits helps maintain balance and focus, ensuring that sessions remain structured rather than arbitrary. Reflection after each session is equally important; reviewing outcomes and noting feature activation frequency enables players to adjust strategies for future gameplay. This thoughtful approach transforms each session into a learning opportunity, reinforcing both awareness and strategic decision-making.&lt;/p&gt;
        &lt;p&gt;Codwin also incorporates seasonal events and leaderboard campaigns that provide additional structure. These events create measurable goals, motivating players to engage purposefully while exploring different categories and mechanics. Participation in such events often requires attention to detail and strategic pacing, as success depends on both understanding the game’s features and maintaining focus throughout extended sessions. Players often report that the combination of technical reliability, engaging mechanics, and structured challenges creates a highly rewarding digital experience that encourages repeated engagement and continuous learning.&lt;/p&gt;
        &lt;p&gt;Another distinguishing feature of Codwin is the community aspect. Players frequently share insights on feature strategies, session management, and pacing techniques. This exchange of information fosters a collaborative environment where users can learn from each other’s observations. Discussions often cover topics such as identifying patterns in cascading sequences, predicting bonus activations, or timing multipliers effectively. The collective knowledge enhances the individual player experience, allowing users to refine their approach and feel part of a larger, strategic community.&lt;/p&gt;
        &lt;p&gt;Ultimately, Codwin represents a well-rounded online gaming platform where stability, interactive mechanics, and thoughtful engagement intersect. By emphasizing preparation, observation, and structured participation, the platform encourages players to approach gameplay with awareness and strategy rather than relying solely on chance or impulsive decisions. Whether exploring feature-rich titles, participating in seasonal challenges, or learning from community insights, Codwin offers an immersive and rewarding digital experience that balances entertainment with thoughtful engagement.&lt;/p&gt;
      </content:encoded>
    </item>
  </channel>
</rss>