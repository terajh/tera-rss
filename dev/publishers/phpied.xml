<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>dev RSS - Stoyan Stefanov</title>
    <link>https://www.phpied.com/</link>
    <description>Stoyan Stefanov RSS 피드</description>
    <lastBuildDate>Mon, 23 Feb 2026 16:18:54 GMT</lastBuildDate>
    <item>
      <title>Quick and dirty linting</title>
      <link>https://www.phpied.com/quick-and-dirty-linting/</link>
      <guid>https://www.phpied.com/quick-and-dirty-linting/</guid>
      <pubDate>Fri, 13 Feb 2026 07:38:31 GMT</pubDate>
      <content:encoded>This post is another installment of the series dedicated to building sightread.org. Parts 1, 2, 3, 4, 5, 6. I&apos;ve been using TypeScript (actually JSDoc + tsc --noEmit) as my linter for a while. Well, TBH, I didn&apos;t do it intentionally, it&apos;s just something Claude does outta the box. I saw some linting going on [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>Measuring SVG rendering time</title>
      <link>https://www.phpied.com/measuring-svg-rendering-time/</link>
      <guid>https://www.phpied.com/measuring-svg-rendering-time/</guid>
      <pubDate>Thu, 05 Feb 2026 07:32:43 GMT</pubDate>
      <content:encoded>The questions Is rendering large SVGs significantly slower than smaller ones? Is there a cut-off size above which things are terrible? And what if these SVGs were PNGs, just for giggles. To answer this let&apos;s generate a bunch of test images and render them! The code is here Test images A Python script (gen.py) generates [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>Minimum viable image optimization</title>
      <link>https://www.phpied.com/minimum-viable-image-optimization/</link>
      <guid>https://www.phpied.com/minimum-viable-image-optimization/</guid>
      <pubDate>Fri, 30 Jan 2026 00:10:00 GMT</pubDate>
      <content:encoded>This post is another installment of the series dedicated to building sightread.org. Parts 1, 2, 3, 4, 5. When I was writing the last blog post, it occurred to me that I&apos;m still optimizing images by hand. I think dropping images into ImageOptim is a second nature for me. So I decided to update my [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>Oops, I build.js’d it again</title>
      <link>https://www.phpied.com/oops-i-build-jsd-it-again/</link>
      <guid>https://www.phpied.com/oops-i-build-jsd-it-again/</guid>
      <pubDate>Sat, 24 Jan 2026 22:20:22 GMT</pubDate>
      <content:encoded>Who amongst us has not created a blogging software of some fashion or another? I know I have, many times. My latest (joke-y) attempt was Lizzy.js. The desire to go into a writing mode and don&apos;t worry about anything else is always strong. Even a dead simple self-hosted WordPress is often too much. Just give [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>Type checking without the muck</title>
      <link>https://www.phpied.com/type-checking-without-the-muck/</link>
      <guid>https://www.phpied.com/type-checking-without-the-muck/</guid>
      <pubDate>Mon, 12 Jan 2026 06:44:12 GMT</pubDate>
      <content:encoded>This is part 4 of a series about hacking on sightread.org with minimal tooling/building and maximum web platform-ing: Part 1: Import JavaScript like it&apos;s 2026 Part 2: Maximally Minimal Build Process Part 3: Do It Yourself: code coverage and testing Now let&apos;s talk about types, the type of types that check if you made a [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>Do It Yourself: code coverage and testing</title>
      <link>https://www.phpied.com/do-it-yourself-code-coverage-and-testing/</link>
      <guid>https://www.phpied.com/do-it-yourself-code-coverage-and-testing/</guid>
      <pubDate>Tue, 06 Jan 2026 00:47:36 GMT</pubDate>
      <content:encoded>This is what turns out to be a part 3 of a series about building sightread.org with minimal tooling: Part 1: Import JavaScript like it&apos;s 2026 Part 2: Maximally Minimal Build Process The previous posts covered how I structure js modules for parallel loading and how to build a production-ready app with a 200-line build [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>Maximally minimal build process</title>
      <link>https://www.phpied.com/maximally-minimal-build-process/</link>
      <guid>https://www.phpied.com/maximally-minimal-build-process/</guid>
      <pubDate>Sun, 04 Jan 2026 23:00:42 GMT</pubDate>
      <content:encoded>In my previous post I described how I set up sightread.org with no build process and modern JavaScript. The goal was raw ES modules, no transpilation, no bundling, just &amp;#60;script type=&quot;module&quot;&amp;#62; and we&apos;re off. That worked great for a minute but I wanted just one more thing: long-lived immutable JS resources that can be cached [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>Import JavaScript like it’s 2026</title>
      <link>https://www.phpied.com/import-javascript-like-its-2026/</link>
      <guid>https://www.phpied.com/import-javascript-like-its-2026/</guid>
      <pubDate>Wed, 29 Oct 2025 01:13:18 GMT</pubDate>
      <content:encoded>I started this new project called sightread.org to generate music to practice sight reading. (Still early days, it works with rhythms only). I wanted to go for no build process and modern JS and modern HTML. How modern is modern? IE8? IE10? In my head when I think &quot;modern&quot; it always brings an image of [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>Introducing Lizzy.js</title>
      <link>https://www.phpied.com/introducing-lizzy-js/</link>
      <guid>https://www.phpied.com/introducing-lizzy-js/</guid>
      <pubDate>Sun, 01 Jun 2025 04:09:37 GMT</pubDate>
      <content:encoded>I created this joke-y &quot;framework&quot; to build a website, or a blog if you will, from markdown files. The idea is to (ab)use Apache&apos;s default directory listing. The &quot;index&quot; page reads the Apache&apos;s HTML of a given directory and produces a list of articles. When the user clicks, the markdown file (corresponding to an article) [&amp;#8230;]</content:encoded>
    </item>
    <item>
      <title>First timid steps in Rust</title>
      <link>https://www.phpied.com/first-timid-steps-in-rust/</link>
      <guid>https://www.phpied.com/first-timid-steps-in-rust/</guid>
      <pubDate>Sat, 01 Feb 2025 00:00:43 GMT</pubDate>
      <content:encoded>I&apos;m working on a new site at https://highperformancewebfonts.com/ where I&apos;m doing everything wrong. E.g. using a joke-y client-side-only rendering of articles from .md files (Hello Lizzy.js) Since there&apos;s no static generation, there was no RSS feed. And since someone asked, I decided to add one. But in the spirit of learning-while-doing, I thought I should [&amp;#8230;]</content:encoded>
    </item>
  </channel>
</rss>